<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Expect · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Expect · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="テストを作成する時に、値が特定の条件に合致することを確認する必要がよくあるでしょう。 `expect` によって様々な事柄を検証するための数多くの&quot;マッチャ&quot;を利用することができます。"/><meta property="og:image" content="/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="/jest/css/main.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/ja/getting-started.html" target="_self">ドキュメント</a></li><li><a href="/jest/docs/ja/api.html" target="_self">API</a></li><li><a href="/jest/ja/help.html" target="_self">ヘルプ</a></li><li><a href="/jest/blog" target="_self">ブログ</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>日本語</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/es-ES">Español</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ro">Română</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ja/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ja/api.html">Globals</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/ja/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/cli.html">Jest CLI Options</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ja/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/testing-frameworks.html">Web フレームワークのテスト</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ja/snapshot-testing.html">スナップショットテスト</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ja/troubleshooting.html">Troubleshooting</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Expect</h1></header><article><div><span><p>テストを作成する時に、値が特定の条件に合致することを確認する必要がよくあるでしょう。 <code>expect</code> によって様々な事柄を検証するための数多くの&quot;マッチャ&quot;を利用することができます。</p>
<h2><a class="anchor" name=""></a>メソッド <a class="hash-link" href="#">#</a></h2>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" name=""></a>リファレンス <a class="hash-link" href="#">#</a></h2>
<h3><a class="anchor" name="expectvalue"></a><code>expect(value)</code> <a class="hash-link" href="#expectvalue">#</a></h3>
<p><code>expect</code> は値をテストしたい時に毎回使用する関数です。 <code>expect</code> のみを呼び出すということはほとんどありません。 代わりに、 値について何らかの事をアサートする&quot;マッチャ&quot;関数とともに<code>expect</code> を使用することでしょう。</p>
<p>この事は例を見れば簡単に理解できます。 <code>'grapefruit'</code>という文字列を返すはずの<code>bestLaCroixFlavor()</code>メソッドがあるとしましょう。 以下のようにテストするでしょう:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best flavor is grapefruit'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).toBe(<span class="hljs-string">'grapefruit'</span>);
});
</code></pre>
<p>このケースでは、 <code>toBe</code>がマッチャ関数です。様々な事をテストするのを手助けする数多くの異なるマッチャ関数があり、以下にまとめられています。</p>
<p><code>expect</code>への引数はコードが生成する値であるべきであり、いかなるマッチャへの引数は正解の値であるべきです。 それらを混同して使用すれば、テストは動作するものの、失敗したテストから出力されるエラーメッセージはおかしなものになります。</p>
<h3><a class="anchor" name="expectextendmatchers"></a><code>expect.extend(matchers)</code> <a class="hash-link" href="#expectextendmatchers">#</a></h3>
<p>Jestに独自のマッチャを追加したい場合は <code>expect.extend</code>を使用します。 例えば、整数論のライブラリをテストしていて、数字が他の数字によって割り切れることを頻繁にアサートしているとしましょう。 それを<code>toBeDivisibleBy</code>マッチャに抽象化することができます:</p>
<pre><code class="language-js">expect.extend({
  toBeDivisibleBy(received, argument) {
    <span class="hljs-keyword">const</span> pass = (received % argument == <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> not to be divisible by <span class="hljs-subst">${argument}</span>`</span>
        ),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (<span class="hljs-string">`expected <span class="hljs-subst">${received}</span> to be divisible by <span class="hljs-subst">${argument}</span>`</span>),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'even and odd numbers'</span>, () =&gt; {
  expect(<span class="hljs-number">100</span>).toBeDivisibleBy(<span class="hljs-number">2</span>);
  expect(<span class="hljs-number">101</span>).not.toBeDivisibleBy(<span class="hljs-number">2</span>);
});
</code></pre>
<p>マッチャ は、2つのキーを持つオブジェクトを返す必要があります。 <code>pass</code>キーはマッチャの条件に合致するかどうかを示し、 <code>message</code>キーは失敗した場合にエラーメッセージを返す引数なしの関数を提供します。 したがって、<code>pass</code>が偽なら、 <code>message</code>は<code>expect(x).yourMatcher()</code>が失敗した場合のエラーメッセージを返す必要があります。 <code>pass</code>が真だった場合、 <code>message</code>は<code>expect(x).not.yourMatcher()</code>が失敗した場合のエラーメッセージを返す必要があります。</p>
<p>これらのヘルパー関数は独自マッチャの<code>this</code>内で確認することができます。</p>
<h4><a class="anchor" name="thisisnot"></a><code>this.isNot</code> <a class="hash-link" href="#thisisnot">#</a></h4>
<p>マッチャがアサーションを反転させる否定の修飾子 <code>.not</code>を付けて呼ばれたかどうかを示す真偽値です。</p>
<h4><a class="anchor" name="thisequalsa-b"></a><code>this.equals(a, b)</code> <a class="hash-link" href="#thisequalsa-b">#</a></h4>
<p>２つのオブジェクトが同じ値を(再帰的に) 持つ場合に <code>true</code>を返す深い等価関数です。</p>
<h4><a class="anchor" name="thisutils"></a><code>this.utils</code> <a class="hash-link" href="#thisutils">#</a></h4>
<p><a href="https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils"><code>jest-matcher-utils</code></a>からexportされたもので主に構成される<code>this.utils</code>から利用できる多数の便利なツールがあります。</p>
<p>最も有用なものにエラーメッセージを見やすくフォーマットする <code>matcherHint</code>、 <code>printExpected</code> そして<code>printReceived</code>があります。 例えば、 <code>toBe</code> マッチャの実装を見てみましょう:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> diff = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-diff'</span>);
expect.extend({
  toBe(received, expected) {
    <span class="hljs-keyword">const</span> pass = received === expected;

    <span class="hljs-keyword">const</span> message = pass
      ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.not.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to not be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>
      : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> diffString = diff(expected, received, {
          <span class="hljs-attr">expand</span>: <span class="hljs-keyword">this</span>.expand,
        });
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span> +
        (diffString ? <span class="hljs-string">`\n\nDifference:\n\n<span class="hljs-subst">${diffString}</span>`</span> : <span class="hljs-string">''</span>);
      };

    <span class="hljs-keyword">return</span> {<span class="hljs-attr">actual</span>: received, message, pass};
  },
});
</code></pre>
<p>上記のコードはこのような出力をします:</p>
<pre><code>  expect(received).toBe(expected)

    Expected value to be (using ===):
      &quot;banana&quot;
    Received:
      &quot;apple&quot;
</code></pre>
<p>アサーションに失敗した場合、エラーメッセージは利用者がその問題を迅速に解決できるようになるべく多くのシグナルを与えるものであるべきです。 独自アサーションの利用者が良い開発体験を得られるよう正確なエラーメッセージを作成する必要があります。</p>
<h3><a class="anchor" name="expectanything"></a><code>expect.anything()</code> <a class="hash-link" href="#expectanything">#</a></h3>
<p><code>expect.anything()</code> は、<code>null</code> または <code>undefined</code> を除くものすべてに一致します。 <code>toEqual</code> または <code>toBeCalledWith</code> の内側でリテラル値の代わりに使用できます。 例えば、モック関数がnullでない引数を与えられて呼び出されたことを確認するには:</p>
<pre><code class="language-js">test(<span class="hljs-string">'map calls its argument with a non-null argument'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  [<span class="hljs-number">1</span>].map(mock);
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h3><a class="anchor" name="expectanyconstructor"></a><code>expect.any(constructor)</code> <a class="hash-link" href="#expectanyconstructor">#</a></h3>
<p><code>expect.any(constructor)</code> は与えられたコンストラクタで生成されたもの全てに一致します。 <code>toEqual</code> または <code>toBeCalledWith</code> の内側でリテラル値の代わりに使用できます。 例えば、モック関数が数字の引数を与えられて呼び出されたことを確認するには:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randocall</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> fn(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>));
}

test(<span class="hljs-string">'randocall calls its callback with a number'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(<span class="hljs-built_in">Number</span>));
});
</code></pre>
<h3><a class="anchor" name="expectarraycontainingarray"></a><code>expect.arrayContaining(array)</code> <a class="hash-link" href="#expectarraycontainingarray">#</a></h3>
<p><code>expect.arrayContaining(array)</code> は受け取った配列が期待される配列の要素全てを含む場合に一致します。 つまり受け取った配列は期待される配列を <strong>包含</strong> するということです。 したがって受け取る配列が期待される配列に含まれ<strong>ない</strong>要素を含んでいても一致します。</p>
<p>以下のケースでリテラル値の代わりに使用できます:</p>
<ul>
<li><code>toEqual</code> または <code>toBeCalledWith</code>の中</li>
<li><code>objectContaining</code> または <code>toMatchObject</code>のプロパティとマッチさせる場合</li>
</ul>
<pre><code class="language-js">describe(<span class="hljs-string">'arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'Beware of a misunderstanding! A sequence of dice rolls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  it(<span class="hljs-string">'matches even with an unexpected number 7'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match without an expected number 2'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" name="expectassertionsnumber"></a><code>expect.assertions(number)</code> <a class="hash-link" href="#expectassertionsnumber">#</a></h3>
<p><code>expect.assertions(number)</code> はテスト中に特定の数だけアサーションが呼び出されたことを確認します。 非同期のコードをテストにおいて、コールバック中のアサーションが実際に呼ばれたことを確認する際にしばしば便利です。</p>
<p>例えば、 <code>callback1</code> と <code>callback2</code>の２つのコールバックを受けとる<code>doAsync</code>関数があったとしたら、その関数は未知の順序で両方を呼び出します。 以下のコードでテストできます:</p>
<pre><code class="language-js">test(<span class="hljs-string">'doAsync calls both callbacks'</span>, () =&gt; {
  expect.assertions(<span class="hljs-number">2</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p><code>expect.assertions(2)</code>を呼び出すことで両方のコールバックが実際に呼ばれたことを確認できます。</p>
<h3><a class="anchor" name="expecthasassertions"></a><code>expect.hasAssertions()</code> <a class="hash-link" href="#expecthasassertions">#</a></h3>
<p><code>expect.hasAssertions()</code>はテスト中で少なくとも1回はアサーションが呼び出されたことを確認します。 非同期のコードをテストにおいて、コールバック中のアサーションが実際に呼ばれたことを確認する際にしばしば便利です。</p>
<p>例えば状態を取り扱ういくつかの関数があったとしましょう。 <code>prepareState</code> は状態オブジェクトとともにコールバックを呼び出し、<code>validateState</code> はその状態オブジェクトを確認し、 <code>waitOnState</code>は<code>prepareState</code> のコールバックが完了するまで待つpromiseを返します。 以下のコードでテストできます:</p>
<pre><code class="language-js">est(<span class="hljs-string">'prepareState prepares a valid state'</span>, () =&gt; {
  expect.hasAssertions();
  prepareState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    expect(validateState(state)).toBeTruthy();
  });
  <span class="hljs-keyword">return</span> waitOnState();
});
</code></pre>
<p><code>expect.hasAssertions()</code>は <code>prepareState</code>のコールバックが実際に呼ばれたことを確認します。</p>
<h3><a class="anchor" name="expectobjectcontainingobject"></a><code>expect.objectContaining(object)</code> <a class="hash-link" href="#expectobjectcontainingobject">#</a></h3>
<p><code>expect.objectContaining(object)</code> は期待されたプロパティに再帰的に一致する、いかなる受け取ったオブジェクトにも一致します。 つまり期待されるオブジェクトは受け取ったオブジェクトの <strong>一部分</strong> であるということです。 したがって受け取ったオブジェクトが期待されるオブジェクトに含まれ<strong>ない</strong>プロパティを含んでいても一致します。</p>
<p>期待されるオブジェクトのプロパティにリテラル値を設定する代わりに、<code>expect.anything()</code>などのマッチャを使用することができます。</p>
<p>例えば、<code>onPress</code>関数が<code>Event</code> オブジェクトと共に呼ばれ、eventが <code>event.x</code> と<code>event.y</code> プロパティを持っていることだけ確認できれば良いと考えましょう。 以下のようにできます:</p>
<pre><code class="language-js">test(<span class="hljs-string">'onPress gets called with the right thing'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(expect.objectContaining({
    <span class="hljs-attr">x</span>: expect.any(<span class="hljs-built_in">Number</span>),
    <span class="hljs-attr">y</span>: expect.any(<span class="hljs-built_in">Number</span>),
  }));
});
</code></pre>
<h3><a class="anchor" name="expectstringcontainingstring"></a><code>expect.stringContaining(string)</code> <a class="hash-link" href="#expectstringcontainingstring">#</a></h3>
<h5><a class="anchor" name="jest-1900"></a>jest バージョン<strong>19.0.0+</strong>で利用可能 <a class="hash-link" href="#jest-1900">#</a></h5>
<p><code>expect.stringContaining(string)</code>は期待された文字列とぴったり一致する受け取った文字列と一致します。</p>
<h3><a class="anchor" name="expectstringmatchingregexp"></a><code>expect.stringMatching(regexp)</code> <a class="hash-link" href="#expectstringmatchingregexp">#</a></h3>
<p><code>expect.stringMatching(regexp)</code> は期待する正規表現に合致する受け取った文字列と一致します。</p>
<p>以下のケースでリテラル値の代わりに使用できます:</p>
<ul>
<li><code>toEqual</code> または <code>toBeCalledWith</code>の中</li>
<li><code>arrayContaining</code>の要素とマッチさせる場合</li>
<li><code>objectContaining</code> または <code>toMatchObject</code>のプロパティとマッチさせる場合</li>
</ul>
<p>この例では<code>expect.arrayContaining</code>内の<code>expect.stringMatching</code> によって、複数の非対称なマッチャをネストする方法も示します。</p>
<pre><code class="language-js">describe(<span class="hljs-string">'stringMatching in arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [
    expect.stringMatching(<span class="hljs-regexp">/^Alic/</span>),
    expect.stringMatching(<span class="hljs-regexp">/^[BR]ob/</span>),
  ];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alicia'</span>, <span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" name="expectaddsnapshotserializerserializer"></a><code>expect.addSnapshotSerializer(serializer)</code> <a class="hash-link" href="#expectaddsnapshotserializerserializer">#</a></h3>
<p><code>expect.addSnapshotSerializer</code>を使用して、アプリケーション独自のデータ構造をフォーマットするモジュールを追加することができます。</p>
<p>個々のテストファイルにおいては、JavaScriptに組み込みの型やReactの要素のデフォルトのスナップショットのシリアライザよりも<code>snapshotSerializers</code>設定で追加されたモジュールが優先され、それらの全てのモジュールより(このAPIで) 追加されたモジュールは優先されます。 最後に追加されたモジュールが最初に確認されるモジュールになります。</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> serializer <span class="hljs-keyword">from</span> <span class="hljs-string">'my-serializer-module'</span>;
expect.addSnapshotSerializer(serializer);

<span class="hljs-comment">// affects expect(value).toMatchSnapshot() assertions in the test file</span>
</code></pre>
<p><code>snapshotSerializers</code> 設定で追加するのではなく、個々のテストファイルでスナップショットのシリアライザをつい以下する場合は:</p>
<ul>
<li>依存関係を暗黙的でなく明示的なものにしてください。</li>
<li><a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>が利用できなくなるような設定は避けてください。</li>
</ul>
<p>詳細については<a href="/jest/docs/ja/configuration.html#snapshotserializers-array-string"> configuring Jest</a> を参照してください。</p>
<h3><a class="anchor" name="not"></a><code>.not</code> <a class="hash-link" href="#not">#</a></h3>
<p>何かをテストする方法が分かっているなら、 <code>.not</code>によってその反対の事をテストできます。例えば以下のコードでは、ラクロワ飲料で一番美味しいのはココナッツ味ではないことをテストでします。</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best flavor is not coconut'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).not.toBe(<span class="hljs-string">'coconut'</span>);
});
</code></pre>
<h3><a class="anchor" name="resolves"></a><code>.resolves</code> <a class="hash-link" href="#resolves">#</a></h3>
<h5><a class="anchor" name="jest-2000"></a>jest バージョン<strong>20.0.0+</strong>で利用可能 <a class="hash-link" href="#jest-2000">#</a></h5>
<p>追加のマッチャをチェーンするためにに完了したpromiseの値を取り出すには<code>resolves</code>を使用して下さい。promiseがrejectされた場合はアサーションは失敗します。</p>
<p>例えば、以下のコードではpromiseが完了した結果の値が<code>'lemon'</code>であることをテストします:</p>
<pre><code class="language-js">test(<span class="hljs-string">'resolves to lemon'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
});
</code></pre>
<p>また、<code>async/await</code> を<code>.resolves</code>と組み合わせて使うことができます。</p>
<pre><code class="language-js">test(<span class="hljs-string">'resolves to lemon'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.not.toBe(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" name="rejects"></a><code>.rejects</code> <a class="hash-link" href="#rejects">#</a></h3>
<h5><a class="anchor" name="jest-2000"></a>jest バージョン<strong>20.0.0+</strong>で利用可能 <a class="hash-link" href="#jest-2000">#</a></h5>
<p>追加のマッチャをチェーンするためににrejectされたpromiseの理由を取り出すには <code>.rejects</code>を使用して下さい。promiseが完了した場合はアサーションは失敗します。</p>
<p>For example, this code tests that the promise rejects with reason <code>'octopus'</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'rejects to octopus'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'octopus'</span>)).rejects.toBe(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<p>Alternatively, you can use <code>async/await</code> in combination with <code>.rejects</code>.</p>
<pre><code class="language-js">test(<span class="hljs-string">'rejects to octopus'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'octopus'</span>)).rejects.toBe(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobevalue"></a><code>.toBe(value)</code> <a class="hash-link" href="#tobevalue">#</a></h3>
<p><code>toBe</code> は値が期待した通りのものかのみを確認します。 <code>===</code>により厳密な等価性を検証します。</p>
<p>例えば以下のコードでは <code>can</code> オブジェクトのいくつかのプロパティを検証します。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> can = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'pamplemousse'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the can'</span>, () =&gt; {
  test(<span class="hljs-string">'has 12 ounces'</span>, () =&gt; {
    expect(can.ounces).toBe(<span class="hljs-number">12</span>);
  });

  test(<span class="hljs-string">'has a sophisticated name'</span>, () =&gt; {
    expect(can.name).toBe(<span class="hljs-string">'pamplemousse'</span>);
  });
});
</code></pre>
<p>浮動小数点数に <code>toBe</code> を使用しないでください。 例えば、JavaScriptでは数値の丸めによって<code>0.2 + 0.1</code>と <code>0.3</code>は厳密には等価ではありません。 浮動小数点がある場合は、代わりに<code>.toBeCloseTo</code>を使用してください。</p>
<h3><a class="anchor" name="tohavebeencalled"></a><code>.toHaveBeenCalled()</code> <a class="hash-link" href="#tohavebeencalled">#</a></h3>
<p>次の別名でも同様となります: <code>.toBeCalled()</code></p>
<p>モック関数が呼ばれたかを確認するには<code>.toHaveBeenCalled</code>を使用して下さい。</p>
<p>例えば<code>drink</code>関数を引数に取って全ての今ある飲み物に適用する<code>drinkAll(drink, flavor)</code>関数があるとしましょう。 <code>drink</code>が <code>'lemon'</code>味に適用されても, <code>'octopus'</code>味には 適用されないという事を確認したいでしょう。<code>'octopus'</code>味なんて奇妙であって欲しいとは思えません。 このテストスイートでテストすることができます:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'drinkAll'</span>, () =&gt; {
  test(<span class="hljs-string">'drinks something lemon-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'lemon'</span>);
    expect(drink).toHaveBeenCalled();
  });

  test(<span class="hljs-string">'does not drink something octopus-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'octopus'</span>);
    expect(drink).not.toHaveBeenCalled();
  });
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledtimesnumber"></a><code>.toHaveBeenCalledTimes(number)</code> <a class="hash-link" href="#tohavebeencalledtimesnumber">#</a></h3>
<p>モック関数が期待した回数だけ呼ばれたことを確認するには<code>.toHaveBeenCalledTimes</code> を使用して下さい。</p>
<p>例えば<code>drink</code>関数を引数に取って渡された飲み物の配列に適用する <code>drinkEach(drink, Array&lt;flavor&gt;)</code> 関数があるとしましょう。 ｄrink関数が正しい回数だけ呼ばれたことを確認したいでしょう。 このテストスイートでテストすることができます:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinkEach drinks each drink'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  drinkEach(drink, [<span class="hljs-string">'lemon'</span>, <span class="hljs-string">'octopus'</span>]);
  expect(drink).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledwitharg1-arg2-"></a><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeencalledwitharg1-arg2-">#</a></h3>
<p>次の別名でも同様となります: <code>.toBeCalledWith()</code></p>
<p>モック関数が特定の引数を与えられて呼び出されたことを確認するには <code>.toHaveBeenCalledWith</code> を使用して下さい。</p>
<p>例えば <code>register</code> 関数で飲み物を登録でき、<code>applyToAll(f)</code> は 関数<code>f</code> を全ての登録された飲み物に適用するものとしましょう。 この振る舞いを確認するコードは、下記のように書けるでしょう:</p>
<pre><code class="language-js">test(<span class="hljs-string">'registration applies correctly to orange La Croix'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage = <span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'orange'</span>);
  register(beverage);
  <span class="hljs-keyword">const</span> f = jest.fn();
  applyToAll(f);
  expect(f).toHaveBeenCalledWith(beverage);
});
</code></pre>
<h3><a class="anchor" name="tohavebeenlastcalledwitharg1-arg2-"></a><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeenlastcalledwitharg1-arg2-">#</a></h3>
<p>次の別名でも同様となります: <code>.lastCalledWith(arg1, arg2, ...)</code></p>
<p>モック関数がある場合は <code>.toHaveBeenLastCalledWith</code>を使用して、最後の呼び出しがどんな引数を渡されたかをテストすることができます。 例えば 複数の風味に対して関数<code>f</code>を適用する<code>applyToAllFlavors(f)</code> 関数があり、関数fが最後に操作した風味が<code>'mango'</code>だったとしましょう。 以下のようにテストコードを書くことができます。</p>
<pre><code class="language-js">test(<span class="hljs-string">'applying to all flavors does mango last'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  applyToAllFlavors(drink);
  expect(drink).toHaveBeenLastCalledWith(<span class="hljs-string">'mango'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeclosetonumber-numdigits"></a><code>.toBeCloseTo(number, numDigits)</code> <a class="hash-link" href="#tobeclosetonumber-numdigits">#</a></h3>
<p>浮動小数点に対して厳密な比較を行うのは悪い考えです。丸めるという事は直感的なものが上手く行かなくなることを意味します。</p>
<pre><code class="language-js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBe(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// Fails!</span>
});
</code></pre>
<p>JavaScriptでは<code>0.2 + 0.1</code> は実際には <code>0.30000000000000004</code>なのでこのテストは失敗します。残念。</p>
<p>代わりに <code>.toBeCloseTo</code>を使用して下さい。 <code>numDigits</code>で小数点以下の何位まで確認するのかを制御できます。 例えば、 <code>0.2 + 0.1</code>が <code>0.3</code>に等しいことを小数点５位の精度で確認したい場合は、このようにテストできます:</p>
<pre><code class="language-js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBeCloseTo(<span class="hljs-number">0.3</span>, <span class="hljs-number">5</span>);
});
</code></pre>
<p><code>numDigits</code>のデフォルト値は２で、大抵のケースにおいて適切なデフォルト値であると証明されています。</p>
<h3><a class="anchor" name="tobedefined"></a><code>.toBeDefined()</code> <a class="hash-link" href="#tobedefined">#</a></h3>
<p>変数がundefinedでないことを確認するには <code>.toBeDefined</code>を使用します。 例えば、関数 <code>fetchNewFlavorIdea()</code>が<em>何らかの値</em>を返すことを確認しただけなら、このように書くことができます。</p>
<pre><code class="language-js">test(<span class="hljs-string">'there is a new flavor idea'</span>, () =&gt; {
  expect(fetchNewFlavorIdea()).toBeDefined();
});
</code></pre>
<p><code>expect(fetchNewFlavorIdea()).not.toBe(undefined)</code>とも書くことができますが、<code>undefined</code>を直接コード内で参照するのは避けたほうが実務上良いでしょう。</p>
<h3><a class="anchor" name="tobefalsy"></a><code>.toBeFalsy()</code> <a class="hash-link" href="#tobefalsy">#</a></h3>
<p>値がどのようなものかを気にせず、真偽値のコンテクストの中で値が偽であることを確認したい場合は<code>.toBeFalsy</code> を使用して下さい。例えば、以下のようなアプリケーションコードがあったとします:</p>
<pre><code class="language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (!getErrors()) {
  drinkMoreLaCroix();
}
</code></pre>
<p><code>getErrors</code>がどんなものを返すかは特に気にしないでしょう - <code>false</code>、<code>null</code>、あるいは ``を返すかもしれませんが、それでもコードは動作します。 だからラクロワ飲料を飲んだ後でエラーが無いことをテストしたければ、このように書くことができます:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinking La Croix does not lead to errors'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(getErrors()).toBeFalsy();
});
</code></pre>
<p>JavaScriptでは、偽と類推される６つの値があります: <code>false</code>、 ``、 <code>''</code>、 <code>null</code>、 <code>undefined</code>、 そして <code>NaN</code>です。他の全ては真と類推されます。</p>
<h3><a class="anchor" name="tobegreaterthannumber"></a><code>.toBeGreaterThan(number)</code> <a class="hash-link" href="#tobegreaterthannumber">#</a></h3>
<p>浮動小数点数を比較するには、 <code>toBeGreaterThan</code>が使用できます。例えば、 <code>ouncesPerCan()</code>が１０オンスより大きい値を返すことをテストしたい場合は、以下のように書いて下さい:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is more than 10'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThan(<span class="hljs-number">10</span>);
});
</code></pre>
<h3><a class="anchor" name="tobegreaterthanorequalnumber"></a><code>.toBeGreaterThanOrEqual(number)</code> <a class="hash-link" href="#tobegreaterthanorequalnumber">#</a></h3>
<p>浮動小数点数を比較するには、 <code>toBeGreaterThanOrEqual</code>が使用できます。例えば、 <code>ouncesPerCan()</code>が少なくとも１２オンス以上の値を返すことをテストしたい場合は、以下のように書いて下さい:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is at least 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthannumber"></a><code>.toBeLessThan(number)</code> <a class="hash-link" href="#tobelessthannumber">#</a></h3>
<p>浮動小数点数を比較するには、 <code>toBeLessThan</code>が使用できます。例えば、 <code>ouncesPerCan()</code>が２０オンスより小さい値を返すことをテストしたい場合は、以下のように書いて下さい:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is less than 20'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThan(<span class="hljs-number">20</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthanorequalnumber"></a><code>.toBeLessThanOrEqual(number)</code> <a class="hash-link" href="#tobelessthanorequalnumber">#</a></h3>
<p>浮動小数点数を比較するには、 <code>toBeLessThanOrEqual</code>が使用できます。例えば、 <code>ouncesPerCan()</code>が１２オンス以下の値を返すことをテストしたい場合は、以下のように書いて下さい:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is at least 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeinstanceofclass"></a><code>.toBeInstanceOf(Class)</code> <a class="hash-link" href="#tobeinstanceofclass">#</a></h3>
<p>オブジェクトがクラスのインスタンスであることを確認するには <code>.toBeInstanceOf(Class)</code>を使用して下さい。このマッチャは <code>instanceof</code>を内部で利用しています。</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{}

expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(A);
expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}).toBeInstanceOf(<span class="hljs-built_in">Function</span>);
expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(<span class="hljs-built_in">Function</span>); <span class="hljs-comment">// throws</span>
</code></pre>
<h3><a class="anchor" name="tobenull"></a><code>.toBeNull()</code> <a class="hash-link" href="#tobenull">#</a></h3>
<p><code>.toBeNull()</code> は <code>.toBe(null)</code>と同じですが、エラーメッセージが少し分かりやすいものになっています。そのため何かがnullであることを確認したい場合は <code>.toBeNull()</code>を使用して下さい。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bloop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

test(<span class="hljs-string">'bloop returns null'</span>, () =&gt; {
  expect(bloop()).toBeNull();
});
</code></pre>
<h3><a class="anchor" name="tobetruthy"></a><code>.toBeTruthy()</code> <a class="hash-link" href="#tobetruthy">#</a></h3>
<p>値がどのようなものかを気にせず、真偽値のコンテクストの中で値が真であることを確認したい場合は<code>.toBeTruthy</code> を使用して下さい。例えば、以下のようなアプリケーションコードがあったとします:</p>
<pre><code class="language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (thirstInfo()) {
  drinkMoreLaCroix();
}
</code></pre>
<p><code>thirstInfo</code>がどんなものを返すかは特に気にしないでしょう - <code>true</code>もしくは複雑な値を返すかもしれませんが、それでもコードは動作します。 だからラクロワ飲料を飲んだ後に<code>thirstInfo</code>が真(またはそう類推される値) を返すことをテストするには、次のように書くことができます:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinking La Croix leads to having thirst info'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(thirstInfo()).toBeTruthy();
});
</code></pre>
<p>JavaScriptでは、偽と類推される６つの値があります: <code>false</code>、 ``、 <code>''</code>、 <code>null</code>、 <code>undefined</code>、 そして <code>NaN</code>です。他の全ては真と類推されます。</p>
<h3><a class="anchor" name="tobeundefined"></a><code>.toBeUndefined()</code> <a class="hash-link" href="#tobeundefined">#</a></h3>
<p>変数がundefinedであることを確認するには <code>.toBeUndefined</code>を使用します。 例えば、 関数<code>bestDrinkForFlavor(flavor)</code>が<code>'octopus'</code>味が与えられた時に<code>undefined</code>を返すことを確認したいとしましょう。タコ味の美味しい飲み物なんてありませんから:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best drink for octopus flavor is undefined'</span>, () =&gt; {
  expect(bestDrinkForFlavor(<span class="hljs-string">'octopus'</span>)).toBeUndefined();
});
</code></pre>
<p><code>expect(bestDrinkForFlavor('octopus')).toBe(undefined)</code>とも書くことができますが、<code>undefined</code>を直接コード内で参照するのは避けたほうが実務上良いでしょう。</p>
<h3><a class="anchor" name="tocontainitem"></a><code>.toContain(item)</code> <a class="hash-link" href="#tocontainitem">#</a></h3>
<p>アイテムが配列内にあることを確認したい場合は、<code>.toContain</code> を使用します。 配列内のアイテムをテストするために、 このマッチャは<code>===</code>を使用して厳密な等価性のチェックを行います。 <code>.toContain</code>は、ある文字列が別の文字列の部分文字列であるかをチェックすることもできます。</p>
<p>例えば <code>getAllFlavors()</code>が風味の配列を返し、<code>lime</code>がその中にある事を確認したいなら、このように書くことができます:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the flavor list contains lime'</span>, () =&gt; {
  expect(getAllFlavors()).toContain(<span class="hljs-string">'lime'</span>);
});
</code></pre>
<h3><a class="anchor" name="tocontainequalitem"></a><code>.toContainEqual(item)</code> <a class="hash-link" href="#tocontainequalitem">#</a></h3>
<p>特定の構造と値を持つ要素が配列に含まれていることをチェックしたい場合は<code>.toContainEqual</code>を使用して下さい。 配列中のアイテムをテストするために、このマッチャはオブジェクトIDではなく、再帰的に全てのフィールドの等価性を確認します。</p>
<pre><code class="language-js">describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious and not sour'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> myBeverage = {<span class="hljs-attr">delicious</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">sour</span>: <span class="hljs-literal">false</span>};
    expect(myBeverages()).toContainEqual(myBeverage);
  });
});
</code></pre>
<h3><a class="anchor" name="toequalvalue"></a><code>.toEqual(value)</code> <a class="hash-link" href="#toequalvalue">#</a></h3>
<p>2 つのオブジェクトが同じ値を持つことを確認したい場合は、<code>.toEqual</code> を使用します。 このマッチャはオブジェクトIdを確認せずに、全てのフィールドの等価性を確認します—これは&quot;deep equal&quot;として知られています。 例えば、 <code>toEqual</code> と <code>toBe</code>は以下のテストスイートで異なる振る舞いをするので、全てのテストがパスします:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> can1 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};
<span class="hljs-keyword">const</span> can2 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the La Croix cans on my desk'</span>, () =&gt; {
  test(<span class="hljs-string">'have all the same properties'</span>, () =&gt; {
    expect(can1).toEqual(can2);
  });
  test(<span class="hljs-string">'are not the exact same can'</span>, () =&gt; {
    expect(can1).not.toBe(can2);
  });
});
</code></pre>
<blockquote>
<p>注意: <code>.toEqual</code>は２つのエラーに <em>deep equality</em>を実施しません。 エラーオブジェクトの <code>message</code>プロパティのみを等価性の比較対象とします。 エラーに対するテストは <code>.toThrow</code>マッチャの使用をお勧めします。</p>
</blockquote>
<h3><a class="anchor" name="tohavelengthnumber"></a><code>.toHaveLength(number)</code> <a class="hash-link" href="#tohavelengthnumber">#</a></h3>
<p>オブジェクトが<code>.length</code>プロパティを持ち、特定の数値であるかを確認するには、<code>.toHaveLength</code> を使用して下さい。</p>
<p>配列や文字列のサイズを確認するのに特に便利です。</p>
<pre><code class="language-js">expect([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">'abc'</span>).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">''</span>).not.toHaveLength(<span class="hljs-number">5</span>);
</code></pre>
<h3><a class="anchor" name="tomatchregexporstring"></a><code>.toMatch(regexpOrString)</code> <a class="hash-link" href="#tomatchregexporstring">#</a></h3>
<p>文字列が正規表現と一致することを確認するには<code>.toMatch</code> を使用して下さい。</p>
<p>例えば、<code>essayOnTheBestFlavor()</code> がどのようなものか正確には分からないけれども本当に長い文字列を返すこと、そして <code>grapefruit</code>という文字列がその中のどこかに含まれるべきであるということを知っているとしましょう。 以下のコードでテストできます:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'an essay on the best flavor'</span>, () =&gt; {
  test(<span class="hljs-string">'mentions grapefruit'</span>, () =&gt; {
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-regexp">/grapefruit/</span>);
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'grapefruit'</span>));
  });
});
</code></pre>
<p>このマッチャは正規表現と照合する対象に文字列も取ることができます:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'grapefruits are healthy'</span>, () =&gt; {
  test(<span class="hljs-string">'grapefruits are a fruit'</span>, () =&gt; {
    expect(<span class="hljs-string">'grapefruits'</span>).toMatch(<span class="hljs-string">'fruit'</span>);
  });
});
</code></pre>
<h3><a class="anchor" name="tomatchobjectobject"></a><code>.toMatchObject(object)</code> <a class="hash-link" href="#tomatchobjectobject">#</a></h3>
<p>JavaScript オブジェクトが、あるオブジェクトのプロパティのサブセットに一致することを確認するには<code>.ToMatchObject</code> を使用して下さい。 期待されるオブジェクトに含まれ<strong>ない</strong>プロパティを含む引数のオブジェクトについても一致します。</p>
<p>オブジェクトの配列を渡すこともでき、その場合はメソッドは期待する配列の対応するオブジェクトと引数の配列の各オブジェクトが( 上述の<code>toMatchObject</code>と同じ意味で) 一致する場合のみ真を返します。 このAPIは引数の配列が余分な要素を持つことを受容する <code>arrayContaining</code>とは反対に、2つの配列がその数で一致することを確認するのに便利です。</p>
<p>プロパティは値またはマッチャでマッチすることができます。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};
<span class="hljs-keyword">const</span> desiredHouse = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">wallColor</span>: expect.stringMatching(<span class="hljs-regexp">/white|yellow/</span>),
  },
};

test(<span class="hljs-string">'the house has my desired features'</span>, () =&gt; {
  expect(houseForSale).toMatchObject(desiredHouse);
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'toMatchObject applied to arrays arrays'</span>, () =&gt; {
  test(<span class="hljs-string">'the number of elements must match exactly'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });

  <span class="hljs-comment">// .arrayContaining "matches a received array which contains elements that are *not* in the expected array"</span>
  test(<span class="hljs-string">'.toMatchObject does not allow extra elements'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> }
    ]);
  });

  test(<span class="hljs-string">'.toMatchObject is called for each elements, so extra object properties are okay'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">extra</span>: <span class="hljs-string">'quux'</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });
});
</code></pre>
<h3><a class="anchor" name="tohavepropertykeypath-value"></a><code>.toHaveProperty(keyPath, value)</code> <a class="hash-link" href="#tohavepropertykeypath-value">#</a></h3>
<p>オブジェクトの指定された参照<code>keyPath</code>のプロパティが存在するかを確認するには、<code>.toHaveProperty</code> を使用して下さい。 オブジェクト内で深くネストされたプロパティを確認するには、 深い階層の参照のための<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors">dot notation</a>を使用して下さい。</p>
<p>必要に応じて、 <code>value</code>を指定して、対象とするオブジェクトの<code>keyPath</code>の現在の値と等しいかを確認することができます。 このマッチャは(<code>toEqual()</code>のように) 'deep equality' を利用して再帰的に全てのフィールドの等価性を確認します。</p>
<p>次に示す例ではネストされたプロパティを含む <code>houseForSale</code> オブジェクトを含んでいます。 <code>toHaveProperty</code>を利用してオブジェクト内の様々なプロパティの存在と値の確認を行っています。</p>
<pre><code class="language-js"><span class="hljs-comment">// Object containing house features to be tested</span>
<span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};

test(<span class="hljs-string">'this house has my desired features'</span>, () =&gt; {
  <span class="hljs-comment">// Simple Referencing</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bath'</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bedrooms'</span>, <span class="hljs-number">4</span>);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'pool'</span>);

  <span class="hljs-comment">// Deep referencing using dot notation</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.area'</span>, <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.amenities'</span>, [
    <span class="hljs-string">'oven'</span>,
    <span class="hljs-string">'stove'</span>,
    <span class="hljs-string">'washer'</span>,
  ]);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'kitchen.open'</span>);
});
</code></pre>
<h3><a class="anchor" name="tomatchsnapshotoptionalstring"></a><code>.toMatchSnapshot(optionalString)</code> <a class="hash-link" href="#tomatchsnapshotoptionalstring">#</a></h3>
<p>この API は最も最近のスナップショットと一致することを確認します。詳細については <a href="/jest/docs/ja/snapshot-testing.html">the Snapshot Testing guide</a> を確認して下さい。</p>
<p>また、オプションでのスナップショットの名前を指定できます。指定がなければ、名前はテストから推測されます。</p>
<p><em>注意: スナップショットテストはReactコンポーネントにおいて最も広く使われていますが、任意のシリアライズ可能な値をスナップショットとして使用することができます。</em></p>
<h3><a class="anchor" name="tothrowerror"></a><code>.toThrow(error)</code> <a class="hash-link" href="#tothrowerror">#</a></h3>
<p>次の別名でも同様となります: <code>.toThrowError(error)</code></p>
<p>関数が呼ばれた際にエラーを投げることを確認するには<code>.toThrow</code> を使用して下さい。 例えば、タコ味なんて気持ち悪すぎて飲めないので<code>drinkFlavor('octopus')</code> が例外を投げることをテストしたい場合、次のように書くことができます:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }).toThrow();
});
</code></pre>
<p>特定のエラーがスローされることをテストしたい場合は、<code>toThrow</code>に引数を与えることができます。 引数はエラーメッセージの文字列か、エラーのクラスか、エラーがマッチするべき正規表現です。 例えば、<code>drinkFlavor</code>はこのようにコーディングされたとしましょう:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Do some other stuff</span>
}
</code></pre>
<p>いくつかの方法でこのエラーが投げられることをテストできます:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  <span class="hljs-comment">// Test the exact error message</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-string">'yuck, octopus flavor'</span>);

  <span class="hljs-comment">// Test that the error message says "yuck" somewhere</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-regexp">/yuck/</span>);

  <span class="hljs-comment">// Test that we get a DisgustingFlavorError</span>
  expect(drinkOctopus).toThrowError(DisgustingFlavorError);
});
</code></pre>
<blockquote>
<p>注意： 関数の中のコードはラップしてください。そうしなければエラーが補足されず、アサーションは失敗します。</p>
</blockquote>
<h3><a class="anchor" name="tothrowerrormatchingsnapshot"></a><code>.toThrowErrorMatchingSnapshot()</code> <a class="hash-link" href="#tothrowerrormatchingsnapshot">#</a></h3>
<p>関数が呼ばれた際に直近のスナップショットと一致するエラーを投げることを確認するには、 <code>.toThrowErrorMatchingSnapshot</code>を使用して下さい。 例えば、 風味が<code>'octopus'</code>ならば必ずエラーを投げる<code>drinkFlavor</code>関数があり、次のようなコードだったとします:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Do some other stuff</span>
}
</code></pre>
<p>この関数のテストはこのようになります:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  expect(drinkOctopus).toThrowErrorMatchingSnapshot();
});
</code></pre>
<p>そして次のようなスナップショットを生成します:</p>
<pre><code>exports[`drinking flavors throws on octopus 1`] = `&quot;yuck, octopus flavor&quot;`;
</code></pre>
<p>スナップショットテストについての詳細は<a href="http://facebook.github.io/jest/blog/2016/07/27/jest-14.html">React Tree Snapshot Testing</a>を確認して下さい。</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="api.html">← Globals</a><a class="docs-next button" href="mock-function-api.html">Mock Functions →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/ja/getting-started.html">Getting Started</a><a href="/jest/docs/ja/snapshot-testing.html">Guides</a><a href="/jest/docs/ja/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/ja/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-count-api="/repos/facebook/jest#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>