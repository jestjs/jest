<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Mock Functions · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="ただ出力をテストするだけでなく、他のコードから間接的に呼び出された関数の振る舞いを見張ることができるので、モック関数は &quot;スパイ&quot;とも呼ばれます。 `jest.fn()`関数でモック関数を作成できます。 実装が与えられなければ、モック関数は実行時に`undefined`を返します。"/><meta name="docsearch:version" content="23.5"/><meta name="docsearch:language" content="ja"/><meta property="og:title" content="Mock Functions · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jestjs.io/index.html"/><meta property="og:description" content="ただ出力をテストするだけでなく、他のコードから間接的に呼び出された関数の振る舞いを見張ることができるので、モック関数は &quot;スパイ&quot;とも呼ばれます。 `jest.fn()`関数でモック関数を作成できます。 実装が与えられなければ、モック関数は実行時に`undefined`を返します。"/><meta property="og:image" content="https://jestjs.io/img/opengraph.png"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://jestjs.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://jestjs.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ja"><img class="logo" src="/img/jest.svg" alt="Jest"/><h2 class="headerTitleWithLogo">Jest</h2></a><a href="/ja/versions"><h3>23.5</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ja/23.5/getting-started" target="_self">ドキュメント</a></li><li class="siteNavGroupActive"><a href="/docs/ja/23.5/api" target="_self">API</a></li><li class=""><a href="/ja/help" target="_self">ヘルプ</a></li><li class=""><a href="/blog/" target="_self">ブログ</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>日本語</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/23.5/mock-function-api">English</a></li><li><a href="/docs/es-ES/23.5/mock-function-api">Español</a></li><li><a href="/docs/pt-BR/23.5/mock-function-api">Português (Brasil)</a></li><li><a href="/docs/ro/23.5/mock-function-api">Română</a></li><li><a href="/docs/ru/23.5/mock-function-api">Русский</a></li><li><a href="/docs/uk/23.5/mock-function-api">Українська</a></li><li><a href="/docs/zh-Hans/23.5/mock-function-api">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docMainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/jest/edit/master/docs/MockFunctionAPI.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">Mock Functions</h1></header><article><div><span><p>ただ出力をテストするだけでなく、他のコードから間接的に呼び出された関数の振る舞いを見張ることができるので、モック関数は &quot;スパイ&quot;とも呼ばれます。 <code>jest.fn()</code>関数でモック関数を作成できます。 実装が与えられなければ、モック関数は実行時に<code>undefined</code>を返します。</p>
<h2><a class="anchor" aria-hidden="true" id="メソッド"></a><a href="#メソッド" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>メソッド</h2>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" aria-hidden="true" id="リファレンス"></a><a href="#リファレンス" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>リファレンス</h2>
<h3><a class="anchor" aria-hidden="true" id="mockfngetmockname"></a><a href="#mockfngetmockname" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.getMockName()</code></h3>
<p><code>mockFn.mockName(value)</code>を呼び出すと、モック名の文字列を返します。</p>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockcalls"></a><a href="#mockfnmockcalls" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mock.calls</code></h3>
<p>An array containing the call arguments of all calls that have been made to this mock function. Each item in the array is an array of arguments that were passed during the call.</p>
<p>For example: A mock function <code>f</code> that has been called twice, with the arguments <code>f('arg1', 'arg2')</code>, and then with the arguments <code>f('arg3', 'arg4')</code>, would have a <code>mock.calls</code> array that looks like this:</p>
<pre><code class="hljs css language-js">[[<span class="hljs-string">'arg1'</span>, <span class="hljs-string">'arg2'</span>], [<span class="hljs-string">'arg3'</span>, <span class="hljs-string">'arg4'</span>]];
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockresults"></a><a href="#mockfnmockresults" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mock.results</code></h3>
<p>An array containing the results of all calls that have been made to this mock function. Each entry in this array is an object containing a boolean <code>isThrow</code> property, and a <code>value</code> property. <code>isThrow</code> is true if the call terminated due to a <code>throw</code>, or false if the the call returned normally. The <code>value</code> property contains the value that was thrown or returned.</p>
<p>For example: A mock function <code>f</code> that has been called three times, returning <code>result1</code>, throwing an error, and then returning <code>result2</code>, would have a <code>mock.results</code> array that looks like this:</p>
<pre><code class="hljs css language-js">[
  {
    <span class="hljs-attr">isThrow</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'result1'</span>,
  },
  {
    <span class="hljs-attr">isThrow</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">value</span>: {
      <span class="hljs-comment">/* Error instance */</span>
    },
  },
  {
    <span class="hljs-attr">isThrow</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">'result2'</span>,
  },
];
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockinstances"></a><a href="#mockfnmockinstances" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mock.instances</code></h3>
<p><code>new</code> によりモック関数からインスタンス化されたオブジェクトのインスタンス全ての配列。</p>
<p>例: 2回インスタンス化されたモック関数は次のような<code>mock.instances</code>配列を持ちます:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> mockFn = jest.fn();

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> mockFn();
<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> mockFn();

mockFn.mock.instances[<span class="hljs-number">0</span>] === a; <span class="hljs-comment">// true</span>
mockFn.mock.instances[<span class="hljs-number">1</span>] === b; <span class="hljs-comment">// true</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockclear"></a><a href="#mockfnmockclear" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockClear()</code></h3>
<p><a href="#mockfn-mock-calls"><code>mockFn.mock.calls</code></a> と <a href="#mockfn-mock-instances"><code>mockFn.mock.instances</code></a>の配列に格納されている全ての情報をリセットします。</p>
<p>2つのアサーションの間でモックの使用状況をクリーンアップしたいときにしばしば役立ちます。</p>
<p><code>mockClear</code> は <a href="#mockfn-mock-calls"><code>mockFn.mock.calls</code></a> と<a href="#mockfn-mock-instances"><code>mockFn.mock.instances</code></a>だけでなく<code>mockFn.mock</code> も置き換えることに注意して下さい。 そのため古く無効なデータにアクセスしないように、 <code>mockFn.mock</code>を他の変数に割り当てるのは一時的であっても、そうでなくても避けるべきです。</p>
<p>テスト間で自動的にモックをクリアするために <a href="configuration.html#clearmocks-boolean"><code>clearMocks</code></a>の設定オプションが利用できます。</p>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockreset"></a><a href="#mockfnmockreset" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockReset()</code></h3>
<p>Does everything that <a href="#mockfnmockclear"><code>mockFn.mockClear()</code></a> does, and also removes any mocked return values or implementations.</p>
<p>This is useful when you want to completely reset a <em>mock</em> back to its initial state. (Note that resetting a <em>spy</em> will result in a function with no return value).</p>
<p><code>mockReset</code> は <a href="#mockfn-mock-calls"><code>mockFn.mock.calls</code></a> と<a href="#mockfn-mock-instances"><code>mockFn.mock.instances</code></a>だけでなく<code>mockFn.mock</code> も置き換えることに注意して下さい。 そのため古く無効なデータにアクセスしないように、 <code>mockFn.mock</code>を他の変数に割り当てるのは一時的であっても、そうでなくても避けるべきです。</p>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockrestore"></a><a href="#mockfnmockrestore" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockRestore()</code></h3>
<p>Does everything that <a href="#mockfnmockreset"><code>mockFn.mockReset()</code></a> does, and also restores the original (non-mocked) implementation.</p>
<p>あるテストケースでモック関数を利用して他のテストケースでは本物のモジュールに戻したいときに便利です。</p>
<p><code>mockFn.mockRestore</code>は<code>jest.spyOn</code>によって作成されたモックに対してのみ動作することに注意して下さい。 このため手動で <code>jest.fn()</code>を割り当てた場合は自分で復元作業を行わなければならないことに気をつけて下さい。</p>
<p>The <a href="configuration.html#restoremocks-boolean"><code>restoreMocks</code></a> configuration option is available to restore mocks automatically between tests.</p>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockimplementationfn"></a><a href="#mockfnmockimplementationfn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockImplementation(fn)</code></h3>
<p>モックの実装として使用される関数を受け取ります。 モック自体はそれ自身から出てきたインスタンスと中に与えられた全てのコールをいまだ記録しています - 違いはモックがコールされたときに実装された関数も実行されることです。</p>
<p><em>注意: <code>jest.fn(implementation)</code> は <code>jest.fn().mockImplementation(implementation)</code> の省略形です。</em></p>
<p>例：</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> mockFn = jest.fn().mockImplementation(<span class="hljs-function"><span class="hljs-params">scalar</span> =&gt;</span> <span class="hljs-number">42</span> + scalar);
<span class="hljs-comment">// or: jest.fn(scalar =&gt; 42 + scalar);</span>

<span class="hljs-keyword">const</span> a = mockFn(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> b = mockFn(<span class="hljs-number">1</span>);

a === <span class="hljs-number">42</span>; <span class="hljs-comment">// true</span>
b === <span class="hljs-number">43</span>; <span class="hljs-comment">// true</span>

mockFn.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] === <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span>
mockFn.mock.calls[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] === <span class="hljs-number">1</span>; <span class="hljs-comment">// true</span>
</code></pre>
<p><code>mockImplementation</code> はクラスのコンストラクタをモックするのにも使用できます。</p>
<pre><code class="hljs css language-js"><span class="hljs-comment">// SomeClass.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> </span>{
  m(a, b) {}
};

<span class="hljs-comment">// OtherModule.test.js</span>
jest.mock(<span class="hljs-string">'./SomeClass'</span>); <span class="hljs-comment">// this happens automatically with automocking</span>
<span class="hljs-keyword">const</span> SomeClass = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./SomeClass'</span>);
<span class="hljs-keyword">const</span> mMock = jest.fn();
SomeClass.mockImplementation(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">m</span>: mMock,
  };
});

<span class="hljs-keyword">const</span> some = <span class="hljs-keyword">new</span> SomeClass();
some.m(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Calls to m: '</span>, mMock.mock.calls);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockimplementationoncefn"></a><a href="#mockfnmockimplementationoncefn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockImplementationOnce(fn)</code></h3>
<p>モック関数への1回のコールに対する実装として使用される関数を受け取ります。関数への複数回のコールが異なる結果を返せるよう、チェーンすることができます。</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> myMockFn = jest
  .fn()
  .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))
  .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>));

myMockFn(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(val)); <span class="hljs-comment">// true</span>

myMockFn(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(val)); <span class="hljs-comment">// false</span>
</code></pre>
<p>モック関数がmockImplementationOnceによって定義された実装が全て使い切った時は、 呼び出された場合に<code>jest.fn(() =&gt; defaultValue)</code> または <code>.mockImplementation(() =&gt; defaultValue)</code>によって設定されたデフォルトの実装を実行します。</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> myMockFn = jest
  .fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'default'</span>)
  .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'first call'</span>)
  .mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'second call'</span>);

<span class="hljs-comment">// 'first call', 'second call', 'default', 'default'</span>
<span class="hljs-built_in">console</span>.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmocknamevalue"></a><a href="#mockfnmocknamevalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockName(value)</code></h3>
<p>どのモック関数が参照されているのかを示すために、&quot;jest.fn()&quot;の代わりにテスト結果で出力される文字列を引数に取ります。</p>
<p>例：</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> mockFn = jest.fn().mockName(<span class="hljs-string">'mockedFunction'</span>);
<span class="hljs-comment">// mockFn();</span>
expect(mockFn).toHaveBeenCalled();
</code></pre>
<p>は以下のエラーを出力します:</p>
<pre><code class="hljs css language-bash">    expect(mockedFunction).toHaveBeenCalled()

    Expected mock <span class="hljs-keyword">function</span> to have been called.
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockreturnthis"></a><a href="#mockfnmockreturnthis" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockReturnThis()</code></h3>
<p>下記の関数の糖衣構文です:</p>
<pre><code class="hljs css language-js">jest.fn(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockreturnvaluevalue"></a><a href="#mockfnmockreturnvaluevalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockReturnValue(value)</code></h3>
<p>モック関数が呼ばれるたびに返す値を受け取ります。</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> mock = jest.fn();
mock.mockReturnValue(<span class="hljs-number">42</span>);
mock(); <span class="hljs-comment">// 42</span>
mock.mockReturnValue(<span class="hljs-number">43</span>);
mock(); <span class="hljs-comment">// 43</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockreturnvalueoncevalue"></a><a href="#mockfnmockreturnvalueoncevalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockReturnValueOnce(value)</code></h3>
<p>モック関数を1回呼び出したときに返す値を受け取ります。 次のモック関数へのコールが異なる値を返せるようチェーンすることができます。 使用できる <code>mockReturnValueOnce</code>の値が無い場合は、 <code>mockReturnValue</code>で設定された値を返します。</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> myMockFn = jest
  .fn()
  .mockReturnValue(<span class="hljs-string">'default'</span>)
  .mockReturnValueOnce(<span class="hljs-string">'first call'</span>)
  .mockReturnValueOnce(<span class="hljs-string">'second call'</span>);

<span class="hljs-comment">// 'first call', 'second call', 'default', 'default'</span>
<span class="hljs-built_in">console</span>.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockresolvedvaluevalue"></a><a href="#mockfnmockresolvedvaluevalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockResolvedValue(value)</code></h3>
<p>下記の関数の糖衣関数です。</p>
<pre><code class="hljs css language-js">jest.fn().mockImplementation(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve(value));
</code></pre>
<p>次のように async テスト内で sync 関数をモックするのに便利です。</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'async test'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> asyncMock = jest.fn().mockResolvedValue(<span class="hljs-number">43</span>);

  <span class="hljs-keyword">await</span> asyncMock(); <span class="hljs-comment">// 43</span>
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockresolvedvalueoncevalue"></a><a href="#mockfnmockresolvedvalueoncevalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockResolvedValueOnce(value)</code></h3>
<p>下記の関数の糖衣関数です。</p>
<pre><code class="hljs css language-js">jest.fn().mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve(value));
</code></pre>
<p>複数の async 呼び出しを異なる値で解決させるのに便利です。</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'async test'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> asyncMock = jest
    .fn()
    .mockResolvedValue(<span class="hljs-string">'default'</span>)
    .mockResolvedValueOnce(<span class="hljs-string">'first call'</span>)
    .mockResolvedValueOnce(<span class="hljs-string">'second call'</span>);

  <span class="hljs-keyword">await</span> asyncMock(); <span class="hljs-comment">// first call</span>
  <span class="hljs-keyword">await</span> asyncMock(); <span class="hljs-comment">// second call</span>
  <span class="hljs-keyword">await</span> asyncMock(); <span class="hljs-comment">// default</span>
  <span class="hljs-keyword">await</span> asyncMock(); <span class="hljs-comment">// default</span>
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockrejectedvaluevalue"></a><a href="#mockfnmockrejectedvaluevalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockRejectedValue(value)</code></h3>
<p>下記の関数の糖衣関数です。</p>
<pre><code class="hljs css language-js">jest.fn().mockImplementation(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.reject(value));
</code></pre>
<p>常に reject する async モック関数を作るのに便利です。</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'async test'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> asyncMock = jest.fn().mockRejectedValue(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Async error'</span>));

  <span class="hljs-keyword">await</span> asyncMock(); <span class="hljs-comment">// throws "Async error"</span>
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mockfnmockrejectedvalueoncevalue"></a><a href="#mockfnmockrejectedvalueoncevalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>mockFn.mockRejectedValueOnce(value)</code></h3>
<p>下記の関数の糖衣関数です。</p>
<pre><code class="hljs css language-js">jest.fn().mockImplementationOnce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.reject(value));
</code></pre>
<p>使用例</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'async test'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> asyncMock = jest
    .fn()
    .mockResolvedValueOnce(<span class="hljs-string">'first call'</span>)
    .mockRejectedValueOnce(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Async error'</span>));

  <span class="hljs-keyword">await</span> asyncMock(); <span class="hljs-comment">// first call</span>
  <span class="hljs-keyword">await</span> asyncMock(); <span class="hljs-comment">// throws "Async error"</span>
});
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ja/23.5/expect"><span class="arrow-prev">← </span><span>前</span></a><a class="docs-next button" href="/docs/ja/23.5/jest-object"><span>次</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav docOnPageNav"><ul class="toc-headings"><li><a href="#メソッド">メソッド</a></li><li><a href="#リファレンス">リファレンス</a><ul class="toc-headings"><li><a href="#mockfngetmockname"><code>mockFn.getMockName()</code></a></li><li><a href="#mockfnmockcalls"><code>mockFn.mock.calls</code></a></li><li><a href="#mockfnmockresults"><code>mockFn.mock.results</code></a></li><li><a href="#mockfnmockinstances"><code>mockFn.mock.instances</code></a></li><li><a href="#mockfnmockclear"><code>mockFn.mockClear()</code></a></li><li><a href="#mockfnmockreset"><code>mockFn.mockReset()</code></a></li><li><a href="#mockfnmockrestore"><code>mockFn.mockRestore()</code></a></li><li><a href="#mockfnmockimplementationfn"><code>mockFn.mockImplementation(fn)</code></a></li><li><a href="#mockfnmockimplementationoncefn"><code>mockFn.mockImplementationOnce(fn)</code></a></li><li><a href="#mockfnmocknamevalue"><code>mockFn.mockName(value)</code></a></li><li><a href="#mockfnmockreturnthis"><code>mockFn.mockReturnThis()</code></a></li><li><a href="#mockfnmockreturnvaluevalue"><code>mockFn.mockReturnValue(value)</code></a></li><li><a href="#mockfnmockreturnvalueoncevalue"><code>mockFn.mockReturnValueOnce(value)</code></a></li><li><a href="#mockfnmockresolvedvaluevalue"><code>mockFn.mockResolvedValue(value)</code></a></li><li><a href="#mockfnmockresolvedvalueoncevalue"><code>mockFn.mockResolvedValueOnce(value)</code></a></li><li><a href="#mockfnmockrejectedvaluevalue"><code>mockFn.mockRejectedValue(value)</code></a></li><li><a href="#mockfnmockrejectedvalueoncevalue"><code>mockFn.mockRejectedValueOnce(value)</code></a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/ja/getting-started.html">Getting Started</a><a href="/docs/ja/snapshot-testing.html">Guides</a><a href="/docs/ja/api.html">API Reference</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discord.gg/MWRhKCj">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star facebook/jest on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2018 Facebook Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:ja","version:23.5"]}
              });
            </script></body></html>