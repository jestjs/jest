<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Expect · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Expect · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="Під час написання тестів, часто потрібно перевіряти, що значення задовольняють певним умовам. `expect` надає вам доступ до ряду так званих матчерів, які дозволяють вам виконувати різні перевірки."/><meta property="og:image" content="/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="/jest/css/main.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/uk/getting-started.html" target="_self">Документація</a></li><li><a href="/jest/docs/uk/api.html" target="_self">API</a></li><li><a href="/jest/uk/help.html" target="_self">Допомога</a></li><li><a href="/jest/blog" target="_self">Блог</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Українська</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/es-ES">Español</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ro">Română</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/uk/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/uk/api.html">Globals</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/uk/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/cli.html">Jest CLI Options</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/uk/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/uk/snapshot-testing.html">Тестування з допомогою знімків</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/uk/troubleshooting.html">Troubleshooting</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Expect</h1></header><article><div><span><p>Під час написання тестів, часто потрібно перевіряти, що значення задовольняють певним умовам. <code>expect</code> надає вам доступ до ряду так званих матчерів, які дозволяють вам виконувати різні перевірки.</p>
<h2><a class="anchor" name=""></a>Методи <a class="hash-link" href="#">#</a></h2>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" name=""></a>Довідка <a class="hash-link" href="#">#</a></h2>
<h3><a class="anchor" name="expectvalue"></a><code>expect(value)</code> <a class="hash-link" href="#expectvalue">#</a></h3>
<p>Функція <code>expect</code> використовується кожного разу, коли ви хочете перевірити якесь значення. Дуже рідко потрібно викликати <code>expect</code> саму по собі. Замість цього, ви будете використовувати <code>expect</code> разом з &quot;матчер&quot; функціями, щоб перевірити твердження щодо якогось значення.</p>
<p>Найпростіше зрозуміти це на прикладі. Уявімо, що у вас є метод <code>bestLaCroixFlavor()</code>, який повинен повертати рядок <code>'grapefruit'</code>. Ось, як ви можете це протестувати:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best flavor is grapefruit'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).toBe(<span class="hljs-string">'grapefruit'</span>);
});
</code></pre>
<p>В цьому випадку <code>toBe</code> - це функція-матчер. Існує багато різних функцій-матчерів, описаних нижче, які допомогають тестувати різні речі.</p>
<p>Аргументом для <code>expect</code> повинне бути значення, яке генерує ваш код, а аргументом для матчера повинне бути правильне значення. Якщо ви їх переплутаєте місцями, то ваші тести працюватимуть, але повідомлння про помилки в тестах будуть виглядати дуже дивно.</p>
<h3><a class="anchor" name="expectextendmatchers"></a><code>expect.extend(matchers)</code> <a class="hash-link" href="#expectextendmatchers">#</a></h3>
<p>Ви можете використовувати <code>expect.extend</code> щоб додати ваші власні матчери для Jest. Наприклад, скажімо ви тестуєте бібліотеку для роботи з теорією чисел і ви часто перевіряєте, що числа діляться на інші числа без залишку. Ви могли би написати для цього матчер <code>toBeDivisibleBy</code>:</p>
<pre><code class="language-js">expect.extend({
  toBeDivisibleBy(received, argument) {
    <span class="hljs-keyword">const</span> pass = (received % argument == <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> not to be divisible by <span class="hljs-subst">${argument}</span>`</span>
        ),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (<span class="hljs-string">`expected <span class="hljs-subst">${received}</span> to be divisible by <span class="hljs-subst">${argument}</span>`</span>),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'even and odd numbers'</span>, () =&gt; {
  expect(<span class="hljs-number">100</span>).toBeDivisibleBy(<span class="hljs-number">2</span>);
  expect(<span class="hljs-number">101</span>).not.toBeDivisibleBy(<span class="hljs-number">2</span>);
});
</code></pre>
<p>Матчер повинен повертати об’єкт з двома ключами. <code>pass</code> вказує на те, чи було співпадіння, а <code>message</code> надає функцію без аргументів, яка повертає повідомлення про помилку, на випадок невдачі. Таким чином, коли <code>pass</code> має значення false, <code>message</code> повинна повернути повідомлення про помилку, якщо твердження <code>expect(x).yourMatcher()</code> не виконується. А коли <code>pass</code> має значення true, <code>message</code> повинна повернути повідомленя про помилку, якщо не виконується твердження <code>expect(x).not.yourMatcher()</code>.</p>
<p>Наступні допоміжні властивості доступні в <code>this</code> всередині власних матчерів:</p>
<h4><a class="anchor" name="thisisnot"></a><code>this.isNot</code> <a class="hash-link" href="#thisisnot">#</a></h4>
<p>Булеве значення, яке дає вам можливість дізнатися, чи цей матчер був викликаний з модифікатором заперечення <code>.not</code>, щоб ви могли інвертувати свою перевірку.</p>
<h4><a class="anchor" name="thisequalsa-b"></a><code>this.equals(a, b)</code> <a class="hash-link" href="#thisequalsa-b">#</a></h4>
<p>Це функція глибокого порівняння, яка повертає <code>true</code>, якщо два об’єкти мають те саме значення (рекурсивно).</p>
<h4><a class="anchor" name="thisutils"></a><code>this.utils</code> <a class="hash-link" href="#thisutils">#</a></h4>
<p>Існує багато корисних інструментів, доступних через <code>this.utils</code>, які, в основному, складаються з функцій, які експортуються в пакеті <a href="https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils"><code>jest-matcher-utils</code></a>.</p>
<p>Найбільш корисні з них - це <code>matcherHint</code>, <code>printExpected</code> і <code>printReceived</code> для форматування повідомлень про помилки. Наприклад, ось як це реалізовано для матчера <code>toBe</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> diff = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-diff'</span>);
expect.extend({
  toBe(received, expected) {
    <span class="hljs-keyword">const</span> pass = received === expected;

    <span class="hljs-keyword">const</span> message = pass
      ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.not.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to not be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>
      : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> diffString = diff(expected, received, {
          <span class="hljs-attr">expand</span>: <span class="hljs-keyword">this</span>.expand,
        });
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span> +
        (diffString ? <span class="hljs-string">`\n\nDifference:\n\n<span class="hljs-subst">${diffString}</span>`</span> : <span class="hljs-string">''</span>);
      };

    <span class="hljs-keyword">return</span> {<span class="hljs-attr">actual</span>: received, message, pass};
  },
});
</code></pre>
<p>Виведеться щось таке:</p>
<pre><code>  expect(received).toBe(expected)

    Expected value to be (using ===):
      &quot;banana&quot;
    Received:
      &quot;apple&quot;
</code></pre>
<p>Коли твердження не виконується, повідомлення про помилку повинне давати користувачеві якомога більше інформації, щоб він міг швидко вирішити проблему. Варто робити точні і зрозумілі поідомлення про помилки, щоб переконатися, що б ваші власні матчери були зручні у використанні.</p>
<h3><a class="anchor" name="expectanything"></a><code>expect.anything()</code> <a class="hash-link" href="#expectanything">#</a></h3>
<p><code>expect.anything()</code> відповідає будь-якому значенню, окрім <code>null</code> та <code>undefined</code>. Ви можете використовувати його всередині <code>toEqual</code> чи <code>toBeCalledWith</code> замість явного вказання значень. Наприклад, якщо ви хочете перевірити, що мок функція була викликана з аргументом, не рівним null:</p>
<pre><code class="language-js">test(<span class="hljs-string">'map calls its argument with a non-null argument'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  [<span class="hljs-number">1</span>].map(mock);
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h3><a class="anchor" name="expectanyconstructor"></a><code>expect.any(constructor)</code> <a class="hash-link" href="#expectanyconstructor">#</a></h3>
<p><code>expect.any(constructor)</code> перевіряє, що значення було створене з допомогою заданого конструктора. Ви можете використовувати його всередині <code>toEqual</code> чи <code>toBeCalledWith</code> замість явного вказання значень. Наприклад, якщо ви хочете перевірити, що мок функція була викликана з аргументом типу Number:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randocall</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> fn(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>));
}

test(<span class="hljs-string">'randocall calls its callback with a number'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(<span class="hljs-built_in">Number</span>));
});
</code></pre>
<h3><a class="anchor" name="expectarraycontainingarray"></a><code>expect.arrayContaining(array)</code> <a class="hash-link" href="#expectarraycontainingarray">#</a></h3>
<p><code>expect.arrayContaining(array)</code> перевіряє, чи отриманий масив містить всі елементи очікуваного. Іншими словами, що очікуваний масив є <strong>підмножиною</strong> отриманого. Отже, отриманий масив може містити елементи, яких <strong>немає</strong> в очікуваному.</p>
<p>Ви можете використовувати його замість явного вказання значень:</p>
<ul>
<li>в <code>toEqual</code> або <code>toBeCalledWith</code></li>
<li>щоб вказати відповідність властивості в <code>objectContaining</code> або <code>toMatchObject</code></li>
</ul>
<pre><code class="language-js">describe(<span class="hljs-string">'arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'Beware of a misunderstanding! A sequence of dice rolls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  it(<span class="hljs-string">'matches even with an unexpected number 7'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match without an expected number 2'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" name="expectassertionsnumber"></a><code>expect.assertions(number)</code> <a class="hash-link" href="#expectassertionsnumber">#</a></h3>
<p><code>expect.assertions(number)</code> перевіряє, що певна кількість тверджень було викликано в межах тесту. Це часто буває корисним при тестуванні асинхронного коду, щоб переконатися, що твердження в зворотніх викликах було викликано.</p>
<p>Наприклад, нехай у нас є функція <code>doAsync</code>, яка приймає два зворотні виклики <code>callback1</code> і <code>callback2</code> і асинхронно викликає їх в невідомому порядку. Ми можемо протестувати це так:</p>
<pre><code class="language-js">test(<span class="hljs-string">'doAsync calls both callbacks'</span>, () =&gt; {
  expect.assertions(<span class="hljs-number">2</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p>Виклик <code>expect.assertions(2)</code> перевіряє, що обидва зворотні виклики дійсно були викликані.</p>
<h3><a class="anchor" name="expecthasassertions"></a><code>expect.hasAssertions()</code> <a class="hash-link" href="#expecthasassertions">#</a></h3>
<p><code>expect.hasAssertions()</code> перевіряє, що хоча б одне твердження було викликане в межах тесту. Це часто буває корисним при тестуванні асинхронного коду, щоб переконатися, що твердження в зворотніх викликах було викликано.</p>
<p>Наприклад, нехай у нас є кілька функцій, які працюють з якимось спільним станом. <code>prepareState</code> викликає функцію зворотнього виклику з об’єктом стану, <code>validateState</code> виконує над цим об’єктом якусь операцію, а <code>waitOnState</code> повертає проміс, який очікує поки виконається зворотній виклик <code>prepareState</code>. Ми можемо протестувати це так:</p>
<pre><code class="language-js">test(<span class="hljs-string">'prepareState prepares a valid state'</span>, () =&gt; {
  expect.hasAssertions();
  prepareState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    expect(validateState(state)).toBeTruthy();
  });
  <span class="hljs-keyword">return</span> waitOnState();
});
</code></pre>
<p>Виклик <code>expect.hasAssertions()</code> перевіряє, що зворотній виклик <code>prepareState</code> дійсно було викликано.</p>
<h3><a class="anchor" name="expectobjectcontainingobject"></a><code>expect.objectContaining(object)</code> <a class="hash-link" href="#expectobjectcontainingobject">#</a></h3>
<p><code>expect.objectContaining(object)</code> відповідає будь-якому об’єкту, який рекурсивно відповідає очікуваному. Іншими словами, що очікуваний об’єкт є <strong>підмножиною</strong> отриманого. Отже, він відповідає отриманому об’єкту, що містить властивості, яких <strong>немає</strong> в очікуваному.</p>
<p>Замість значень властивостей в очікуваному об’єкті ви можете використовувати матчери типу <code>expect.anything()</code> та інші.</p>
<p>Наприклад, нехай ми очікуємо, що функція <code>onPress</code> буде викликана з об’єктом <code>Event</code> і нам потрібно перевірити, що цей об’єкт має властивості <code>event.x</code> і <code>event.y</code>. Ми можемо зробити це так:</p>
<pre><code class="language-js">test(<span class="hljs-string">'onPress gets called with the right thing'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(expect.objectContaining({
    <span class="hljs-attr">x</span>: expect.any(<span class="hljs-built_in">Number</span>),
    <span class="hljs-attr">y</span>: expect.any(<span class="hljs-built_in">Number</span>),
  }));
});
</code></pre>
<h3><a class="anchor" name="expectstringcontainingstring"></a><code>expect.stringContaining(string)</code> <a class="hash-link" href="#expectstringcontainingstring">#</a></h3>
<h5><a class="anchor" name="jest-1900"></a>доступно в Jest <strong>19.0.0+</strong> <a class="hash-link" href="#jest-1900">#</a></h5>
<p><code>expect.stringContaining(string)</code> відповідає будь-якому отриманому рядку, який містить в собі очікуваний.</p>
<h3><a class="anchor" name="expectstringmatchingregexp"></a><code>expect.stringMatching(regexp)</code> <a class="hash-link" href="#expectstringmatchingregexp">#</a></h3>
<p><code>expect.stringMatching(regexp)</code> відповідає будь якому рядку, який співпадає з оікуваним регулярним виразом.</p>
<p>Ви можете використовувати його замість явного вказання значень:</p>
<ul>
<li>в <code>toEqual</code> або <code>toBeCalledWith</code></li>
<li>щоб вказати відповідність елементу в <code>arrayContaining</code></li>
<li>щоб вказати відповідність властивості в <code>objectContaining</code> або <code>toMatchObject</code></li>
</ul>
<p>Наступний приклад показує як можна використовувати кілька вкладених матчерів з <code>expect.stringMatching</code> всередині <code>expect.arrayContaining</code>.</p>
<pre><code class="language-js">describe(<span class="hljs-string">'stringMatching in arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [
    expect.stringMatching(<span class="hljs-regexp">/^Alic/</span>),
    expect.stringMatching(<span class="hljs-regexp">/^[BR]ob/</span>),
  ];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alicia'</span>, <span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" name="expectaddsnapshotserializerserializer"></a><code>expect.addSnapshotSerializer(serializer)</code> <a class="hash-link" href="#expectaddsnapshotserializerserializer">#</a></h3>
<p>Ви можете викликати <code>expect.addSnapshotSerializer</code>, щоб додати модуль, який форматує специфічні для вашої програми структури даних.</p>
<p>Для откремого файлу з тестами, вказаний модуль буде мати пріорітет над модулями з розділу <code>snapshotSerializers</code> файла конфігурації, які мають пріорітет над серіалізаторами для вбудованих типів JavaScript та React елементів. Останній доданий модуль буде використаний першим.</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> serializer <span class="hljs-keyword">from</span> <span class="hljs-string">'my-serializer-module'</span>;
expect.addSnapshotSerializer(serializer);

<span class="hljs-comment">// впливає на всі твердження expect(value).toMatchSnapshot() в межах файла з тестами</span>
</code></pre>
<p>Якщо ви додаєте серіалізатор знімків для окремого файла з тестами замість додавання його в розділ <code>snapshotSerializers</code> файлу конфігурації, то:</p>
<ul>
<li>Ви робити залежність явною, замість неявної.</li>
<li>Ви уникаєте обмежень на зміну конфігурації, які можуть призвести до необхідності виконувати команду <code>eject</code> для <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>.</li>
</ul>
<p>See <a href="/jest/docs/uk/configuration.html#snapshotserializers-array-string">configuring Jest</a> for more information.</p>
<h3><a class="anchor" name="not"></a><code>.not</code> <a class="hash-link" href="#not">#</a></h3>
<p>Якщо ви знаєте, як перевірити якесь твердження, то <code>.not</code> дозволяє перевірити протилежне до цього твердження. Наприклад наступний код перевіряє,що найклащий смак Ла-Круа — не кокосовий:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best flavor is not coconut'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).not.toBe(<span class="hljs-string">'coconut'</span>);
});
</code></pre>
<h3><a class="anchor" name="resolves"></a><code>.resolves</code> <a class="hash-link" href="#resolves">#</a></h3>
<h5><a class="anchor" name="jest-2000"></a>Доступно в Jest <strong>20.0.0+</strong> <a class="hash-link" href="#jest-2000">#</a></h5>
<p>Використовуйте <code>resolves</code> для отримання значення виконаного промісу, щоб будь-який інший матчер міг його перевірити. Якщо проміс буде відхилено, твердження не виконається.</p>
<p>Наприклад, цей код перевіряє, що проміс виконується успішно і його значення — це <code>'lemon'</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'resolves to lemon'</span>, () =&gt; {
  <span class="hljs-comment">// не забудьте додати оператор return</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
});
</code></pre>
<p>Крім того, ви можете використовувати <code>async/await</code> у поєднання з <code>.resolves</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'resolves to lemon'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.not.toBe(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" name="rejects"></a><code>.rejects</code> <a class="hash-link" href="#rejects">#</a></h3>
<h5><a class="anchor" name="jest-2000"></a>Доступно в Jest <strong>20.0.0+</strong> <a class="hash-link" href="#jest-2000">#</a></h5>
<p>Використовуйте <code>resolves</code> для отримання значення відхиленого промісу, щоб будь-який інший матчер міг його перевірити. Якщо проміс буде виконано успішно, твердження не виконається.</p>
<p>Наприклад, цей код перевіряє, що проміс було відхилено з вказанням причини:</p>
<pre><code class="language-js">test(<span class="hljs-string">'fetchData() rejects to be error'</span>, () =&gt; {
  <span class="hljs-comment">// не забудьте додати оператор return</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'octopus'</span>)).rejects.toBeDefined();
});
</code></pre>
<p>Крім того, ви можете використовувати <code>async/await</code> у поєднанні з <code>.rejects</code>. Більше того, наступний код перевіряє, що причина відхилення містить рядок 'octopus':</p>
<pre><code class="language-js">test(<span class="hljs-string">'fetchData() rejects to be error'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> drinkOctopus = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  });

  <span class="hljs-keyword">await</span> expect(drinkOctopus).rejects.toMatch(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobevalue"></a><code>.toBe(value)</code> <a class="hash-link" href="#tobevalue">#</a></h3>
<p><code>toBe</code> перевіряє, що значення є саме таким, як ви очікуєте. Він використовує <code>===</code> для перевірки суворої рівності.</p>
<p>Наприклад, наступний код буде валідувати деякі властивості об’єкту <code>can</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> can = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'pamplemousse'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the can'</span>, () =&gt; {
  test(<span class="hljs-string">'has 12 ounces'</span>, () =&gt; {
    expect(can.ounces).toBe(<span class="hljs-number">12</span>);
  });

  test(<span class="hljs-string">'has a sophisticated name'</span>, () =&gt; {
    expect(can.name).toBe(<span class="hljs-string">'pamplemousse'</span>);
  });
});
</code></pre>
<p>Не використовуйте <code>toBe</code> для чисел з плаваючою комою. Наприклад, через округлення в JavaScript, <code>0.2 + 0.1</code> не дорівнює <code>0.3</code>. Якщо вам потрібно перевіряти числа з плаваючою комою, використовуйте <code>.toBeCloseTo</code>.</p>
<h3><a class="anchor" name="tohavebeencalled"></a><code>.toHaveBeenCalled()</code> <a class="hash-link" href="#tohavebeencalled">#</a></h3>
<p>Також має псевдонім <code>.toBeCalled()</code></p>
<p>Використовуйте <code>.toHaveBeenCalled</code>, щоб переконатися, що мок функція була викликана.</p>
<p>Наприклад, нехай у вас є функція <code>drinkAll(drink, flavor)</code>, яка приймає функцію <code>drink</code> та викликає її для всіх доступних напоїв. Ви можете перевірити, що функція <code>drink</code> викликається для <code>'lemon'</code>, але не викликається для <code>'octopus'</code>. Це можна зробити наступним чином:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'drinkAll'</span>, () =&gt; {
  test(<span class="hljs-string">'drinks something lemon-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'lemon'</span>);
    expect(drink).toHaveBeenCalled();
  });

  test(<span class="hljs-string">'does not drink something octopus-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'octopus'</span>);
    expect(drink).not.toHaveBeenCalled();
  });
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledtimesnumber"></a><code>.toHaveBeenCalledTimes(number)</code> <a class="hash-link" href="#tohavebeencalledtimesnumber">#</a></h3>
<p>Використовуйте <code>.toHaveBeenCalledTimes</code>, щоб переконатися, що мок функція була викликана певну кількість разів.</p>
<p>Наприклад, нехай у вас є функція <code>drinkEach(drink, Array&lt;flavor&gt;)</code>, яка приймає функцію <code>drink</code> та викликає її для масиву переданих напоїв. Ви можете захотіти перевірити, що передана функція була викликана рівно вказану кількість разів. Це можна зробити наступним чином:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinkEach drinks each drink'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  drinkEach(drink, [<span class="hljs-string">'lemon'</span>, <span class="hljs-string">'octopus'</span>]);
  expect(drink).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledwitharg1-arg2-"></a><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeencalledwitharg1-arg2-">#</a></h3>
<p>Також має псевдонім <code>.toBeCalledWith()</code></p>
<p>Використовуйте <code>.toHaveBeenCalledWith()</code>, щоб переконатися, що мок функція була викликана зі вказаними аргументами.</p>
<p>Наприклад, нехай ви можете зареєструвати напій з допомогою функції <code>register()</code>, а функція <code>applyToAll(f)</code> повинна застосувати функцію <code>f</code> до всіх зареєстрованих напоїв. Щоб переконатися, що це працює, ви можете написати:</p>
<pre><code class="language-js">test(<span class="hljs-string">'registration applies correctly to orange La Croix'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage = <span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'orange'</span>);
  register(beverage);
  <span class="hljs-keyword">const</span> f = jest.fn();
  applyToAll(f);
  expect(f).toHaveBeenCalledWith(beverage);
});
</code></pre>
<h3><a class="anchor" name="tohavebeenlastcalledwitharg1-arg2-"></a><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeenlastcalledwitharg1-arg2-">#</a></h3>
<p>Також має псевдонім <code>.lastCalledWith(arg1, arg2, ...)</code></p>
<p>Ви можете використати <code>.toHaveBeenLastCalledWith</code>, щоб перевірити аргументи, з якими мок функція була викликана востаннє. Наприклад, нехай у вас є функція <code>applyToAllFlavors(f)</code>, яка застосовує функцію <code>f</code> до набору смаків і ви хочете переконатися, що коли ви її викличите, то останній смак, з яким вона буде працювати - це <code>'mango'</code>. Ви можете написати:</p>
<pre><code class="language-js">test(<span class="hljs-string">'applying to all flavors does mango last'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  applyToAllFlavors(drink);
  expect(drink).toHaveBeenLastCalledWith(<span class="hljs-string">'mango'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeclosetonumber-numdigits"></a><code>.toBeCloseTo(number, numDigits)</code> <a class="hash-link" href="#tobeclosetonumber-numdigits">#</a></h3>
<p>Використання суворого порівняння для чисел з плаваючою кмою - це погана ідея. Через проблему округлення, інтуітивно правильне твердження не буде виконуватися. Наприклад наступний тест виконається з помилкою:</p>
<pre><code class="language-js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBe(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// Помилка!</span>
});
</code></pre>
<p>Тут буде помилка, оскільки <code>0.2 + 0.1</code> в JavaScript насправді дорівнює <code>0.30000000000000004</code>.</p>
<p>Тому краще використовувати <code>.toBeCloseTo</code>. Використовуйте параметр <code>numDigits</code>, щоб вказувати як багато знаків після коми перевіряти. Наприклад, якщо ви хочете переконатися, що <code>0.2 + 0.1</code> дорівнює <code>0.3</code> з точністю до 5 знаків після коми, ви можете використати наступний тест:</p>
<pre><code class="language-js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBeCloseTo(<span class="hljs-number">0.3</span>, <span class="hljs-number">5</span>);
});
</code></pre>
<p>Значення <code>numDigits</code> за замовчуванням — 2, що зазвичай достатньо для більшості випадків.</p>
<h3><a class="anchor" name="tobedefined"></a><code>.toBeDefined()</code> <a class="hash-link" href="#tobedefined">#</a></h3>
<p>Висористовуйте <code>.toBeDefined()</code>, щоб переірити, що змінна визначена. Наприклад, якщо ви хочете перевірити, що функція <code>fetchNewFlavorIdea()</code> <em>щось</em> повертає, ви можете написати:</p>
<pre><code class="language-js">test(<span class="hljs-string">'there is a new flavor idea'</span>, () =&gt; {
  expect(fetchNewFlavorIdea()).toBeDefined();
});
</code></pre>
<p>Ви також можете написати <code>expect(fetchNewFlavorIdea()).not.toBe(undefined)</code>, але хорошою практикою є уникати прямого використання <code>undefined</code> в коді.</p>
<h3><a class="anchor" name="tobefalsy"></a><code>.toBeFalsy()</code> <a class="hash-link" href="#tobefalsy">#</a></h3>
<p>Використовуйте <code>.toBeFalsy()</code>, коли вам не важливо, яким є значення і ви всього лише хочете переконатися, що значення приводиться до <code>false</code> в булевому контексті. Наприклад, нехай у вас є наступний код:</p>
<pre><code class="language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (!getErrors()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>Вас може не цікавити, яке саме значення повертає <code>getErrors</code>. Це може бути <code>false</code>, <code>null</code> чи `` — ваш код все одно буде працювати. Отже, якщо в ихочете перевірити, що немає помилок після вживання Ла-Круа, ви можете написати:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinking La Croix does not lead to errors'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(getErrors()).toBeFalsy();
});
</code></pre>
<p>В JavaScript існує шість значень, які приводяться до <code>false</code> в булевому контексті: <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code> і <code>NaN</code>. Все інше приводиться до <code>true</code>.</p>
<h3><a class="anchor" name="tobegreaterthannumber"></a><code>.toBeGreaterThan(number)</code> <a class="hash-link" href="#tobegreaterthannumber">#</a></h3>
<p>Для порівняння чисел з плаваючою комою, ви можете використовувати <code>toBeGreaterThan</code>. Наприклад, якщо ви хочете протестувати, що <code>ouncesPerCan()</code> повертає значення, більше за 10, напишіть:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is more than 10'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThan(<span class="hljs-number">10</span>);
});
</code></pre>
<h3><a class="anchor" name="tobegreaterthanorequalnumber"></a><code>.toBeGreaterThanOrEqual(number)</code> <a class="hash-link" href="#tobegreaterthanorequalnumber">#</a></h3>
<p>Для порівняння чисел з плаваючою комою, ви можете використовувати <code>toBeGreaterThanOrEqual</code>. Наприклад, якщо ви хочете протестувати, що <code>ouncesPerCan()</code> повертає щонайменше 12, напишіть:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is at least 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthannumber"></a><code>.toBeLessThan(number)</code> <a class="hash-link" href="#tobelessthannumber">#</a></h3>
<p>Для порівняння чисел з плаваючою комою, ви можете використовувати <code>toBeLessThan</code>. Наприклад, якщо ви хочете протестувати, що <code>ouncesPerCan()</code> повертає значення, менше за 10, напишіть:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is less than 20'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThan(<span class="hljs-number">20</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthanorequalnumber"></a><code>.toBeLessThanOrEqual(number)</code> <a class="hash-link" href="#tobelessthanorequalnumber">#</a></h3>
<p>Для порівняння чисел з плаваючою комою, ви можете використовувати <code>toBeLessThanOrEqual</code>. Наприклад, якщо ви хочете протестувати, що <code>ouncesPerCan()</code> повертає щонайбільше 12, напишіть:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is at most 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeinstanceofclass"></a><code>.toBeInstanceOf(Class)</code> <a class="hash-link" href="#tobeinstanceofclass">#</a></h3>
<p>Використовуйте <code>.toBeInstanceOf(Class)</code>, щоб перевірити, що об’єкт є екземпляром певного класу. Цей матчер використовує <code>instanceof</code> всередині.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{}

expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(A);
expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}).toBeInstanceOf(<span class="hljs-built_in">Function</span>);
expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(<span class="hljs-built_in">Function</span>); <span class="hljs-comment">// помилка</span>
</code></pre>
<h3><a class="anchor" name="tobenull"></a><code>.toBeNull()</code> <a class="hash-link" href="#tobenull">#</a></h3>
<p><code>.toBeNull()</code> — це те ж саме, що і <code>.toBe(null)</code>, але має трохи краще повідомлення про помилку. Тож використовуйте <code>.toBeNull()</code>, коли ви хочете перевірити, що якесь значення дорівнює null.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bloop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

test(<span class="hljs-string">'bloop returns null'</span>, () =&gt; {
  expect(bloop()).toBeNull();
});
</code></pre>
<h3><a class="anchor" name="tobetruthy"></a><code>.toBeTruthy()</code> <a class="hash-link" href="#tobetruthy">#</a></h3>
<p>Використовуйте <code>. toBeTruthy()</code>, коли вам не важливо, яким є значення і ви всього лише хочете переконатися, що значення приводиться до <code>true</code> в булевому контексті. Наприклад, нехай у вас є наступний код:</p>
<pre><code class="language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (thirstInfo()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>Вас може не цікавити, яке саме значення повертає <code>thirstInfo</code>. Це може бути <code>true</code> або складний об’єкт — ваш код все одно буде працювати. Тому, якщо ви просто хочете перевірити, що результат <code>thirstInfo</code> буде приведено до <code>true</code>, ви можете написати:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinking La Croix leads to having thirst info'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(thirstInfo()).toBeTruthy();
});
</code></pre>
<p>В JavaScript існує шість значень, які приводяться до <code>false</code> в булевому контексті: <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code> і <code>NaN</code>. Все інше приводиться до <code>true</code>.</p>
<h3><a class="anchor" name="tobeundefined"></a><code>.toBeUndefined()</code> <a class="hash-link" href="#tobeundefined">#</a></h3>
<p>Висористовуйте <code>.toBeUndefined()</code>, щоб переірити, що змінна не визначена. Наприклад, якщо ви хочете перевірити, що функція <code>bestDrinkForFlavor(flavor)</code> повертає <code>undefined</code>, якщо їй передати смак <code>'octopus'</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best drink for octopus flavor is undefined'</span>, () =&gt; {
  expect(bestDrinkForFlavor(<span class="hljs-string">'octopus'</span>)).toBeUndefined();
});
</code></pre>
<p>Ви також можете написати <code>expect(bestDrinkForFlavor()).toBe(undefined)</code>, але хорошою практикою є уникати прямого використання <code>undefined</code> в коді.</p>
<h3><a class="anchor" name="tocontainitem"></a><code>.toContain(item)</code> <a class="hash-link" href="#tocontainitem">#</a></h3>
<p>Use <code>.toContain</code> when you want to check that an item is in an array. For testing the items in the array, this uses <code>===</code>, a strict equality check. <code>.toContain</code> can also check whether a string is a substring of another string.</p>
<p>For example, if <code>getAllFlavors()</code> returns an array of flavors and you want to be sure that <code>lime</code> is in there, you can write:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the flavor list contains lime'</span>, () =&gt; {
  expect(getAllFlavors()).toContain(<span class="hljs-string">'lime'</span>);
});
</code></pre>
<h3><a class="anchor" name="tocontainequalitem"></a><code>.toContainEqual(item)</code> <a class="hash-link" href="#tocontainequalitem">#</a></h3>
<p>Use <code>.toContainEqual</code> when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity.</p>
<pre><code class="language-js">describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious and not sour'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> myBeverage = {<span class="hljs-attr">delicious</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">sour</span>: <span class="hljs-literal">false</span>};
    expect(myBeverages()).toContainEqual(myBeverage);
  });
});
</code></pre>
<h3><a class="anchor" name="toequalvalue"></a><code>.toEqual(value)</code> <a class="hash-link" href="#toequalvalue">#</a></h3>
<p>Використовуйте <code>.toEqual</code>, коли ви хочете перевірити, що два об’єкти мають однакове значення. Цей матчер рекурсивно порівнує всі поля об’єктів, замість перевірки їх рівності. Така перевірка також відома, як глибоке порівняння. Наприклад, <code>toEqual</code> і <code>toBe</code> поводяться по-різному в наступному наборі тестів, тому всі тести проходять успішно:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> can1 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};
<span class="hljs-keyword">const</span> can2 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the La Croix cans on my desk'</span>, () =&gt; {
  test(<span class="hljs-string">'have all the same properties'</span>, () =&gt; {
    expect(can1).toEqual(can2);
  });
  test(<span class="hljs-string">'are not the exact same can'</span>, () =&gt; {
    expect(can1).not.toBe(can2);
  });
});
</code></pre>
<blockquote>
<p>Примітка: <code>.toEqual</code> не виконує порівняння на <em>глибоку рівність</em> для двох об’єктів помилок. Порівнюються лише їх властивості <code>message</code>. Рекомендується використовувати матчер <code>.toThrow</code> для тестування об’єктів помилок.</p>
</blockquote>
<h3><a class="anchor" name="tohavelengthnumber"></a><code>.toHaveLength(number)</code> <a class="hash-link" href="#tohavelengthnumber">#</a></h3>
<p>Використовуйте <code>.toHaveLength</code>, щоб перевірити, що об’єкт має властивість <code>.length</code> і вона дорівнює певному числовому значенню.</p>
<p>Це особливо корисно для перевірки розміру масивів або довжини рядків.</p>
<pre><code class="language-js">expect([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">'abc'</span>).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">''</span>).not.toHaveLength(<span class="hljs-number">5</span>);
</code></pre>
<h3><a class="anchor" name="tomatchregexporstring"></a><code>.toMatch(regexpOrString)</code> <a class="hash-link" href="#tomatchregexporstring">#</a></h3>
<p>Використовуйте <code>.toMatch</code>, щоб перевірити, що рядок відповідає регулярному виразу.</p>
<p>Наприклад, ви можете не знати точно, що повертає <code>essayOnTheBestFlavor()</code>, але ви знаєте, що це досить довгий рядок і він повинен містити в собі рядок <code>grapefruit</code>. Ви можете протестувати це так:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'an essay on the best flavor'</span>, () =&gt; {
  test(<span class="hljs-string">'mentions grapefruit'</span>, () =&gt; {
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-regexp">/grapefruit/</span>);
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'grapefruit'</span>));
  });
});
</code></pre>
<p>Цей матчер також приймає рядок, який він намагатиметься знайти:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'grapefruits are healthy'</span>, () =&gt; {
  test(<span class="hljs-string">'grapefruits are a fruit'</span>, () =&gt; {
    expect(<span class="hljs-string">'grapefruits'</span>).toMatch(<span class="hljs-string">'fruit'</span>);
  });
});
</code></pre>
<h3><a class="anchor" name="tomatchobjectobject"></a><code>.toMatchObject(object)</code> <a class="hash-link" href="#tomatchobjectobject">#</a></h3>
<p>Використовуйте <code>.toMatchObject</code>, щоб перевірити, що JavaScript об’єкт відповідає підмножині властивостей очікуваного об’єкту. Він відповідає отриманому об’єкту, який місить властивості, яких <strong>немає</strong> у очікуваному об’єкті.</p>
<p>Ви можете передати масив об’єктів. В такому випадку метод поверне true тільки якщо кожен з об’єктів масиву проходить сходиться (у сенсі <code>toMatchObject</code>, який описаний вище) з відповідним об’єктом очікуваного масиву. Це корисно, якщо в ихочете перевірити, що два масиви збігаються за кількістю елементів на противагу <code>arrayContaining</code>, який дозволяє додаткові елементи в отриманому масиві.</p>
<p>Ви можете поівнювати властивості зі значеннями або з матчерами.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};
<span class="hljs-keyword">const</span> desiredHouse = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">wallColor</span>: expect.stringMatching(<span class="hljs-regexp">/white|yellow/</span>),
  },
};

test(<span class="hljs-string">'the house has my desired features'</span>, () =&gt; {
  expect(houseForSale).toMatchObject(desiredHouse);
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'toMatchObject applied to arrays arrays'</span>, () =&gt; {
  test(<span class="hljs-string">'the number of elements must match exactly'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });

  <span class="hljs-comment">// .arrayContaining "matches a received array which contains elements that are *not* in the expected array"</span>
  test(<span class="hljs-string">'.toMatchObject does not allow extra elements'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> }
    ]);
  });

  test(<span class="hljs-string">'.toMatchObject is called for each elements, so extra object properties are okay'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">extra</span>: <span class="hljs-string">'quux'</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });
});
</code></pre>
<h3><a class="anchor" name="tohavepropertykeypath-value"></a><code>.toHaveProperty(keyPath, value)</code> <a class="hash-link" href="#tohavepropertykeypath-value">#</a></h3>
<p>Використовуйте <code>.toHaveProperty</code>, щоб перевірити, чи властивість за заданим в <code>keyPath</code> посиланням існує для об’єкта. Для перевірки вкладених властивостей об’єкта, використовуйте <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors">запис через крапку</a> для вказання назви вкладених полів.</p>
<p>Опціонально, ви можете вказати значення <code>value</code>, яке має містити властивість <code>keyPath</code> цільового об’єкту. Цей матчер використовує глибоке порівняння (як <code>toEqual()</code>) і рекурсивно перевіряє рівність усіх полів.</p>
<p>Наступий приклад містить об’єкт <code>houseForSale</code> з двома вкладеними властивостями. Ми використовуємо <code>toHaveProperty</code>, щоб перевірити наявність і значення різних властивостей об’єкта.</p>
<pre><code class="language-js"><span class="hljs-comment">// об’єкт, що містить властивості будинку, які потрібно протестувати</span>
<span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};

test(<span class="hljs-string">'this house has my desired features'</span>, () =&gt; {
  <span class="hljs-comment">// Simple Referencing</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bath'</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bedrooms'</span>, <span class="hljs-number">4</span>);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'pool'</span>);

  <span class="hljs-comment">// Deep referencing using dot notation</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.area'</span>, <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.amenities'</span>, [
    <span class="hljs-string">'oven'</span>,
    <span class="hljs-string">'stove'</span>,
    <span class="hljs-string">'washer'</span>,
  ]);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'kitchen.open'</span>);
});
</code></pre>
<h3><a class="anchor" name="tomatchsnapshotoptionalstring"></a><code>.toMatchSnapshot(optionalString)</code> <a class="hash-link" href="#tomatchsnapshotoptionalstring">#</a></h3>
<p>This ensures that a value matches the most recent snapshot. Check out <a href="/jest/docs/uk/snapshot-testing.html">the Snapshot Testing guide</a> for more information.</p>
<p>Ви також можете вказати опціональне ім’я знімка. Інакше, ім’я буде взято з назви тесту.</p>
<p><em>Примітка: хоча тестування з допомогою знімків найчастіше використовується для React компонентів, будь-яке значення, яке можна серіалізувати, може бути використане як знімок.</em></p>
<h3><a class="anchor" name="tothrowerror"></a><code>.toThrow(error)</code> <a class="hash-link" href="#tothrowerror">#</a></h3>
<p>Також має псевдонім <code>. toThrowError(error)</code></p>
<p>Використовуйте <code>.toThrow</code>, щоб переконатися, що функція викликає помилку під час виконання. Наприклад, якщо ми хочемо перевірити, що <code>drinkFlavor('octopus')</code> викликає помилку через те, що смак восминога занадто огидний для пиття, ми можемо написати:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }).toThrow();
});
</code></pre>
<p>Якщо ви хочете перевірити, що викликається конкретна помилка, ви можете вказати аргумент для <code>toThrow</code>. Аргументом може бути рядок повідомлення про помилку, клас помилки або регулярний вираз, якому має відповідати помилка. Наприклад, нехай функція <code>drinkFlavor</code> написана так:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Робіть інші речі</span>
}
</code></pre>
<p>Ми можемо протестувати, що вона викликає помилку кількома способами:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  <span class="hljs-comment">// Перевірка точного співпадіння повідомлення про помилку</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-string">'yuck, octopus flavor'</span>);

  <span class="hljs-comment">// Перевірка, що рядок "yuck" присутній в повідомленні про помилку</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-regexp">/yuck/</span>);

  <span class="hljs-comment">// Перевірка, що помилка має тип DisgustingFlavorError</span>
  expect(drinkOctopus).toThrowError(DisgustingFlavorError);
});
</code></pre>
<blockquote>
<p>Note: You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail.</p>
</blockquote>
<h3><a class="anchor" name="tothrowerrormatchingsnapshot"></a><code>.toThrowErrorMatchingSnapshot()</code> <a class="hash-link" href="#tothrowerrormatchingsnapshot">#</a></h3>
<p>Використовуйте <code>.toThrowErrorMatchingSnapshot</code>, щоб протестувати, що функція викликає помилку під час виконання, яка співпадає з останнім знімком. Наприклад, нехай у вас є функція <code>drinkFlavor</code>, яка викликає помилку, коли отримує смак <code>'octopus'</code>, і вона написана так:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Робіть інші речі</span>
}
</code></pre>
<p>Тест для цієї функції виглядатиме наступним чином:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  expect(drinkOctopus).toThrowErrorMatchingSnapshot();
});
</code></pre>
<p>І він створить наступний знімок:</p>
<pre><code>exports[`drinking flavors throws on octopus 1`] = `&quot;yuck, octopus flavor&quot;`;
</code></pre>
<p>Ознайомтеся з розділом <a href="http://facebook.github.io/jest/blog/2016/07/27/jest-14.html">Тестування дерева React за допомогою знімків</a> для додаткової інформації про тестування зі знімками.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="api.html">← Globals</a><a class="docs-next button" href="mock-function-api.html">Mock Functions →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/uk/getting-started.html">Getting Started</a><a href="/jest/docs/uk/snapshot-testing.html">Guides</a><a href="/jest/docs/uk/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/uk/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-count-api="/repos/facebook/jest#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>