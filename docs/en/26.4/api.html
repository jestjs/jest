<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Globals · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="In your test files, Jest puts each of these methods and objects into the global environment. You don&#x27;t have to require or import anything to use them. However, if you prefer explicit imports, you can do `import {describe, expect, test} from &#x27;@jest/globals&#x27;`."/><meta name="docsearch:version" content="26.4"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Globals · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jestjs.io/"/><meta property="og:description" content="In your test files, Jest puts each of these methods and objects into the global environment. You don&#x27;t have to require or import anything to use them. However, if you prefer explicit imports, you can do `import {describe, expect, test} from &#x27;@jest/globals&#x27;`."/><meta property="og:image" content="https://jestjs.io/img/opengraph.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://jestjs.io/img/jest.png"/><link rel="shortcut icon" href="/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://jestjs.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://jestjs.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/img/jest.svg" alt="Jest"/><h2 class="headerTitleWithLogo">Jest</h2></a><a href="/en/versions"><h3>26.4</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/en/26.4/getting-started" target="_self">Docs</a></li><li class="siteNavGroupActive siteNavItemActive"><a href="/docs/en/26.4/api" target="_self">API</a></li><li class=""><a href="/en/help" target="_self">Help</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/26.4/api">日本語</a></li><li><a href="/docs/es-ES/26.4/api">Español</a></li><li><a href="/docs/pt-BR/26.4/api">Português (Brasil)</a></li><li><a href="/docs/ro/26.4/api">Română</a></li><li><a href="/docs/ru/26.4/api">Русский</a></li><li><a href="/docs/uk/26.4/api">Українська</a></li><li><a href="/docs/zh-Hans/26.4/api">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>API Reference</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/26.4/getting-started">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/using-matchers">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/asynchronous">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/setup-teardown">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/mock-functions">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/jest-platform">Jest Platform</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/jest-community">Jest Community</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/more-resources">More Resources</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/26.4/snapshot-testing">Snapshot Testing</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/tutorial-async">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/timer-mocks">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/manual-mocks">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/es6-class-mocks">ES6 Class Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/bypassing-module-mocks">Bypassing module mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/ecmascript-modules">ECMAScript Modules</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/webpack">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/puppeteer">Using with puppeteer</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/mongodb">Using with MongoDB</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/dynamodb">Using with DynamoDB</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/tutorial-jquery">DOM Manipulation</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/watch-plugins">Watch Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/migration-guide">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/architecture">Architecture</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Framework Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/26.4/tutorial-react">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/tutorial-react-native">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/testing-frameworks">Testing Web Frameworks</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API Reference</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/en/26.4/api">Globals</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/expect">Expect</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/mock-function-api">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/jest-object">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/configuration">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/docs/en/26.4/cli">Jest CLI Options</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/jest/edit/master/docs/GlobalAPI.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Globals</h1></header><article><div><span><p>In your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do <code>import {describe, expect, test} from '@jest/globals'</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="methods"></a><a href="#methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Methods</h2>
<ul>
<li><a href="#afterallfn-timeout"><code>afterAll(fn, timeout)</code></a></li>
<li><a href="#aftereachfn-timeout"><code>afterEach(fn, timeout)</code></a></li>
<li><a href="#beforeallfn-timeout"><code>beforeAll(fn, timeout)</code></a></li>
<li><a href="#beforeeachfn-timeout"><code>beforeEach(fn, timeout)</code></a></li>
<li><a href="#describename-fn"><code>describe(name, fn)</code></a></li>
<li><a href="#describeeachtablename-fn-timeout"><code>describe.each(table)(name, fn, timeout)</code></a></li>
<li><a href="#describeonlyname-fn"><code>describe.only(name, fn)</code></a></li>
<li><a href="#describeonlyeachtablename-fn"><code>describe.only.each(table)(name, fn)</code></a></li>
<li><a href="#describeskipname-fn"><code>describe.skip(name, fn)</code></a></li>
<li><a href="#describeskipeachtablename-fn"><code>describe.skip.each(table)(name, fn)</code></a></li>
<li><a href="#testname-fn-timeout"><code>test(name, fn, timeout)</code></a></li>
<li><a href="#testconcurrentname-fn-timeout"><code>test.concurrent(name, fn, timeout)</code></a></li>
<li><a href="#testconcurrenteachtablename-fn-timeout"><code>test.concurrent.each(table)(name, fn, timeout)</code></a></li>
<li><a href="#testconcurrentonlyeachtablename-fn"><code>test.concurrent.only.each(table)(name, fn)</code></a></li>
<li><a href="#testconcurrentskipeachtablename-fn"><code>test.concurrent.skip.each(table)(name, fn)</code></a></li>
<li><a href="#testeachtablename-fn-timeout"><code>test.each(table)(name, fn, timeout)</code></a></li>
<li><a href="#testonlyname-fn-timeout"><code>test.only(name, fn, timeout)</code></a></li>
<li><a href="#testonlyeachtablename-fn"><code>test.only.each(table)(name, fn)</code></a></li>
<li><a href="#testskipname-fn"><code>test.skip(name, fn)</code></a></li>
<li><a href="#testskipeachtablename-fn"><code>test.skip.each(table)(name, fn)</code></a></li>
<li><a href="#testtodoname"><code>test.todo(name)</code></a></li>
</ul>
<hr>
<h2><a class="anchor" aria-hidden="true" id="reference"></a><a href="#reference" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reference</h2>
<h3><a class="anchor" aria-hidden="true" id="afterallfn-timeout"></a><a href="#afterallfn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>afterAll(fn, timeout)</code></h3>
<p>Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</p>
<p>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<p>This is often useful if you want to clean up some global setup state that is shared across tests.</p>
<p>For example:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanUpDatabase</span>(<span class="hljs-params">db</span>) </span>{
  db.cleanUp();
}

afterAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cleanUpDatabase(globalDatabase);
});

test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});

test(<span class="hljs-string">'can insert a thing'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.insert(<span class="hljs-string">'thing'</span>, makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<p>Here the <code>afterAll</code> ensures that <code>cleanUpDatabase</code> is called after all tests run.</p>
<p>If <code>afterAll</code> is inside a <code>describe</code> block, it runs at the end of the describe block.</p>
<p>If you want to run some cleanup after every test instead of after all tests, use <code>afterEach</code> instead.</p>
<h3><a class="anchor" aria-hidden="true" id="aftereachfn-timeout"></a><a href="#aftereachfn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>afterEach(fn, timeout)</code></h3>
<p>Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</p>
<p>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<p>This is often useful if you want to clean up some temporary state that is created by each test.</p>
<p>For example:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanUpDatabase</span>(<span class="hljs-params">db</span>) </span>{
  db.cleanUp();
}

afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cleanUpDatabase(globalDatabase);
});

test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});

test(<span class="hljs-string">'can insert a thing'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.insert(<span class="hljs-string">'thing'</span>, makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<p>Here the <code>afterEach</code> ensures that <code>cleanUpDatabase</code> is called after each test runs.</p>
<p>If <code>afterEach</code> is inside a <code>describe</code> block, it only runs after the tests that are inside this describe block.</p>
<p>If you want to run some cleanup just once, after all of the tests run, use <code>afterAll</code> instead.</p>
<h3><a class="anchor" aria-hidden="true" id="beforeallfn-timeout"></a><a href="#beforeallfn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>beforeAll(fn, timeout)</code></h3>
<p>Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.</p>
<p>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<p>This is often useful if you want to set up some global state that will be used by many tests.</p>
<p>For example:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Clears the database and adds some testing data.</span>
  <span class="hljs-comment">// Jest will wait for this promise to resolve before running tests.</span>
  <span class="hljs-keyword">return</span> globalDatabase.clear().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> globalDatabase.insert({<span class="hljs-attr">testData</span>: <span class="hljs-string">'foo'</span>});
  });
});

<span class="hljs-comment">// Since we only set up the database once in this example, it's important</span>
<span class="hljs-comment">// that our tests don't modify it.</span>
test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});
</code></pre>
<p>Here the <code>beforeAll</code> ensures that the database is set up before tests run. If setup was synchronous, you could do this without <code>beforeAll</code>. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.</p>
<p>If <code>beforeAll</code> is inside a <code>describe</code> block, it runs at the beginning of the describe block.</p>
<p>If you want to run something before every test instead of before any test runs, use <code>beforeEach</code> instead.</p>
<h3><a class="anchor" aria-hidden="true" id="beforeeachfn-timeout"></a><a href="#beforeeachfn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>beforeEach(fn, timeout)</code></h3>
<p>Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.</p>
<p>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<p>This is often useful if you want to reset some global state that will be used by many tests.</p>
<p>For example:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Clears the database and adds some testing data.</span>
  <span class="hljs-comment">// Jest will wait for this promise to resolve before running tests.</span>
  <span class="hljs-keyword">return</span> globalDatabase.clear().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> globalDatabase.insert({<span class="hljs-attr">testData</span>: <span class="hljs-string">'foo'</span>});
  });
});

test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});

test(<span class="hljs-string">'can insert a thing'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.insert(<span class="hljs-string">'thing'</span>, makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<p>Here the <code>beforeEach</code> ensures that the database is reset for each test.</p>
<p>If <code>beforeEach</code> is inside a <code>describe</code> block, it runs for each test in the describe block.</p>
<p>If you only need to run some setup code once, before any tests run, use <code>beforeAll</code> instead.</p>
<h3><a class="anchor" aria-hidden="true" id="describename-fn"></a><a href="#describename-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe(name, fn)</code></h3>
<p><code>describe(name, fn)</code> creates a block that groups together several related tests. For example, if you have a <code>myBeverage</code> object that is supposed to be delicious but not sour, you could test it with:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> myBeverage = {
  <span class="hljs-attr">delicious</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">sour</span>: <span class="hljs-literal">false</span>,
};

describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious'</span>, () =&gt; {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test(<span class="hljs-string">'is not sour'</span>, () =&gt; {
    expect(myBeverage.sour).toBeFalsy();
  });
});
</code></pre>
<p>This isn't required - you can write the <code>test</code> blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.</p>
<p>You can also nest <code>describe</code> blocks if you have a hierarchy of tests:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> binaryStringToNumber = <span class="hljs-function"><span class="hljs-params">binString</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^[01]+$/</span>.test(binString)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomError(<span class="hljs-string">'Not a binary number.'</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(binString, <span class="hljs-number">2</span>);
};

describe(<span class="hljs-string">'binaryStringToNumber'</span>, () =&gt; {
  describe(<span class="hljs-string">'given an invalid binary string'</span>, () =&gt; {
    test(<span class="hljs-string">'composed of non-numbers throws CustomError'</span>, () =&gt; {
      expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> binaryStringToNumber(<span class="hljs-string">'abc'</span>)).toThrowError(CustomError);
    });

    test(<span class="hljs-string">'with extra whitespace throws CustomError'</span>, () =&gt; {
      expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> binaryStringToNumber(<span class="hljs-string">'  100'</span>)).toThrowError(CustomError);
    });
  });

  describe(<span class="hljs-string">'given a valid binary string'</span>, () =&gt; {
    test(<span class="hljs-string">'returns the correct number'</span>, () =&gt; {
      expect(binaryStringToNumber(<span class="hljs-string">'100'</span>)).toBe(<span class="hljs-number">4</span>);
    });
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="describeeachtablename-fn-timeout"></a><a href="#describeeachtablename-fn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe.each(table)(name, fn, timeout)</code></h3>
<p>Use <code>describe.each</code> if you keep duplicating the same test suites with different data. <code>describe.each</code> allows you to write the test suite once and pass data in.</p>
<p><code>describe.each</code> is available with two APIs:</p>
<h4><a class="anchor" aria-hidden="true" id="1-describeeachtablename-fn-timeout"></a><a href="#1-describeeachtablename-fn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. <code>describe.each(table)(name, fn, timeout)</code></h4>
<ul>
<li><code>table</code>: <code>Array</code> of Arrays with the arguments that are passed into the <code>fn</code> for each row.
<ul>
<li><em>Note</em> If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. <code>[1, 2, 3] -&gt; [[1], [2], [3]]</code></li>
</ul></li>
<li><code>name</code>: <code>String</code> the title of the test suite.
<ul>
<li>Generate unique test titles by positionally injecting parameters with <a href="https://nodejs.org/api/util.html#util_util_format_format_args"><code>printf</code> formatting</a>:
<ul>
<li><code>%p</code> - <a href="https://www.npmjs.com/package/pretty-format">pretty-format</a>.</li>
<li><code>%s</code>- String.</li>
<li><code>%d</code>- Number.</li>
<li><code>%i</code> - Integer.</li>
<li><code>%f</code> - Floating point value.</li>
<li><code>%j</code> - JSON.</li>
<li><code>%o</code> - Object.</li>
<li><code>%#</code> - Index of the test case.</li>
<li><code>%%</code> - single percent sign ('%'). This does not consume an argument.</li>
</ul></li>
</ul></li>
<li><code>fn</code>: <code>Function</code> the suite of tests to be ran, this is the function that will receive the parameters in each row as function arguments.</li>
<li>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait for each row before aborting. <em>Note: The default timeout is 5 seconds.</em></li>
</ul>
<p>Example:</p>
<pre><code class="hljs css language-js">describe.each([
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>],
])(<span class="hljs-string">'.add(%i, %i)'</span>, (a, b, expected) =&gt; {
  test(<span class="hljs-string">`returns <span class="hljs-subst">${expected}</span>`</span>, () =&gt; {
    expect(a + b).toBe(expected);
  });

  test(<span class="hljs-string">`returned value not be greater than <span class="hljs-subst">${expected}</span>`</span>, () =&gt; {
    expect(a + b).not.toBeGreaterThan(expected);
  });

  test(<span class="hljs-string">`returned value not be less than <span class="hljs-subst">${expected}</span>`</span>, () =&gt; {
    expect(a + b).not.toBeLessThan(expected);
  });
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="2--describeeachtablename-fn-timeout-"></a><a href="#2--describeeachtablename-fn-timeout-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. <code>describe.each`table`(name, fn, timeout)</code></h4>
<ul>
<li><code>table</code>: <code>Tagged Template Literal</code>
<ul>
<li>First row of variable name column headings separated with <code>|</code></li>
<li>One or more subsequent rows of data supplied as template literal expressions using <code>${value}</code> syntax.</li>
</ul></li>
<li><code>name</code>: <code>String</code> the title of the test suite, use <code>$variable</code> to inject test data into the suite title from the tagged template expressions.
<ul>
<li>To inject nested object values use you can supply a keyPath i.e. <code>$variable.path.to.value</code></li>
</ul></li>
<li><code>fn</code>: <code>Function</code> the suite of tests to be ran, this is the function that will receive the test data object.</li>
<li>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait for each row before aborting. <em>Note: The default timeout is 5 seconds.</em></li>
</ul>
<p>Example:</p>
<pre><code class="hljs css language-js">describe.each<span class="hljs-string">`
  a    | b    | expected
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
`</span>(<span class="hljs-string">'$a + $b'</span>, ({a, b, expected}) =&gt; {
  test(<span class="hljs-string">`returns <span class="hljs-subst">${expected}</span>`</span>, () =&gt; {
    expect(a + b).toBe(expected);
  });

  test(<span class="hljs-string">`returned value not be greater than <span class="hljs-subst">${expected}</span>`</span>, () =&gt; {
    expect(a + b).not.toBeGreaterThan(expected);
  });

  test(<span class="hljs-string">`returned value not be less than <span class="hljs-subst">${expected}</span>`</span>, () =&gt; {
    expect(a + b).not.toBeLessThan(expected);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="describeonlyname-fn"></a><a href="#describeonlyname-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe.only(name, fn)</code></h3>
<p>Also under the alias: <code>fdescribe(name, fn)</code></p>
<p>You can use <code>describe.only</code> if you want to run only one describe block:</p>
<pre><code class="hljs css language-js">describe.only(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious'</span>, () =&gt; {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test(<span class="hljs-string">'is not sour'</span>, () =&gt; {
    expect(myBeverage.sour).toBeFalsy();
  });
});

describe(<span class="hljs-string">'my other beverage'</span>, () =&gt; {
  <span class="hljs-comment">// ... will be skipped</span>
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="describeonlyeachtablename-fn"></a><a href="#describeonlyeachtablename-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe.only.each(table)(name, fn)</code></h3>
<p>Also under the aliases: <code>fdescribe.each(table)(name, fn)</code> and <code>fdescribe.each`table`(name, fn)</code></p>
<p>Use <code>describe.only.each</code> if you want to only run specific tests suites of data driven tests.</p>
<p><code>describe.only.each</code> is available with two APIs:</p>
<h4><a class="anchor" aria-hidden="true" id="describeonlyeachtablename-fn-1"></a><a href="#describeonlyeachtablename-fn-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe.only.each(table)(name, fn)</code></h4>
<pre><code class="hljs css language-js">describe.only.each([
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>],
])(<span class="hljs-string">'.add(%i, %i)'</span>, (a, b, expected) =&gt; {
  test(<span class="hljs-string">`returns <span class="hljs-subst">${expected}</span>`</span>, () =&gt; {
    expect(a + b).toBe(expected);
  });
});

test(<span class="hljs-string">'will not be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="-describeonlyeachtablename-fn-"></a><a href="#-describeonlyeachtablename-fn-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe.only.each`table`(name, fn)</code></h4>
<pre><code class="hljs css language-js">describe.only.each<span class="hljs-string">`
  a    | b    | expected
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
`</span>(<span class="hljs-string">'returns $expected when $a is added $b'</span>, ({a, b, expected}) =&gt; {
  test(<span class="hljs-string">'passes'</span>, () =&gt; {
    expect(a + b).toBe(expected);
  });
});

test(<span class="hljs-string">'will not be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="describeskipname-fn"></a><a href="#describeskipname-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe.skip(name, fn)</code></h3>
<p>Also under the alias: <code>xdescribe(name, fn)</code></p>
<p>You can use <code>describe.skip</code> if you do not want to run a particular describe block:</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious'</span>, () =&gt; {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test(<span class="hljs-string">'is not sour'</span>, () =&gt; {
    expect(myBeverage.sour).toBeFalsy();
  });
});

describe.skip(<span class="hljs-string">'my other beverage'</span>, () =&gt; {
  <span class="hljs-comment">// ... will be skipped</span>
});
</code></pre>
<p>Using <code>describe.skip</code> is often a cleaner alternative to temporarily commenting out a chunk of tests.</p>
<h3><a class="anchor" aria-hidden="true" id="describeskipeachtablename-fn"></a><a href="#describeskipeachtablename-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe.skip.each(table)(name, fn)</code></h3>
<p>Also under the aliases: <code>xdescribe.each(table)(name, fn)</code> and <code>xdescribe.each`table`(name, fn)</code></p>
<p>Use <code>describe.skip.each</code> if you want to stop running a suite of data driven tests.</p>
<p><code>describe.skip.each</code> is available with two APIs:</p>
<h4><a class="anchor" aria-hidden="true" id="describeskipeachtablename-fn-1"></a><a href="#describeskipeachtablename-fn-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe.skip.each(table)(name, fn)</code></h4>
<pre><code class="hljs css language-js">describe.skip.each([
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>],
])(<span class="hljs-string">'.add(%i, %i)'</span>, (a, b, expected) =&gt; {
  test(<span class="hljs-string">`returns <span class="hljs-subst">${expected}</span>`</span>, () =&gt; {
    expect(a + b).toBe(expected); <span class="hljs-comment">// will not be ran</span>
  });
});

test(<span class="hljs-string">'will be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="-describeskipeachtablename-fn-"></a><a href="#-describeskipeachtablename-fn-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe.skip.each`table`(name, fn)</code></h4>
<pre><code class="hljs css language-js">describe.skip.each<span class="hljs-string">`
  a    | b    | expected
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
`</span>(<span class="hljs-string">'returns $expected when $a is added $b'</span>, ({a, b, expected}) =&gt; {
  test(<span class="hljs-string">'will not be ran'</span>, () =&gt; {
    expect(a + b).toBe(expected); <span class="hljs-comment">// will not be ran</span>
  });
});

test(<span class="hljs-string">'will be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="testname-fn-timeout"></a><a href="#testname-fn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test(name, fn, timeout)</code></h3>
<p>Also under the alias: <code>it(name, fn, timeout)</code></p>
<p>All you need in a test file is the <code>test</code> method which runs a test. For example, let's say there's a function <code>inchesOfRain()</code> that should be zero. Your whole test could be:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'did not rain'</span>, () =&gt; {
  expect(inchesOfRain()).toBe(<span class="hljs-number">0</span>);
});
</code></pre>
<p>The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<blockquote>
<p>Note: If a <strong>promise is returned</strong> from <code>test</code>, Jest will wait for the promise to resolve before letting the test complete. Jest will also wait if you <strong>provide an argument to the test function</strong>, usually called <code>done</code>. This could be handy when you want to test callbacks. See how to test async code <a href="/docs/en/26.4/asynchronous#callbacks">here</a>.</p>
</blockquote>
<p>For example, let's say <code>fetchBeverageList()</code> returns a promise that is supposed to resolve to a list that has <code>lemon</code> in it. You can test this with:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'has lemon in it'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> fetchBeverageList().then(<span class="hljs-function"><span class="hljs-params">list</span> =&gt;</span> {
    expect(list).toContain(<span class="hljs-string">'lemon'</span>);
  });
});
</code></pre>
<p>Even though the call to <code>test</code> will return right away, the test doesn't complete until the promise resolves as well.</p>
<h3><a class="anchor" aria-hidden="true" id="testconcurrentname-fn-timeout"></a><a href="#testconcurrentname-fn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.concurrent(name, fn, timeout)</code></h3>
<p>Also under the alias: <code>it.concurrent(name, fn, timeout)</code></p>
<p>Use <code>test.concurrent</code> if you want the test to run concurrently.</p>
<blockquote>
<p>Note: <code>test.concurrent</code> is considered experimental - see <a href="https://github.com/facebook/jest/labels/Area%3A%20Concurrent">here</a> for details on missing features and other issues</p>
</blockquote>
<p>The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<pre><code class="hljs">test.concurrent('addition of <span class="hljs-number">2</span> numbers', async () =&gt; {
  expect(<span class="hljs-number">5</span> + <span class="hljs-number">3</span>).toBe(<span class="hljs-number">8</span>);
});

test.concurrent('subtraction <span class="hljs-number">2</span> numbers', async () =&gt; {
  expect(<span class="hljs-number">5</span> - <span class="hljs-number">3</span>).toBe(<span class="hljs-number">2</span>);
});
</code></pre>
<blockquote>
<p>Note: Use <code>maxConcurrency</code> in configuration to prevents Jest from executing more than the specified amount of tests at the same time</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="testconcurrenteachtablename-fn-timeout"></a><a href="#testconcurrenteachtablename-fn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.concurrent.each(table)(name, fn, timeout)</code></h3>
<p>Also under the alias: <code>it.concurrent.each(table)(name, fn, timeout)</code></p>
<p>Use <code>test.concurrent.each</code> if you keep duplicating the same test with different data. <code>test.each</code> allows you to write the test once and pass data in, the tests are all run asynchronously.</p>
<p><code>test.concurrent.each</code> is available with two APIs:</p>
<h4><a class="anchor" aria-hidden="true" id="1-testconcurrenteachtablename-fn-timeout"></a><a href="#1-testconcurrenteachtablename-fn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. <code>test.concurrent.each(table)(name, fn, timeout)</code></h4>
<ul>
<li><code>table</code>: <code>Array</code> of Arrays with the arguments that are passed into the test <code>fn</code> for each row.
<ul>
<li><em>Note</em> If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. <code>[1, 2, 3] -&gt; [[1], [2], [3]]</code></li>
</ul></li>
<li><code>name</code>: <code>String</code> the title of the test block.
<ul>
<li>Generate unique test titles by positionally injecting parameters with <a href="https://nodejs.org/api/util.html#util_util_format_format_args"><code>printf</code> formatting</a>:
<ul>
<li><code>%p</code> - <a href="https://www.npmjs.com/package/pretty-format">pretty-format</a>.</li>
<li><code>%s</code>- String.</li>
<li><code>%d</code>- Number.</li>
<li><code>%i</code> - Integer.</li>
<li><code>%f</code> - Floating point value.</li>
<li><code>%j</code> - JSON.</li>
<li><code>%o</code> - Object.</li>
<li><code>%#</code> - Index of the test case.</li>
<li><code>%%</code> - single percent sign ('%'). This does not consume an argument.</li>
</ul></li>
</ul></li>
<li><code>fn</code>: <code>Function</code> the test to be ran, this is the function that will receive the parameters in each row as function arguments, <strong>this will have to be an asynchronous function</strong>.</li>
<li>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait for each row before aborting. <em>Note: The default timeout is 5 seconds.</em></li>
</ul>
<p>Example:</p>
<pre><code class="hljs css language-js">test.concurrent.each([
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>],
])(<span class="hljs-string">'.add(%i, %i)'</span>, (a, b, expected) =&gt; {
  expect(a + b).toBe(expected);
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="2--testconcurrenteachtablename-fn-timeout-"></a><a href="#2--testconcurrenteachtablename-fn-timeout-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. <code>test.concurrent.each`table`(name, fn, timeout)</code></h4>
<ul>
<li><code>table</code>: <code>Tagged Template Literal</code>
<ul>
<li>First row of variable name column headings separated with <code>|</code></li>
<li>One or more subsequent rows of data supplied as template literal expressions using <code>${value}</code> syntax.</li>
</ul></li>
<li><code>name</code>: <code>String</code> the title of the test, use <code>$variable</code> to inject test data into the test title from the tagged template expressions.
<ul>
<li>To inject nested object values use you can supply a keyPath i.e. <code>$variable.path.to.value</code></li>
</ul></li>
<li><code>fn</code>: <code>Function</code> the test to be ran, this is the function that will receive the test data object, <strong>this will have to be an asynchronous function</strong>.</li>
<li>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait for each row before aborting. <em>Note: The default timeout is 5 seconds.</em></li>
</ul>
<p>Example:</p>
<pre><code class="hljs css language-js">test.concurrent.each<span class="hljs-string">`
  a    | b    | expected
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
`</span>(<span class="hljs-string">'returns $expected when $a is added $b'</span>, ({a, b, expected}) =&gt; {
  expect(a + b).toBe(expected);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="testconcurrentonlyeachtablename-fn"></a><a href="#testconcurrentonlyeachtablename-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.concurrent.only.each(table)(name, fn)</code></h3>
<p>Also under the alias: <code>it.concurrent.only.each(table)(name, fn)</code></p>
<p>Use <code>test.concurrent.only.each</code> if you want to only run specific tests with different test data concurrently.</p>
<p><code>test.concurrent.only.each</code> is available with two APIs:</p>
<h4><a class="anchor" aria-hidden="true" id="testconcurrentonlyeachtablename-fn-1"></a><a href="#testconcurrentonlyeachtablename-fn-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.concurrent.only.each(table)(name, fn)</code></h4>
<pre><code class="hljs css language-js">test.concurrent.only.each([
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>],
])(<span class="hljs-string">'.add(%i, %i)'</span>, <span class="hljs-keyword">async</span> (a, b, expected) =&gt; {
  expect(a + b).toBe(expected);
});

test(<span class="hljs-string">'will not be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="-testonlyeachtablename-fn-"></a><a href="#-testonlyeachtablename-fn-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.only.each`table`(name, fn)</code></h4>
<pre><code class="hljs css language-js">test.concurrent.only.each<span class="hljs-string">`
  a    | b    | expected
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
`</span>(<span class="hljs-string">'returns $expected when $a is added $b'</span>, <span class="hljs-keyword">async</span> ({a, b, expected}) =&gt; {
  expect(a + b).toBe(expected);
});

test(<span class="hljs-string">'will not be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="testconcurrentskipeachtablename-fn"></a><a href="#testconcurrentskipeachtablename-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.concurrent.skip.each(table)(name, fn)</code></h3>
<p>Also under the alias: <code>it.concurrent.skip.each(table)(name, fn)</code></p>
<p>Use <code>test.concurrent.skip.each</code> if you want to stop running a collection of asynchronous data driven tests.</p>
<p><code>test.concurrent.skip.each</code> is available with two APIs:</p>
<h4><a class="anchor" aria-hidden="true" id="testconcurrentskipeachtablename-fn-1"></a><a href="#testconcurrentskipeachtablename-fn-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.concurrent.skip.each(table)(name, fn)</code></h4>
<pre><code class="hljs css language-js">test.concurrent.skip.each([
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>],
])(<span class="hljs-string">'.add(%i, %i)'</span>, <span class="hljs-keyword">async</span> (a, b, expected) =&gt; {
  expect(a + b).toBe(expected); <span class="hljs-comment">// will not be ran</span>
});

test(<span class="hljs-string">'will be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="-testconcurrentskipeachtablename-fn-"></a><a href="#-testconcurrentskipeachtablename-fn-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.concurrent.skip.each`table`(name, fn)</code></h4>
<pre><code class="hljs css language-js">test.concurrent.skip.each<span class="hljs-string">`
  a    | b    | expected
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
`</span>(<span class="hljs-string">'returns $expected when $a is added $b'</span>, <span class="hljs-keyword">async</span> ({a, b, expected}) =&gt; {
  expect(a + b).toBe(expected); <span class="hljs-comment">// will not be ran</span>
});

test(<span class="hljs-string">'will be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="testeachtablename-fn-timeout"></a><a href="#testeachtablename-fn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.each(table)(name, fn, timeout)</code></h3>
<p>Also under the alias: <code>it.each(table)(name, fn)</code> and <code>it.each`table`(name, fn)</code></p>
<p>Use <code>test.each</code> if you keep duplicating the same test with different data. <code>test.each</code> allows you to write the test once and pass data in.</p>
<p><code>test.each</code> is available with two APIs:</p>
<h4><a class="anchor" aria-hidden="true" id="1-testeachtablename-fn-timeout"></a><a href="#1-testeachtablename-fn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. <code>test.each(table)(name, fn, timeout)</code></h4>
<ul>
<li><code>table</code>: <code>Array</code> of Arrays with the arguments that are passed into the test <code>fn</code> for each row.
<ul>
<li><em>Note</em> If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. <code>[1, 2, 3] -&gt; [[1], [2], [3]]</code></li>
</ul></li>
<li><code>name</code>: <code>String</code> the title of the test block.
<ul>
<li>Generate unique test titles by positionally injecting parameters with <a href="https://nodejs.org/api/util.html#util_util_format_format_args"><code>printf</code> formatting</a>:
<ul>
<li><code>%p</code> - <a href="https://www.npmjs.com/package/pretty-format">pretty-format</a>.</li>
<li><code>%s</code>- String.</li>
<li><code>%d</code>- Number.</li>
<li><code>%i</code> - Integer.</li>
<li><code>%f</code> - Floating point value.</li>
<li><code>%j</code> - JSON.</li>
<li><code>%o</code> - Object.</li>
<li><code>%#</code> - Index of the test case.</li>
<li><code>%%</code> - single percent sign ('%'). This does not consume an argument.</li>
</ul></li>
</ul></li>
<li><code>fn</code>: <code>Function</code> the test to be ran, this is the function that will receive the parameters in each row as function arguments.</li>
<li>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait for each row before aborting. <em>Note: The default timeout is 5 seconds.</em></li>
</ul>
<p>Example:</p>
<pre><code class="hljs css language-js">test.each([
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>],
])(<span class="hljs-string">'.add(%i, %i)'</span>, (a, b, expected) =&gt; {
  expect(a + b).toBe(expected);
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="2--testeachtablename-fn-timeout-"></a><a href="#2--testeachtablename-fn-timeout-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. <code>test.each`table`(name, fn, timeout)</code></h4>
<ul>
<li><code>table</code>: <code>Tagged Template Literal</code>
<ul>
<li>First row of variable name column headings separated with <code>|</code></li>
<li>One or more subsequent rows of data supplied as template literal expressions using <code>${value}</code> syntax.</li>
</ul></li>
<li><code>name</code>: <code>String</code> the title of the test, use <code>$variable</code> to inject test data into the test title from the tagged template expressions.
<ul>
<li>To inject nested object values use you can supply a keyPath i.e. <code>$variable.path.to.value</code></li>
</ul></li>
<li><code>fn</code>: <code>Function</code> the test to be ran, this is the function that will receive the test data object.</li>
<li>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait for each row before aborting. <em>Note: The default timeout is 5 seconds.</em></li>
</ul>
<p>Example:</p>
<pre><code class="hljs css language-js">test.each<span class="hljs-string">`
  a    | b    | expected
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
`</span>(<span class="hljs-string">'returns $expected when $a is added $b'</span>, ({a, b, expected}) =&gt; {
  expect(a + b).toBe(expected);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="testonlyname-fn-timeout"></a><a href="#testonlyname-fn-timeout" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.only(name, fn, timeout)</code></h3>
<p>Also under the aliases: <code>it.only(name, fn, timeout)</code>, and <code>fit(name, fn, timeout)</code></p>
<p>When you are debugging a large test file, you will often only want to run a subset of tests. You can use <code>.only</code> to specify which tests are the only ones you want to run in that test file.</p>
<p>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<p>For example, let's say you had these tests:</p>
<pre><code class="hljs css language-js">test.only(<span class="hljs-string">'it is raining'</span>, () =&gt; {
  expect(inchesOfRain()).toBeGreaterThan(<span class="hljs-number">0</span>);
});

test(<span class="hljs-string">'it is not snowing'</span>, () =&gt; {
  expect(inchesOfSnow()).toBe(<span class="hljs-number">0</span>);
});
</code></pre>
<p>Only the &quot;it is raining&quot; test will run in that test file, since it is run with <code>test.only</code>.</p>
<p>Usually you wouldn't check code using <code>test.only</code> into source control - you would use it for debugging, and remove it once you have fixed the broken tests.</p>
<h3><a class="anchor" aria-hidden="true" id="testonlyeachtablename-fn"></a><a href="#testonlyeachtablename-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.only.each(table)(name, fn)</code></h3>
<p>Also under the aliases: <code>it.only.each(table)(name, fn)</code>, <code>fit.each(table)(name, fn)</code>, <code>it.only.each`table`(name, fn)</code> and <code>fit.each`table`(name, fn)</code></p>
<p>Use <code>test.only.each</code> if you want to only run specific tests with different test data.</p>
<p><code>test.only.each</code> is available with two APIs:</p>
<h4><a class="anchor" aria-hidden="true" id="testonlyeachtablename-fn-1"></a><a href="#testonlyeachtablename-fn-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.only.each(table)(name, fn)</code></h4>
<pre><code class="hljs css language-js">test.only.each([
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>],
])(<span class="hljs-string">'.add(%i, %i)'</span>, (a, b, expected) =&gt; {
  expect(a + b).toBe(expected);
});

test(<span class="hljs-string">'will not be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="-testonlyeachtablename-fn--1"></a><a href="#-testonlyeachtablename-fn--1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.only.each`table`(name, fn)</code></h4>
<pre><code class="hljs css language-js">test.only.each<span class="hljs-string">`
  a    | b    | expected
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
`</span>(<span class="hljs-string">'returns $expected when $a is added $b'</span>, ({a, b, expected}) =&gt; {
  expect(a + b).toBe(expected);
});

test(<span class="hljs-string">'will not be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="testskipname-fn"></a><a href="#testskipname-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.skip(name, fn)</code></h3>
<p>Also under the aliases: <code>it.skip(name, fn)</code>, <code>xit(name, fn)</code>, and <code>xtest(name, fn)</code></p>
<p>When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use <code>test.skip</code> to specify some tests to skip.</p>
<p>For example, let's say you had these tests:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'it is raining'</span>, () =&gt; {
  expect(inchesOfRain()).toBeGreaterThan(<span class="hljs-number">0</span>);
});

test.skip(<span class="hljs-string">'it is not snowing'</span>, () =&gt; {
  expect(inchesOfSnow()).toBe(<span class="hljs-number">0</span>);
});
</code></pre>
<p>Only the &quot;it is raining&quot; test will run, since the other test is run with <code>test.skip</code>.</p>
<p>You could comment the test out, but it's often a bit nicer to use <code>test.skip</code> because it will maintain indentation and syntax highlighting.</p>
<h3><a class="anchor" aria-hidden="true" id="testskipeachtablename-fn"></a><a href="#testskipeachtablename-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.skip.each(table)(name, fn)</code></h3>
<p>Also under the aliases: <code>it.skip.each(table)(name, fn)</code>, <code>xit.each(table)(name, fn)</code>, <code>xtest.each(table)(name, fn)</code>, <code>it.skip.each`table`(name, fn)</code>, <code>xit.each`table`(name, fn)</code> and <code>xtest.each`table`(name, fn)</code></p>
<p>Use <code>test.skip.each</code> if you want to stop running a collection of data driven tests.</p>
<p><code>test.skip.each</code> is available with two APIs:</p>
<h4><a class="anchor" aria-hidden="true" id="testskipeachtablename-fn-1"></a><a href="#testskipeachtablename-fn-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.skip.each(table)(name, fn)</code></h4>
<pre><code class="hljs css language-js">test.skip.each([
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>],
])(<span class="hljs-string">'.add(%i, %i)'</span>, (a, b, expected) =&gt; {
  expect(a + b).toBe(expected); <span class="hljs-comment">// will not be ran</span>
});

test(<span class="hljs-string">'will be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="-testskipeachtablename-fn-"></a><a href="#-testskipeachtablename-fn-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.skip.each`table`(name, fn)</code></h4>
<pre><code class="hljs css language-js">test.skip.each<span class="hljs-string">`
  a    | b    | expected
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
  <span class="hljs-subst">${<span class="hljs-number">2</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">1</span>}</span> | <span class="hljs-subst">${<span class="hljs-number">3</span>}</span>
`</span>(<span class="hljs-string">'returns $expected when $a is added $b'</span>, ({a, b, expected}) =&gt; {
  expect(a + b).toBe(expected); <span class="hljs-comment">// will not be ran</span>
});

test(<span class="hljs-string">'will be ran'</span>, () =&gt; {
  expect(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>).toBe(<span class="hljs-literal">Infinity</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="testtodoname"></a><a href="#testtodoname" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.todo(name)</code></h3>
<p>Also under the alias: <code>it.todo(name)</code></p>
<p>Use <code>test.todo</code> when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.</p>
<p><em>Note</em>: If you supply a test callback function then the <code>test.todo</code> will throw an error. If you have already implemented the test and it is broken and you do not want it to run, then use <code>test.skip</code> instead.</p>
<h4><a class="anchor" aria-hidden="true" id="api"></a><a href="#api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>API</h4>
<ul>
<li><code>name</code>: <code>String</code> the title of the test plan.</li>
</ul>
<p>Example:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;

test.todo(<span class="hljs-string">'add should be associative'</span>);
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/en/26.4/testing-frameworks"><span class="arrow-prev">← </span><span>Testing Web Frameworks</span></a><a class="docs-next button" href="/docs/en/26.4/expect"><span>Expect</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#methods">Methods</a></li><li><a href="#reference">Reference</a><ul class="toc-headings"><li><a href="#afterallfn-timeout"><code>afterAll(fn, timeout)</code></a></li><li><a href="#aftereachfn-timeout"><code>afterEach(fn, timeout)</code></a></li><li><a href="#beforeallfn-timeout"><code>beforeAll(fn, timeout)</code></a></li><li><a href="#beforeeachfn-timeout"><code>beforeEach(fn, timeout)</code></a></li><li><a href="#describename-fn"><code>describe(name, fn)</code></a></li><li><a href="#describeeachtablename-fn-timeout"><code>describe.each(table)(name, fn, timeout)</code></a></li><li><a href="#describeonlyname-fn"><code>describe.only(name, fn)</code></a></li><li><a href="#describeonlyeachtablename-fn"><code>describe.only.each(table)(name, fn)</code></a></li><li><a href="#describeskipname-fn"><code>describe.skip(name, fn)</code></a></li><li><a href="#describeskipeachtablename-fn"><code>describe.skip.each(table)(name, fn)</code></a></li><li><a href="#testname-fn-timeout"><code>test(name, fn, timeout)</code></a></li><li><a href="#testconcurrentname-fn-timeout"><code>test.concurrent(name, fn, timeout)</code></a></li><li><a href="#testconcurrenteachtablename-fn-timeout"><code>test.concurrent.each(table)(name, fn, timeout)</code></a></li><li><a href="#testconcurrentonlyeachtablename-fn"><code>test.concurrent.only.each(table)(name, fn)</code></a></li><li><a href="#testconcurrentskipeachtablename-fn"><code>test.concurrent.skip.each(table)(name, fn)</code></a></li><li><a href="#testeachtablename-fn-timeout"><code>test.each(table)(name, fn, timeout)</code></a></li><li><a href="#testonlyname-fn-timeout"><code>test.only(name, fn, timeout)</code></a></li><li><a href="#testonlyeachtablename-fn"><code>test.only.each(table)(name, fn)</code></a></li><li><a href="#testskipname-fn"><code>test.skip(name, fn)</code></a></li><li><a href="#testskipeachtablename-fn"><code>test.skip.each(table)(name, fn)</code></a></li><li><a href="#testtodoname"><code>test.todo(name)</code></a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/getting-started.html">Getting Started</a><a href="/docs/en/snapshot-testing.html">Guides</a><a href="/docs/en/api.html">API Reference</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://www.reactiflux.com/">Reactiflux</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star facebook/jest on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2020 Facebook Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:en","version:26.4"]}
              });
            </script></body></html>