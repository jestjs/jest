<!DOCTYPE html><html lang="es-ES"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Globals · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="In your test files, Jest puts each of these methods and objects into the global environment. You don&#x27;t have to require or import anything to use them."/><meta name="docsearch:version" content="22.x"/><meta name="docsearch:language" content="es-ES"/><meta property="og:title" content="Globals · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jestjs.io/"/><meta property="og:description" content="In your test files, Jest puts each of these methods and objects into the global environment. You don&#x27;t have to require or import anything to use them."/><meta property="og:image" content="https://jestjs.io/img/opengraph.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://jestjs.io/img/jest.png"/><link rel="shortcut icon" href="/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://jestjs.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://jestjs.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/es-ES"><img class="logo" src="/img/jest.svg" alt="Jest"/><h2 class="headerTitleWithLogo">Jest</h2></a><a href="/es-ES/versions"><h3>22.x</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/es-ES/22.x/getting-started" target="_self">Documentación</a></li><li class="siteNavGroupActive siteNavItemActive"><a href="/docs/es-ES/22.x/api" target="_self">API</a></li><li class=""><a href="/es-ES/help" target="_self">Ayuda</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Español</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/22.x/api">English</a></li><li><a href="/docs/ja/22.x/api">日本語</a></li><li><a href="/docs/pt-BR/22.x/api">Português (Brasil)</a></li><li><a href="/docs/ro/22.x/api">Română</a></li><li><a href="/docs/ru/22.x/api">Русский</a></li><li><a href="/docs/uk/22.x/api">Українська</a></li><li><a href="/docs/zh-Hans/22.x/api">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>API Reference</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/getting-started">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/using-matchers">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/asynchronous">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/setup-teardown">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/mock-functions">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/jest-platform">Jest Platform</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/jest-community">Jest Community</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/more-resources">More Resources</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/snapshot-testing">Snapshot Testing</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/tutorial-async">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/timer-mocks">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/manual-mocks">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/es6-class-mocks">ES6 Class Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/bypassing-module-mocks">Bypassing module mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/webpack">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/puppeteer">Using with puppeteer</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/mongodb">Using with MongoDB</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/dynamodb">Using with DynamoDB</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/tutorial-jquery">DOM Manipulation</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/migration-guide">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/architecture">Architecture</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Framework Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/tutorial-react">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/tutorial-react-native">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/testing-frameworks">Testing Web Frameworks</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API Reference</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/es-ES/22.x/api">Globals</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/expect">Expect</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/mock-function-api">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/jest-object">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/configuration">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/cli">Jest CLI Options</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/22.x/environment-variables">Environment Variables</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/jest/edit/master/docs/GlobalAPI.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Globals</h1></header><article><div><span><p>In your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them.</p>
<h2><a class="anchor" aria-hidden="true" id="métodos"></a><a href="#métodos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Métodos</h2>
<ul>
<li><a href="#después-de-todo-fn-tiempo"><code>después de todo (fn, tiempo)</code></a></li>
<li><a href="#aftereachfn-tiempo"><code>afterEach(fn, tiempo)</code></a></li>
<li><a href="#beforeallfn-tiempo"><code>beforeAll(fn, tiempo)</code></a></li>
<li><a href="#beforeeachfn-tiempo"><code>beforeEach(fn, tiempo)</code></a></li>
<li><a href="#describename-fn"><code>describe(name, fn)</code></a></li>
<li><a href="#describeonlyname-fn"><code>describe.only(name, fn)</code></a></li>
<li><a href="#describeskipname-fn"><code>describe.skip(name, fn)</code></a></li>
<li><a href="#pruebanombre-fn-tiempo"><code>prueba(nombre, fn, tiempo)</code></a></li>
<li><a href="#pruebasoloname-fn-tiempo"><code>prueba.solo(name, fn, tiempo)</code></a></li>
<li><a href="#testskipname-fn"><code>test.skip(name, fn)</code></a></li>
</ul>
<hr>
<h2><a class="anchor" aria-hidden="true" id="referencia"></a><a href="#referencia" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Referencia</h2>
<h3><a class="anchor" aria-hidden="true" id="después-de-todo-fn-tiempo"></a><a href="#después-de-todo-fn-tiempo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>después de todo (fn, tiempo)</code></h3>
<p>Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</p>
<p>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<p>Esto es frecuentemente útil para restablecer el estado global compartido entre pruebas.</p>
<p>Por ejemplo:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanUpDatabase</span>(<span class="hljs-params">db</span>) </span>{
  db.cleanUp();
}

afterAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cleanUpDatabase(globalDatabase);
});

test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});

test(<span class="hljs-string">'can insert a thing'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.insert(<span class="hljs-string">'thing'</span>, makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<p>La función <code>afterAll</code> garantiza que el método <code>cleanUpDatabase</code> sea llamado una vez terminada la ejecución de pruebas.</p>
<p>Si <code>afterAll</code> es llamado dentro de un bloque <code>describe</code>, este se ejecutará al final de la ejecución del bloque describe.</p>
<p>Si se desea ejecutar algún tipo de limpieza o restablecimiento después de cada prueba en lugar de al final de todas las pruebas, se puede utilizar <code>afterEach</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="aftereachfn-tiempo"></a><a href="#aftereachfn-tiempo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>afterEach(fn, tiempo)</code></h3>
<p>Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</p>
<p>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<p>Esto es frecuentemente útil para restablecer algún estado temporal que sea creado por cada prueba.</p>
<p>Por ejemplo:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanUpDatabase</span>(<span class="hljs-params">db</span>) </span>{
  db.cleanUp();
}

afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cleanUpDatabase(globalDatabase);
});

test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});

test(<span class="hljs-string">'can insert a thing'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.insert(<span class="hljs-string">'thing'</span>, makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<p>La función <code>afterAll</code> garantiza que el método <code>cleanUpDatabase</code> sea llamado una vez terminada cada prueba.</p>
<p>Si <code>afterAll</code> es llamado dentro de un bloque <code>describe</code>, este se ejecutará al final de la ejecución de cada prueba en el bloque describe.</p>
<p>Si se desea ejecutar algún tipo de limpieza o restablecimiento una sola vez por todas las pruebas, se puede utilizar <code>afterAll</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="beforeallfn-tiempo"></a><a href="#beforeallfn-tiempo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>beforeAll(fn, tiempo)</code></h3>
<p>Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.</p>
<p>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<p>Esto es frecuentemente útil para establecer algún estado global a ser ocupado por varias pruebas.</p>
<p>Por ejemplo:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Clears the database and adds some testing data.</span>
  <span class="hljs-comment">// Jest will wait for this promise to resolve before running tests.</span>
  <span class="hljs-keyword">return</span> globalDatabase.clear().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> globalDatabase.insert({<span class="hljs-attr">testData</span>: <span class="hljs-string">'foo'</span>});
  });
});

<span class="hljs-comment">// Since we only set up the database once in this example, it's important</span>
<span class="hljs-comment">// that our tests don't modify it.</span>
test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});
</code></pre>
<p>Aquí el bloque <code>beforeAll</code> garantiza que la base de datos sea configurada antes de que se ejecuten las pruebas. If setup was synchronous, you could do this without <code>beforeAll</code>. La clave es que Jest espera a una promise para resolver, de modo que también se puede tener configuración inicial setup asincrona.</p>
<p>Si el bloque <code>beforeAll</code> se encuentra dentro de un bloque <code>describe</code>, esté se ejecutará al principio del bloque describe.</p>
<p>Si se desea ejecutar código antes de cada prueba en lugar de antes de todas las pruebas, se puede usar <code>beforeEach</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="beforeeachfn-tiempo"></a><a href="#beforeeachfn-tiempo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>beforeEach(fn, tiempo)</code></h3>
<p>Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.</p>
<p>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<p>Esto es frecuentemente útil para restablecer algún estado global a ser ocupado por varias pruebas.</p>
<p>Por ejemplo:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> globalDatabase = makeGlobalDatabase();

beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Clears the database and adds some testing data.</span>
  <span class="hljs-comment">// Jest will wait for this promise to resolve before running tests.</span>
  <span class="hljs-keyword">return</span> globalDatabase.clear().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> globalDatabase.insert({<span class="hljs-attr">testData</span>: <span class="hljs-string">'foo'</span>});
  });
});

test(<span class="hljs-string">'can find things'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.find(<span class="hljs-string">'thing'</span>, {}, results =&gt; {
    expect(results.length).toBeGreaterThan(<span class="hljs-number">0</span>);
  });
});

test(<span class="hljs-string">'can insert a thing'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> globalDatabase.insert(<span class="hljs-string">'thing'</span>, makeThing(), response =&gt; {
    expect(response.success).toBeTruthy();
  });
});
</code></pre>
<p>Aquí el bloque <code>beforeAll</code> garantiza que la base de datos se restablezca antes de cada prueba.</p>
<p>Si el bloque <code>beforeAll</code> se encuentra dentro de un bloque <code>describe</code>, esté se ejecutará una vez antes de cada prueba en el bloque describe.</p>
<p>Si se desea ejecutar código de configuración inicial, una sola vez antes de cualquier prueba, usesé <code>beforeAll</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="describename-fn"></a><a href="#describename-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe(name, fn)</code></h3>
<p><code>describe(name, fn)</code> creates a block that groups together several related tests. Por ejemplo, si se tiene una objeto <code>myBeverage</code> que representa una bebida que debe ser deliciosa pero no agria, se podría probar con:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> myBeverage = {
  <span class="hljs-attr">delicious</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">sour</span>: <span class="hljs-literal">false</span>,
};

describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious'</span>, () =&gt; {
    expect(myBeverage.delicious).toBeTruthy();
  });

  test(<span class="hljs-string">'is not sour'</span>, () =&gt; {
    expect(myBeverage.sour).toBeFalsy();
  });
});
</code></pre>
<p>This isn't required - you can write the <code>test</code> blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.</p>
<p>También se pueden anidar bloques <code>describe</code> si se tiene una jerarquía de pruebas:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> cadenaBinariaANumero = <span class="hljs-function"><span class="hljs-params">cadenaBinaria</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^[01]+$/</span>.test(cadenaBinaria)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomError(<span class="hljs-string">'No es un número binario.'</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(cadenaBinaria, <span class="hljs-number">2</span>);
};

describe(<span class="hljs-string">'cadenaBinariaANumero'</span>, () =&gt; {
  describe(<span class="hljs-string">'dada una cadena binaria invalida'</span>, () =&gt; {
    test(<span class="hljs-string">'compuesta de no-números arroja un CustomError'</span>, () =&gt; {
      expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> cadenaBinariaANumero(<span class="hljs-string">'abc'</span>)).toThrowError(CustomError);
    });

    test(<span class="hljs-string">'con espacios en blanco extra arroja un CustomError'</span>, () =&gt; {
      expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> cadenaBinariaANumero(<span class="hljs-string">'  100'</span>)).toThrowError(CustomError);
    });
  });

  describe(<span class="hljs-string">'dada una cadena binaria valida'</span>, () =&gt; {
    test(<span class="hljs-string">'regresa el número correcto'</span>, () =&gt; {
      expect(cadenaBinariaANumero(<span class="hljs-string">'100'</span>)).toBe(<span class="hljs-number">4</span>);
    });
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="describeonlyname-fn"></a><a href="#describeonlyname-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe.only(name, fn)</code></h3>
<p>Se puede encontrar también debajo del alias: <code>fdescribe(name, fn)</code></p>
<p>Se puede utilizar <code>describe.only</code> si se desea ejecutar solo ún bloque describe:</p>
<pre><code class="hljs css language-js">describe.only(<span class="hljs-string">'mi bebida'</span>, () =&gt; {
  test(<span class="hljs-string">'es deliciosa'</span>, () =&gt; {
    expect(miBebida.deliciosa).toBeTruthy();
  });

  test(<span class="hljs-string">'no es amarga'</span>, () =&gt; {
    expect(miBebida.amarga).toBeFalsy();
  });
});

describe(<span class="hljs-string">'mi otra bebida'</span>, () =&gt; {
  <span class="hljs-comment">// ... will be skipped</span>
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="describeskipname-fn"></a><a href="#describeskipname-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>describe.skip(name, fn)</code></h3>
<p>Se puede encontrar también debajo del alias: <code>xdescribe(name, fn)</code></p>
<p>Se puede utilizar <code>describe.skip</code> si se desea omitirun bloque describe en particular:</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'mi bebida'</span>, () =&gt; {
  test(<span class="hljs-string">'es deliciosa'</span>, () =&gt; {
    expect(miBebida.deliciosa).toBeTruthy();
  });

  test(<span class="hljs-string">'no es amarga'</span>, () =&gt; {
    expect(miBebida.amarga).toBeFalsy();
  });
});

describe.skip(<span class="hljs-string">'mi otra bebida'</span>, () =&gt; {
  <span class="hljs-comment">// ... will be skipped</span>
});
</code></pre>
<p>Using <code>describe.skip</code> is often a cleaner alternative to temporarily commenting out a chunk of tests.</p>
<h3><a class="anchor" aria-hidden="true" id="pruebanombre-fn-tiempo"></a><a href="#pruebanombre-fn-tiempo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>prueba(nombre, fn, tiempo)</code></h3>
<p>También con el alias: <code>it(name, fn, tiempo)</code></p>
<p>All you need in a test file is the <code>test</code> method which runs a test. For example, let's say there's a function <code>inchesOfRain()</code> that should be zero. Your whole test could be:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'did not rain'</span>, () =&gt; {
  expect(inchesOfRain()).toBe(<span class="hljs-number">0</span>);
});
</code></pre>
<p>El primer argumento es el nombre de la prueba, el segundo argumento es una función con el codigo de expectativas a ser probadas. The third argument (optional) is <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<blockquote>
<p>Note: If a <strong>promise is returned</strong> from <code>test</code>, Jest will wait for the promise to resolve before letting the test complete. Jest will also wait if you <strong>provide an argument to the test function</strong>, usually called <code>done</code>. This could be handy when you want to test callbacks. See how to test async code <a href="/docs/es-ES/22.x/asynchronous#callbacks">here</a>.</p>
</blockquote>
<p>For example, let's say <code>fetchBeverageList()</code> returns a promise that is supposed to resolve to a list that has <code>lemon</code> in it. Podemos probarlo con:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'has lemon in it'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> fetchBeverageList().then(<span class="hljs-function"><span class="hljs-params">list</span> =&gt;</span> {
    expect(list).toContain(<span class="hljs-string">'lemon'</span>);
  });
});
</code></pre>
<p>Aunque la llamada al <code>test</code> terminará inmediatamente, la prueba no será completada hasta que resuelva el promise.</p>
<h3><a class="anchor" aria-hidden="true" id="pruebasoloname-fn-tiempo"></a><a href="#pruebasoloname-fn-tiempo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>prueba.solo(name, fn, tiempo)</code></h3>
<p>Also under the aliases: <code>it.only(name, fn, timeout)</code>, and <code>fit(name, fn, timeout)</code></p>
<p>When you are debugging a large test file, you will often only want to run a subset of tests. You can use <code>.only</code> to specify which tests are the only ones you want to run in that test file.</p>
<p>Optionally, you can provide a <code>timeout</code> (in milliseconds) for specifying how long to wait before aborting. <em>Note: The default timeout is 5 seconds.</em></p>
<p>Por ejemplo, digamos que se tuviera estas pruebas:</p>
<pre><code class="hljs css language-js">test.only(<span class="hljs-string">'it is raining'</span>, () =&gt; {
  expect(inchesOfRain()).toBeGreaterThan(<span class="hljs-number">0</span>);
});

test(<span class="hljs-string">'it is not snowing'</span>, () =&gt; {
  expect(inchesOfSnow()).toBe(<span class="hljs-number">0</span>);
});
</code></pre>
<p>Only the &quot;it is raining&quot; test will run in that test file, since it is run with <code>test.only</code>.</p>
<p>Usually you wouldn't check code using <code>test.only</code> into source control - you would use it for debugging, and remove it once you have fixed the broken tests.</p>
<h3><a class="anchor" aria-hidden="true" id="testskipname-fn"></a><a href="#testskipname-fn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>test.skip(name, fn)</code></h3>
<p>Also under the aliases: <code>it.skip(name, fn)</code>, <code>xit(name, fn)</code>, and <code>xtest(name, fn)</code></p>
<p>Cuando se trabaja en una gran base de código, es frecuente encontrar alguna prueba que falla de manera temporal. If you want to skip running this test, but you don't want to delete this code, you can use <code>test.skip</code> to specify some tests to skip.</p>
<p>Por ejemplo, digamos que se tuviera estas pruebas:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'it is raining'</span>, () =&gt; {
  expect(inchesOfRain()).toBeGreaterThan(<span class="hljs-number">0</span>);
});

test.skip(<span class="hljs-string">'it is not snowing'</span>, () =&gt; {
  expect(inchesOfSnow()).toBe(<span class="hljs-number">0</span>);
});
</code></pre>
<p>Sólo se ejecutaría la prueba &quot;it is raning&quot;, pues se agregó <code>test.skip</code> a la otra prueba.</p>
<p>You could comment the test out, but it's often a bit nicer to use <code>test.skip</code> because it will maintain indentation and syntax highlighting.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/es-ES/22.x/testing-frameworks"><span class="arrow-prev">← </span><span>Testing Web Frameworks</span></a><a class="docs-next button" href="/docs/es-ES/22.x/expect"><span>Expect</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#métodos">Métodos</a></li><li><a href="#referencia">Referencia</a><ul class="toc-headings"><li><a href="#después-de-todo-fn-tiempo"><code>después de todo (fn, tiempo)</code></a></li><li><a href="#aftereachfn-tiempo"><code>afterEach(fn, tiempo)</code></a></li><li><a href="#beforeallfn-tiempo"><code>beforeAll(fn, tiempo)</code></a></li><li><a href="#beforeeachfn-tiempo"><code>beforeEach(fn, tiempo)</code></a></li><li><a href="#describename-fn"><code>describe(name, fn)</code></a></li><li><a href="#describeonlyname-fn"><code>describe.only(name, fn)</code></a></li><li><a href="#describeskipname-fn"><code>describe.skip(name, fn)</code></a></li><li><a href="#pruebanombre-fn-tiempo"><code>prueba(nombre, fn, tiempo)</code></a></li><li><a href="#pruebasoloname-fn-tiempo"><code>prueba.solo(name, fn, tiempo)</code></a></li><li><a href="#testskipname-fn"><code>test.skip(name, fn)</code></a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/es-ES/getting-started.html">Getting Started</a><a href="/docs/es-ES/snapshot-testing.html">Guides</a><a href="/docs/es-ES/api.html">API Reference</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discord.gg/j6FKKQQrW9">Reactiflux</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star facebook/jest on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2021 Facebook Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:es-ES","version:22.x"]}
              });
            </script></body></html>