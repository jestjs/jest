<!DOCTYPE html><html lang="ro"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Expect · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="When you&#x27;re writing tests, you often need to check that values meet certain conditions. `expect` gives you access to a number of &quot;matchers&quot; that let you validate different things."/><meta name="docsearch:version" content="26.5"/><meta name="docsearch:language" content="ro"/><meta property="og:title" content="Expect · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jestjs.io/"/><meta property="og:description" content="When you&#x27;re writing tests, you often need to check that values meet certain conditions. `expect` gives you access to a number of &quot;matchers&quot; that let you validate different things."/><meta property="og:image" content="https://jestjs.io/img/opengraph.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://jestjs.io/img/jest.png"/><link rel="shortcut icon" href="/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://jestjs.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://jestjs.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ro"><img class="logo" src="/img/jest.svg" alt="Jest"/><h2 class="headerTitleWithLogo">Jest</h2></a><a href="/ro/versions"><h3>26.5</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ro/26.5/getting-started" target="_self">Documentație</a></li><li class="siteNavGroupActive"><a href="/docs/ro/26.5/api" target="_self">API</a></li><li class=""><a href="/ro/help" target="_self">Ajutor</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Română</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/26.5/expect">English</a></li><li><a href="/docs/ja/26.5/expect">日本語</a></li><li><a href="/docs/es-ES/26.5/expect">Español</a></li><li><a href="/docs/pt-BR/26.5/expect">Português (Brasil)</a></li><li><a href="/docs/ru/26.5/expect">Русский</a></li><li><a href="/docs/uk/26.5/expect">Українська</a></li><li><a href="/docs/zh-Hans/26.5/expect">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>API Reference</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/getting-started">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/using-matchers">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/asynchronous">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/setup-teardown">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/mock-functions">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/jest-platform">Jest Platform</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/jest-community">Jest Community</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/more-resources">More Resources</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/snapshot-testing">Snapshot Testing</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/tutorial-async">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/timer-mocks">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/manual-mocks">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/es6-class-mocks">ES6 Class Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/bypassing-module-mocks">Bypassing module mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/ecmascript-modules">ECMAScript Modules</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/webpack">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/puppeteer">Using with puppeteer</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/mongodb">Using with MongoDB</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/dynamodb">Using with DynamoDB</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/tutorial-jquery">DOM Manipulation</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/watch-plugins">Watch Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/migration-guide">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/architecture">Architecture</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Framework Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/tutorial-react">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/tutorial-react-native">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/testing-frameworks">Testing Web Frameworks</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API Reference</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/api">Globals</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ro/26.5/expect">Expect</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/mock-function-api">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/jest-object">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/configuration">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/cli">Jest CLI Options</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/environment-variables">Environment Variables</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/jest/edit/master/docs/ExpectAPI.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Expect</h1></header><article><div><span><p>When you're writing tests, you often need to check that values meet certain conditions. <code>expect</code> gives you access to a number of &quot;matchers&quot; that let you validate different things.</p>
<p>For additional Jest matchers maintained by the Jest Community check out <a href="https://github.com/jest-community/jest-extended"><code>jest-extended</code></a>.</p>
<h2><a class="anchor" aria-hidden="true" id="metode"></a><a href="#metode" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Metode</h2>
<ul>
<li><a href="#expectvalue"><code>expect(value)</code></a></li>
<li><a href="#expectextendmatchers"><code>expect.extend(matchers)</code></a></li>
<li><a href="#expectanything"><code>expect.anything()</code></a></li>
<li><a href="#expectanyconstructor"><code>expect.any(constructor)</code></a></li>
<li><a href="#expectarraycontainingarray"><code>expect.arrayContaining(array)</code></a></li>
<li><a href="#expectassertionsnumber"><code>expect.assertions(number)</code></a></li>
<li><a href="#expecthasassertions"><code>expect.hasAssertions()</code></a></li>
<li><a href="#expectnotarraycontainingarray"><code>expect.not.arrayContaining(array)</code></a></li>
<li><a href="#expectnotobjectcontainingobject"><code>expect.not.objectContaining(object)</code></a></li>
<li><a href="#expectnotstringcontainingstring"><code>expect.not.stringContaining(string)</code></a></li>
<li><a href="#expectnotstringmatchingstring--regexp"><code>expect.not.stringMatching(string | regexp)</code></a></li>
<li><a href="#expectobjectcontainingobject"><code>expect.objectContaining(object)</code></a></li>
<li><a href="#expectstringcontainingstring"><code>expect.stringContaining(string)</code></a></li>
<li><a href="#expectstringmatchingstring--regexp"><code>expect.stringMatching(string | regexp)</code></a></li>
<li><a href="#expectaddsnapshotserializerserializer"><code>expect.addSnapshotSerializer(serializer)</code></a></li>
<li><a href="#not"><code>.not</code></a></li>
<li><a href="#resolves"><code>.resolves</code></a></li>
<li><a href="#rejects"><code>.rejects</code></a></li>
<li><a href="#tobevalue"><code>.toBe(value)</code></a></li>
<li><a href="#tohavebeencalled"><code>.toHaveBeenCalled()</code></a></li>
<li><a href="#tohavebeencalledtimesnumber"><code>.toHaveBeenCalledTimes(number)</code></a></li>
<li><a href="#tohavebeencalledwitharg1-arg2-"><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code></a></li>
<li><a href="#tohavebeenlastcalledwitharg1-arg2-"><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code></a></li>
<li><a href="#tohavebeennthcalledwithnthcall-arg1-arg2-"><code>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)</code></a></li>
<li><a href="#tohavereturned"><code>.toHaveReturned()</code></a></li>
<li><a href="#tohavereturnedtimesnumber"><code>.toHaveReturnedTimes(number)</code></a></li>
<li><a href="#tohavereturnedwithvalue"><code>.toHaveReturnedWith(value)</code></a></li>
<li><a href="#tohavelastreturnedwithvalue"><code>.toHaveLastReturnedWith(value)</code></a></li>
<li><a href="#tohaventhreturnedwithnthcall-value"><code>.toHaveNthReturnedWith(nthCall, value)</code></a></li>
<li><a href="#tohavelengthnumber"><code>.toHaveLength(number)</code></a></li>
<li><a href="#tohavepropertykeypath-value"><code>.toHaveProperty(keyPath, value?)</code></a></li>
<li><a href="#tobeclosetonumber-numdigits"><code>.toBeCloseTo(number, numDigits?)</code></a></li>
<li><a href="#tobedefined"><code>.toBeDefined()</code></a></li>
<li><a href="#tobefalsy"><code>.toBeFalsy()</code></a></li>
<li><a href="#tobegreaterthannumber--bigint"><code>.toBeGreaterThan(number | bigint)</code></a></li>
<li><a href="#tobegreaterthanorequalnumber--bigint"><code>.toBeGreaterThanOrEqual(number | bigint)</code></a></li>
<li><a href="#tobelessthannumber--bigint"><code>.toBeLessThan(number | bigint)</code></a></li>
<li><a href="#tobelessthanorequalnumber--bigint"><code>.toBeLessThanOrEqual(number | bigint)</code></a></li>
<li><a href="#tobeinstanceofclass"><code>.toBeInstanceOf(Class)</code></a></li>
<li><a href="#tobenull"><code>.toBeNull()</code></a></li>
<li><a href="#tobetruthy"><code>.toBeTruthy()</code></a></li>
<li><a href="#tobeundefined"><code>.toBeUndefined()</code></a></li>
<li><a href="#tobenan"><code>.toBeNaN()</code></a></li>
<li><a href="#tocontainitem"><code>.toContain(item)</code></a></li>
<li><a href="#tocontainequalitem"><code>.toContainEqual(item)</code></a></li>
<li><a href="#toequalvalue"><code>.toEqual(value)</code></a></li>
<li><a href="#tomatchregexporstring"><code>.toMatch(regexpOrString)</code></a></li>
<li><a href="#tomatchobjectobject"><code>.toMatchObject(object)</code></a></li>
<li><a href="#tomatchsnapshotpropertymatchers-hint"><code>.toMatchSnapshot(propertyMatchers?, hint?)</code></a></li>
<li><a href="#tomatchinlinesnapshotpropertymatchers-inlinesnapshot"><code>.toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)</code></a></li>
<li><a href="#tostrictequalvalue"><code>.toStrictEqual(value)</code></a></li>
<li><a href="#tothrowerror"><code>.toThrow(error?)</code></a></li>
<li><a href="#tothrowerrormatchingsnapshothint"><code>.toThrowErrorMatchingSnapshot(hint?)</code></a></li>
<li><a href="#tothrowerrormatchinginlinesnapshotinlinesnapshot"><code>.toThrowErrorMatchingInlineSnapshot(inlineSnapshot)</code></a></li>
</ul>
<hr>
<h2><a class="anchor" aria-hidden="true" id="referințe"></a><a href="#referințe" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Referințe</h2>
<h3><a class="anchor" aria-hidden="true" id="expectvalue"></a><a href="#expectvalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect(value)</code></h3>
<p>Funcţia <code>expect</code> este folosită de fiecare dată când vrei să testezi o valoare. Foarte rar vei apela <code>expect</code> de una singură. Instead, you will use <code>expect</code> along with a &quot;matcher&quot; function to assert something about value.</p>
<p>Este mai uşor de înţeles acest lucru printr-un exemplu. Să presupunem că aveţi o metodă <code>bestLaCroixFlavor()</code> care ar trebui să returneze <code>'grapefruit'</code>. Iată cum ai testa acest lucru:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'the best flavor is grapefruit'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).toBe(<span class="hljs-string">'grapefruit'</span>);
});
</code></pre>
<p>In this case, <code>toBe</code> is the matcher function. There are a lot of different matcher functions, documented below, to help you test different things.</p>
<p>Argumentul funcției <code>expect</code> trebuie să fie valoarea care produce codul şi orice argument pentru funcția comparator ar trebui să fie valoarea corectă. Dacă le amestecați, testele vor funcţiona în continuare, dar mesajele de eroare pentru testele eșuate vor arăta ciudat.</p>
<h3><a class="anchor" aria-hidden="true" id="expectextendmatchers"></a><a href="#expectextendmatchers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.extend(matchers)</code></h3>
<p>Utilizaţi <code>expect.extend</code> pentru a adăuga proprii comparatorii. For example, let's say that you're testing a number utility library and you're frequently asserting that numbers appear within particular ranges of other numbers. You could abstract that into a <code>toBeWithinRange</code> matcher:</p>
<pre><code class="hljs css language-js">expect.extend({
  toBeWithinRange(received, floor, ceiling) {
    <span class="hljs-keyword">const</span> pass = received &gt;= floor &amp;&amp; received &lt;= ceiling;
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> not to be within range <span class="hljs-subst">${floor}</span> - <span class="hljs-subst">${ceiling}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> to be within range <span class="hljs-subst">${floor}</span> - <span class="hljs-subst">${ceiling}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'numeric ranges'</span>, () =&gt; {
  expect(<span class="hljs-number">100</span>).toBeWithinRange(<span class="hljs-number">90</span>, <span class="hljs-number">110</span>);
  expect(<span class="hljs-number">101</span>).not.toBeWithinRange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);
  expect({<span class="hljs-attr">apples</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">bananas</span>: <span class="hljs-number">3</span>}).toEqual({
    <span class="hljs-attr">apples</span>: expect.toBeWithinRange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>),
    <span class="hljs-attr">bananas</span>: expect.not.toBeWithinRange(<span class="hljs-number">11</span>, <span class="hljs-number">20</span>),
  });
});
</code></pre>
<p><em>Note</em>: In TypeScript, when using <code>@types/jest</code> for example, you can declare the new <code>toBeWithinRange</code> matcher like this:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">declare</span> global {
  <span class="hljs-keyword">namespace</span> jest {
    <span class="hljs-keyword">interface</span> Matchers&lt;R&gt; {
      toBeWithinRange(a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span>): R;
    }
  }
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="async-matchers"></a><a href="#async-matchers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Async Matchers</h4>
<p><code>expect.extend</code> also supports async matchers. Async matchers return a Promise so you will need to await the returned value. Let's use an example matcher to illustrate the usage of them. We are going to implement a matcher called <code>toBeDivisibleByExternalValue</code>, where the divisible number is going to be pulled from an external source.</p>
<pre><code class="hljs css language-js">expect.extend({
  <span class="hljs-keyword">async</span> toBeDivisibleByExternalValue(received) {
    <span class="hljs-keyword">const</span> externalValue = <span class="hljs-keyword">await</span> getExternalValueFromRemoteSource();
    <span class="hljs-keyword">const</span> pass = received % externalValue == <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> not to be divisible by <span class="hljs-subst">${externalValue}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> to be divisible by <span class="hljs-subst">${externalValue}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'is divisible by external value'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-number">100</span>).toBeDivisibleByExternalValue();
  <span class="hljs-keyword">await</span> expect(<span class="hljs-number">101</span>).not.toBeDivisibleByExternalValue();
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="custom-matchers-api"></a><a href="#custom-matchers-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom Matchers API</h4>
<p>Matchers should return an object (or a Promise of an object) with two keys. <code>pass</code> indicates whether there was a match or not, and <code>message</code> provides a function with no arguments that return an error message in case of failure. Astfel, atunci când <code>pass</code> este fals, <code>message</code> trebuie să returneze mesajul de eroare pentru atunci când <code>expect(x).yourMatcher()</code> eșuează. Iar când <code>pass</code> este adevărat, <code>message</code> trebuie să returneze mesajul de eroare pentru atunci când <code>expect(x).not.yourMatcher()</code> eșuează.</p>
<p>Matchers are called with the argument passed to <code>expect(x)</code> followed by the arguments passed to <code>.yourMatcher(y, z)</code>:</p>
<pre><code class="hljs css language-js">expect.extend({
  yourMatcher(x, y, z) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">''</span>,
    };
  },
});
</code></pre>
<p>These helper functions and properties can be found on <code>this</code> inside a custom matcher:</p>
<h4><a class="anchor" aria-hidden="true" id="thisisnot"></a><a href="#thisisnot" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.isNot</code></h4>
<p>A boolean to let you know this matcher was called with the negated <code>.not</code> modifier allowing you to display a clear and correct matcher hint (see example code).</p>
<h4><a class="anchor" aria-hidden="true" id="thispromise"></a><a href="#thispromise" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.promise</code></h4>
<p>A string allowing you to display a clear and correct matcher hint:</p>
<ul>
<li><code>'rejects'</code> if matcher was called with the promise <code>.rejects</code> modifier</li>
<li><code>'resolves'</code> if matcher was called with the promise <code>.resolves</code> modifier</li>
<li><code>''</code> if matcher was not called with a promise modifier</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="thisequalsa-b"></a><a href="#thisequalsa-b" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.equals(a, b)</code></h4>
<p>Aceasta este o funcţie de egalitate-în-adâncime, care va returna <code>true</code> dacă două obiecte au aceleaşi valori (recursiv).</p>
<h4><a class="anchor" aria-hidden="true" id="thisexpand"></a><a href="#thisexpand" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.expand</code></h4>
<p>A boolean to let you know this matcher was called with an <code>expand</code> option. When Jest is called with the <code>--expand</code> flag, <code>this.expand</code> can be used to determine if Jest is expected to show full diffs and errors.</p>
<h4><a class="anchor" aria-hidden="true" id="thisutils"></a><a href="#thisutils" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.utils</code></h4>
<p>Există o serie de instrumente utile expuse în <code>this.utils</code> în principal constând din exporturile din <a href="https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils"> <code>jest-matcher-utils</code></a>.</p>
<p>Cele mai utile sunt <code>matcherHint</code>, <code>printExpected</code> şi <code>printReceived</code> pentru a formata frumos mesajele de eroare. De exemplu, să aruncăm o privire asupra implementării pentru <code>toBe</code>:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> diff = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-diff'</span>);
expect.extend({
  toBe(received, expected) {
    <span class="hljs-keyword">const</span> options = {
      <span class="hljs-attr">comment</span>: <span class="hljs-string">'Object.is equality'</span>,
      <span class="hljs-attr">isNot</span>: <span class="hljs-keyword">this</span>.isNot,
      <span class="hljs-attr">promise</span>: <span class="hljs-keyword">this</span>.promise,
    };

    <span class="hljs-keyword">const</span> pass = <span class="hljs-built_in">Object</span>.is(received, expected);

    <span class="hljs-keyword">const</span> message = pass
      ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'toBe'</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, options) +
          <span class="hljs-string">'\n\n'</span> +
          <span class="hljs-string">`Expected: not <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
          <span class="hljs-string">`Received: <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>
      : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> diffString = diff(expected, received, {
            <span class="hljs-attr">expand</span>: <span class="hljs-keyword">this</span>.expand,
          });
          <span class="hljs-keyword">return</span> (
            <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'toBe'</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, options) +
            <span class="hljs-string">'\n\n'</span> +
            (diffString &amp;&amp; diffString.includes(<span class="hljs-string">'- Expect'</span>)
              ? <span class="hljs-string">`Difference:\n\n<span class="hljs-subst">${diffString}</span>`</span>
              : <span class="hljs-string">`Expected: <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
                <span class="hljs-string">`Received: <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>)
          );
        };

    <span class="hljs-keyword">return</span> {<span class="hljs-attr">actual</span>: received, message, pass};
  },
});
</code></pre>
<p>Acest lucru va afișa ceva similar:</p>
<pre><code class="hljs css language-bash">  expect(received).toBe(expected)

    Expected value to be (using Object.is):
      <span class="hljs-string">"banana"</span>
    Received:
      <span class="hljs-string">"apple"</span>
</code></pre>
<p>Atunci când o aserţiune eșuează, mesajul de eroare ar trebui să dea detalii suficiente pentru utilizator, astfel încât ei poată rezolva problema rapid. Ar trebui să construiți mesaje de eroare precise pentru a vă asigura că utilizatorii de aserțiunilor voastre au o experienţă bună.</p>
<h4><a class="anchor" aria-hidden="true" id="custom-snapshot-matchers"></a><a href="#custom-snapshot-matchers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom snapshot matchers</h4>
<p>To use snapshot testing inside of your custom matcher you can import <code>jest-snapshot</code> and use it from within your matcher.</p>
<p>Here's a snapshot matcher that trims a string to store for a given length, <code>.toMatchTrimmedSnapshot(length)</code>:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> {toMatchSnapshot} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-snapshot'</span>);

expect.extend({
  toMatchTrimmedSnapshot(received, length) {
    <span class="hljs-keyword">return</span> toMatchSnapshot.call(
      <span class="hljs-keyword">this</span>,
      received.substring(<span class="hljs-number">0</span>, length),
      <span class="hljs-string">'toMatchTrimmedSnapshot'</span>,
    );
  },
});

it(<span class="hljs-string">'stores only 10 characters'</span>, () =&gt; {
  expect(<span class="hljs-string">'extra long string oh my gerd'</span>).toMatchTrimmedSnapshot(<span class="hljs-number">10</span>);
});

<span class="hljs-comment">/*
Stored snapshot will look like:

exports[`stores only 10 characters: toMatchTrimmedSnapshot 1`] = `"extra long"`;
*/</span>
</code></pre>
<p>It's also possible to create custom matchers for inline snapshots, the snapshots will be correctly added to the custom matchers. However, inline snapshot will always try to append to the first argument or the second when the first argument is the property matcher, so it's not possible to accept custom arguments in the custom matchers.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> {toMatchInlineSnapshot} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-snapshot'</span>);

expect.extend({
  toMatchTrimmedInlineSnapshot(received) {
    <span class="hljs-keyword">return</span> toMatchInlineSnapshot.call(<span class="hljs-keyword">this</span>, received.substring(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>));
  },
});

it(<span class="hljs-string">'stores only 10 characters'</span>, () =&gt; {
  expect(<span class="hljs-string">'extra long string oh my gerd'</span>).toMatchTrimmedInlineSnapshot();
  <span class="hljs-comment">/*
  The snapshot will be added inline like
  expect('extra long string oh my gerd').toMatchTrimmedInlineSnapshot(
    `"extra long"`
  );
  */</span>
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectanything"></a><a href="#expectanything" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.anything()</code></h3>
<p><code>expect.anything()</code> validează orice, mai putin <code>null</code> sau <code>undefined</code>. Îl puteţi folosi în interiorul lui <code>toEqual</code> sau <code>toBeCalledWith</code> în locul unei valori concrete. De exemplu, dacă doriţi să verificaţi că o dublură a fost apelată cu un argument non-null:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'map calls its argument with a non-null argument'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  [<span class="hljs-number">1</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> mock(x));
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectanyconstructor"></a><a href="#expectanyconstructor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.any(constructor)</code></h3>
<p><code>expect.any(constructor)</code> validează orice obiect creat cu constructorul dat. Îl puteţi folosi în interiorul lui <code>toEqual</code> sau <code>toBeCalledWith</code> în locul unei valori concrete. De exemplu, dacă doriţi să verificaţi că o dublură a fost apelată cu un număr:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randocall</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> fn(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>));
}

test(<span class="hljs-string">'randocall calls its callback with a number'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(<span class="hljs-built_in">Number</span>));
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectarraycontainingarray"></a><a href="#expectarraycontainingarray" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.arrayContaining(array)</code></h3>
<p><code>expect.arrayContaining(array)</code> validează o listă care conţine toate elementele din lista pasată. Adică, lista presupusă este un <strong>subset</strong> al listei primite. Prin urmare, validează o listă care conţine elemente care <strong>nu</strong> fac parte din lista aşteptată.</p>
<p>Îl puteţi folosi în locul unei valori concrete:</p>
<ul>
<li>în <code>toEqual</code> sau <code>toBeCalledWith</code></li>
<li>pentru a valida o proprietate în <code>objectContaining</code> sau <code>toMatchObject</code></li>
</ul>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'Beware of a misunderstanding! A sequence of dice rolls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  it(<span class="hljs-string">'matches even with an unexpected number 7'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it(<span class="hljs-string">'does not match without an expected number 2'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectassertionsnumber"></a><a href="#expectassertionsnumber" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.assertions(number)</code></h3>
<p><code>expect.assertions(number)</code> verifică dacă un anumit număr de aserțiuni au fost apelate în timpul unui test. Acest lucru este adesea util când testăm cod asincron, pentru a ne asigura că aserțiunile dintr-un callback chiar sunt apelate.</p>
<p>De exemplu, să presupunem că avem o funcţie <code>doAsync</code> care primeşte două callback-uri <code>callback1</code> şi <code>callback2</code>, care vor fi apelate asincron într-o ordine necunoscută. Putem testa acest lucru în felul următor:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'doAsync calls both callbacks'</span>, () =&gt; {
  expect.assertions(<span class="hljs-number">2</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p>Apelul <code>expect.assertions(2)</code> asigură că ambele callback-uri au fost apelate.</p>
<h3><a class="anchor" aria-hidden="true" id="expecthasassertions"></a><a href="#expecthasassertions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.hasAssertions()</code></h3>
<p><code>expect.hasAssertions()</code> verifică dacă cel puțin o aserțiune a fost apelată în timpul unui test. Acest lucru este adesea util când testăm cod asincron, pentru a ne asigura că aserțiunile dintr-un callback chiar sunt apelate.</p>
<p>De exemplu, să spunem că avem câteva funcţii care se ocupă toate de stare. <code>prepareState</code> apelează un callback cu un obiect de stare, <code>validateState</code> ruleaza pe acel obiect de stare şi <code>waitOnState</code> returnează o promisiune care aşteaptă până când toate callback-urile <code>prepareState</code> se termină. Putem testa acest lucru în felul următor:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'prepareState prepares a valid state'</span>, () =&gt; {
  expect.hasAssertions();
  prepareState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    expect(validateState(state)).toBeTruthy();
  });
  <span class="hljs-keyword">return</span> waitOnState();
});
</code></pre>
<p>Apelul <code>expect.hasAssertions()</code> ne asigură că <code>prepareState</code> este apelat.</p>
<h3><a class="anchor" aria-hidden="true" id="expectnotarraycontainingarray"></a><a href="#expectnotarraycontainingarray" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.arrayContaining(array)</code></h3>
<p><code>expect.not.arrayContaining(array)</code> matches a received array which does not contain all of the elements in the expected array. That is, the expected array <strong>is not a subset</strong> of the received array.</p>
<p>It is the inverse of <code>expect.arrayContaining</code>.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'not.arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Samantha'</span>];

  it(<span class="hljs-string">'matches if the actual array does not contain the expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(
      expect.not.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectnotobjectcontainingobject"></a><a href="#expectnotobjectcontainingobject" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.objectContaining(object)</code></h3>
<p><code>expect.not.objectContaining(object)</code> matches any received object that does not recursively match the expected properties. That is, the expected object <strong>is not a subset</strong> of the received object. Prin urmare, validează un obiect primit care conţine proprietăți care <strong>nu</strong> fac parte din obiectul aşteptat.</p>
<p>It is the inverse of <code>expect.objectContaining</code>.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'not.objectContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = {<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>};

  it(<span class="hljs-string">'matches if the actual object does not contain expected key: value pairs'</span>, () =&gt; {
    expect({<span class="hljs-attr">bar</span>: <span class="hljs-string">'baz'</span>}).toEqual(expect.not.objectContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectnotstringcontainingstring"></a><a href="#expectnotstringcontainingstring" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.stringContaining(string)</code></h3>
<p><code>expect.not.stringContaining(string)</code> matches the received value if it is not a string or if it is a string that does not contain the exact expected string.</p>
<p>It is the inverse of <code>expect.stringContaining</code>.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'not.stringContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = <span class="hljs-string">'Hello world!'</span>;

  it(<span class="hljs-string">'matches if the received value does not contain the expected substring'</span>, () =&gt; {
    expect(<span class="hljs-string">'How are you?'</span>).toEqual(expect.not.stringContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectnotstringmatchingstring--regexp"></a><a href="#expectnotstringmatchingstring--regexp" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.stringMatching(string | regexp)</code></h3>
<p><code>expect.not.stringMatching(string | regexp)</code> matches the received value if it is not a string or if it is a string that does not match the expected string or regular expression.</p>
<p>It is the inverse of <code>expect.stringMatching</code>.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'not.stringMatching'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = <span class="hljs-regexp">/Hello world!/</span>;

  it(<span class="hljs-string">'matches if the received value does not match the expected regex'</span>, () =&gt; {
    expect(<span class="hljs-string">'How are you?'</span>).toEqual(expect.not.stringMatching(expected));
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectobjectcontainingobject"></a><a href="#expectobjectcontainingobject" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.objectContaining(object)</code></h3>
<p><code>expect.objectContaining(object)</code> validează orice obiect primit care conține în mod recursiv proprietăţile aşteptate. Adică, obiectul asteptat este un <strong>subset</strong> al obiectului primit. Therefore, it matches a received object which contains properties that <strong>are present</strong> in the expected object.</p>
<p>În loc de valori literale în obiectul aşteptat, puteţi utiliza validatori, <code>expect.anything()</code>, şi aşa mai departe.</p>
<p>De exemplu, să presupunem că ne aşteptăm ca o funcţie <code>onPress</code> să fie apelată cu un obiect de tip <code>Event</code>, şi tot ce avem nevoie să verificăm este că evenimentul are proprietățile <code>event.x</code> și <code>event.y</code>. Putem testa acest lucru în felul următor:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'onPress gets called with the right thing'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(
    expect.objectContaining({
      <span class="hljs-attr">x</span>: expect.any(<span class="hljs-built_in">Number</span>),
      <span class="hljs-attr">y</span>: expect.any(<span class="hljs-built_in">Number</span>),
    }),
  );
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectstringcontainingstring"></a><a href="#expectstringcontainingstring" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.stringContaining(string)</code></h3>
<p><code>expect.stringContaining(string)</code> matches the received value if it is a string that contains the exact expected string.</p>
<h3><a class="anchor" aria-hidden="true" id="expectstringmatchingstring--regexp"></a><a href="#expectstringmatchingstring--regexp" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.stringMatching(string | regexp)</code></h3>
<p><code>expect.stringMatching(string | regexp)</code> matches the received value if it is a string that matches the expected string or regular expression.</p>
<p>Îl puteţi folosi în locul unei valori concrete:</p>
<ul>
<li>în <code>toEqual</code> sau <code>toBeCalledWith</code></li>
<li>pentru a valida un element în <code>arrayContaining</code></li>
<li>pentru a valida o proprietate în <code>objectContaining</code> sau <code>toMatchObject</code></li>
</ul>
<p>Acest exemplu arată cum puteţi imbrica mai mulți validatori asimetrici, cu <code>expect.stringMatching</code> în interiorul unui <code>expect.arrayContaining</code>.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'stringMatching in arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [
    expect.stringMatching(<span class="hljs-regexp">/^Alic/</span>),
    expect.stringMatching(<span class="hljs-regexp">/^[BR]ob/</span>),
  ];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alicia'</span>, <span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectaddsnapshotserializerserializer"></a><a href="#expectaddsnapshotserializerserializer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.addSnapshotSerializer(serializer)</code></h3>
<p>Puteţi apela <code>expect.addSnapshotSerializer</code> pentru a adăuga un modul care formatează structuri de date specifice aplicaţiei.</p>
<p>Pentru un fişier de individual test, un modul suplimentar precede orice module din configurarea <code>snapshotSerializers</code>, care precedă la rândul lor serializatoarele implicite pentru tipurile JavaScript şi elemente React. Ultimul modul adăugat este primul testat.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> serializer <span class="hljs-keyword">from</span> <span class="hljs-string">'my-serializer-module'</span>;
expect.addSnapshotSerializer(serializer);

<span class="hljs-comment">// affects expect(value).toMatchSnapshot() assertions in the test file</span>
</code></pre>
<p>If you add a snapshot serializer in individual test files instead of adding it to <code>snapshotSerializers</code> configuration:</p>
<ul>
<li>Definiți explicit dependenţa în loc de implicit.</li>
<li>Evitați limitele de configurare care v-ar putea forța să faceți &quot;eject&quot; din <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>.</li>
</ul>
<p>A se vedea <a href="/docs/ro/26.5/configuration#snapshotserializers-arraystring">configurarea Jest</a> pentru mai multe informaţii.</p>
<h3><a class="anchor" aria-hidden="true" id="not"></a><a href="#not" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.not</code></h3>
<p>If you know how to test something, <code>.not</code> lets you test its opposite. For example, this code tests that the best La Croix flavor is not coconut:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'the best flavor is not coconut'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).not.toBe(<span class="hljs-string">'coconut'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="resolves"></a><a href="#resolves" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.resolves</code></h3>
<p>Use <code>resolves</code> to unwrap the value of a fulfilled promise so any other matcher can be chained. If the promise is rejected the assertion fails.</p>
<p>De exemplu, acest cod testează că promisiunea se rezolvă şi că valoarea rezultată este <code>'lemon'</code>:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'resolves to lemon'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
});
</code></pre>
<p>Note that, since you are still testing promises, the test is still asynchronous. Hence, you will need to <a href="/docs/ro/26.5/asynchronous#promises">tell Jest to wait</a> by returning the unwrapped assertion.</p>
<p>Alternativ, puteţi utiliza <code>async/await</code> în combinaţie cu <code>.resolves</code>:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'resolves to lemon'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.not.toBe(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="rejects"></a><a href="#rejects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.rejects</code></h3>
<p>Use <code>.rejects</code> to unwrap the reason of a rejected promise so any other matcher can be chained. If the promise is fulfilled the assertion fails.</p>
<p>For example, this code tests that the promise rejects with reason <code>'octopus'</code>:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'rejects to octopus'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'octopus'</span>))).rejects.toThrow(
    <span class="hljs-string">'octopus'</span>,
  );
});
</code></pre>
<p>Note that, since you are still testing promises, the test is still asynchronous. Hence, you will need to <a href="/docs/ro/26.5/asynchronous#promises">tell Jest to wait</a> by returning the unwrapped assertion.</p>
<p>Alternatively, you can use <code>async/await</code> in combination with <code>.rejects</code>.</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'rejects to octopus'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'octopus'</span>))).rejects.toThrow(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobevalue"></a><a href="#tobevalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBe(value)</code></h3>
<p>Use <code>.toBe</code> to compare primitive values or to check referential identity of object instances. It calls <code>Object.is</code> to compare values, which is even better for testing than <code>===</code> strict equality operator.</p>
<p>De exemplu, acest cod va valida unele proprietăţi ale obiectului <code>can</code>:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> can = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'pamplemousse'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the can'</span>, () =&gt; {
  test(<span class="hljs-string">'has 12 ounces'</span>, () =&gt; {
    expect(can.ounces).toBe(<span class="hljs-number">12</span>);
  });

  test(<span class="hljs-string">'has a sophisticated name'</span>, () =&gt; {
    expect(can.name).toBe(<span class="hljs-string">'pamplemousse'</span>);
  });
});
</code></pre>
<p>Don't use <code>.toBe</code> with floating-point numbers. De exemplu, din cauza rotunjirilor, în JavaScript <code>0.2 + 0.1</code> nu este strict egal cu <code>0.3</code>. Dacă aveţi numerele cu virgulă mobilă, încercaţi <code>.toBeCloseTo</code> în schimb.</p>
<p>Although the <code>.toBe</code> matcher <strong>checks</strong> referential identity, it <strong>reports</strong> a deep comparison of values if the assertion fails. If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the <code>expect</code> function. For example, to assert whether or not elements are the same instance:</p>
<ul>
<li>rewrite <code>expect(received).toBe(expected)</code> as <code>expect(Object.is(received, expected)).toBe(true)</code></li>
<li>rewrite <code>expect(received).not.toBe(expected)</code> as <code>expect(Object.is(received, expected)).toBe(false)</code></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="tohavebeencalled"></a><a href="#tohavebeencalled" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalled()</code></h3>
<p>Există și cu aliasul: <code>.toBeCalled()</code></p>
<p>Utilizaţi <code>.toHaveBeenCalled</code> pentru a vă asigura că o funcţie mock a fost apelată.</p>
<p>For example, let's say you have a <code>drinkAll(drink, flavour)</code> function that takes a <code>drink</code> function and applies it to all available beverages. You might want to check that <code>drink</code> gets called for <code>'lemon'</code>, but not for <code>'octopus'</code>, because <code>'octopus'</code> flavour is really weird and why would anything be octopus-flavoured? Se poate face asta cu următorul test:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkAll</span>(<span class="hljs-params">callback, flavour</span>) </span>{
  <span class="hljs-keyword">if</span> (flavour !== <span class="hljs-string">'octopus'</span>) {
    callback(flavour);
  }
}

describe(<span class="hljs-string">'drinkAll'</span>, () =&gt; {
  test(<span class="hljs-string">'drinks something lemon-flavoured'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'lemon'</span>);
    expect(drink).toHaveBeenCalled();
  });

  test(<span class="hljs-string">'does not drink something octopus-flavoured'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'octopus'</span>);
    expect(drink).not.toHaveBeenCalled();
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavebeencalledtimesnumber"></a><a href="#tohavebeencalledtimesnumber" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalledTimes(number)</code></h3>
<p>Also under the alias: <code>.toBeCalledTimes(number)</code></p>
<p>Utilizaţi <code>. toHaveBeenCalledTimes</code> pentru a vă asigura că o funcţie mock a fost apelată de un anumit număr de ori.</p>
<p>De exemplu, să presupunem că avem o funcţie <code>drinkEach(drink, Array&lt;flavor&gt;)</code>, care primește o funcţie <code>drink</code> pe care o aplică tuturor băuturilor primite. Aţi putea verifica faptul că funcţia a fost apelată de un număr exact de ori. Se poate face asta cu următorul test:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drinkEach drinks each drink'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  drinkEach(drink, [<span class="hljs-string">'lemon'</span>, <span class="hljs-string">'octopus'</span>]);
  expect(drink).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavebeencalledwitharg1-arg2-"></a><a href="#tohavebeencalledwitharg1-arg2-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code></h3>
<p>Există și cu aliasul: <code>.toBeCalledWith()</code></p>
<p>Utilizaţi <code>.toHaveBeenCalledWith</code> pentru a vă asigura că o funcţie mock a fost apelată cu niște argumente specifice.</p>
<p>De exemplu, să spunem că puteţi înregistra o băutură cu funcție <code>register</code>, şi <code>applyToAll(f)</code> ar trebui să aplice funcția <code>f</code> tuturor băuturilor înregistrate. Pentru a vă asigura că aceasta funcţionează, ați putea scrie:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'registration applies correctly to orange La Croix'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage = <span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'orange'</span>);
  register(beverage);
  <span class="hljs-keyword">const</span> f = jest.fn();
  applyToAll(f);
  expect(f).toHaveBeenCalledWith(beverage);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavebeenlastcalledwitharg1-arg2-"></a><a href="#tohavebeenlastcalledwitharg1-arg2-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code></h3>
<p>Există și cu aliasul: <code>.lastCalledWith(arg1, arg2, ...)</code></p>
<p>Dacă aveţi o funcţie mock, puteţi utiliza <code>.toHaveBeenLastCalledWith</code> pentru a testa cu ce argumente a fost apelată ultima dată. De exemplu, să presupunem că aveţi o funcţie <code>applyToAllFlavors(f)</code>, care aplică <code>f</code> la o grămadă de arome, şi doriţi să vă asiguraţi că, atunci când o apelați, ultima aromă cu care operează este <code>'mango'</code>. Puteţi scrie:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'applying to all flavors does mango last'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  applyToAllFlavors(drink);
  expect(drink).toHaveBeenLastCalledWith(<span class="hljs-string">'mango'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavebeennthcalledwithnthcall-arg1-arg2-"></a><a href="#tohavebeennthcalledwithnthcall-arg1-arg2-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)</code></h3>
<p>Also under the alias: <code>.nthCalledWith(nthCall, arg1, arg2, ...)</code></p>
<p>If you have a mock function, you can use <code>.toHaveBeenNthCalledWith</code> to test what arguments it was nth called with. For example, let's say you have a <code>drinkEach(drink, Array&lt;flavor&gt;)</code> function that applies <code>f</code> to a bunch of flavors, and you want to ensure that when you call it, the first flavor it operates on is <code>'lemon'</code> and the second one is <code>'octopus'</code>. Puteţi scrie:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drinkEach drinks each drink'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  drinkEach(drink, [<span class="hljs-string">'lemon'</span>, <span class="hljs-string">'octopus'</span>]);
  expect(drink).toHaveBeenNthCalledWith(<span class="hljs-number">1</span>, <span class="hljs-string">'lemon'</span>);
  expect(drink).toHaveBeenNthCalledWith(<span class="hljs-number">2</span>, <span class="hljs-string">'octopus'</span>);
});
</code></pre>
<p>Note: the nth argument must be positive integer starting from 1.</p>
<h3><a class="anchor" aria-hidden="true" id="tohavereturned"></a><a href="#tohavereturned" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveReturned()</code></h3>
<p>Also under the alias: <code>.toReturn()</code></p>
<p>If you have a mock function, you can use <code>.toHaveReturned</code> to test that the mock function successfully returned (i.e., did not throw an error) at least one time. For example, let's say you have a mock <code>drink</code> that returns <code>true</code>. Puteţi scrie:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drinks returns'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-literal">true</span>);

  drink();

  expect(drink).toHaveReturned();
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavereturnedtimesnumber"></a><a href="#tohavereturnedtimesnumber" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveReturnedTimes(number)</code></h3>
<p>Also under the alias: <code>.toReturnTimes(number)</code></p>
<p>Use <code>.toHaveReturnedTimes</code> to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned.</p>
<p>For example, let's say you have a mock <code>drink</code> that returns <code>true</code>. Puteţi scrie:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drink returns twice'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-literal">true</span>);

  drink();
  drink();

  expect(drink).toHaveReturnedTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavereturnedwithvalue"></a><a href="#tohavereturnedwithvalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveReturnedWith(value)</code></h3>
<p>Also under the alias: <code>.toReturnWith(value)</code></p>
<p>Use <code>.toHaveReturnedWith</code> to ensure that a mock function returned a specific value.</p>
<p>For example, let's say you have a mock <code>drink</code> that returns the name of the beverage that was consumed. Puteţi scrie:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drink returns La Croix'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage = {<span class="hljs-attr">name</span>: <span class="hljs-string">'La Croix'</span>};
  <span class="hljs-keyword">const</span> drink = jest.fn(<span class="hljs-function"><span class="hljs-params">beverage</span> =&gt;</span> beverage.name);

  drink(beverage);

  expect(drink).toHaveReturnedWith(<span class="hljs-string">'La Croix'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavelastreturnedwithvalue"></a><a href="#tohavelastreturnedwithvalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveLastReturnedWith(value)</code></h3>
<p>Also under the alias: <code>.lastReturnedWith(value)</code></p>
<p>Use <code>.toHaveLastReturnedWith</code> to test the specific value that a mock function last returned. If the last call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</p>
<p>For example, let's say you have a mock <code>drink</code> that returns the name of the beverage that was consumed. Puteţi scrie:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drink returns La Croix (Orange) last'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage1 = {<span class="hljs-attr">name</span>: <span class="hljs-string">'La Croix (Lemon)'</span>};
  <span class="hljs-keyword">const</span> beverage2 = {<span class="hljs-attr">name</span>: <span class="hljs-string">'La Croix (Orange)'</span>};
  <span class="hljs-keyword">const</span> drink = jest.fn(<span class="hljs-function"><span class="hljs-params">beverage</span> =&gt;</span> beverage.name);

  drink(beverage1);
  drink(beverage2);

  expect(drink).toHaveLastReturnedWith(<span class="hljs-string">'La Croix (Orange)'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohaventhreturnedwithnthcall-value"></a><a href="#tohaventhreturnedwithnthcall-value" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveNthReturnedWith(nthCall, value)</code></h3>
<p>Also under the alias: <code>.nthReturnedWith(nthCall, value)</code></p>
<p>Use <code>.toHaveNthReturnedWith</code> to test the specific value that a mock function returned for the nth call. If the nth call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</p>
<p>For example, let's say you have a mock <code>drink</code> that returns the name of the beverage that was consumed. Puteţi scrie:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drink returns expected nth calls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage1 = {<span class="hljs-attr">name</span>: <span class="hljs-string">'La Croix (Lemon)'</span>};
  <span class="hljs-keyword">const</span> beverage2 = {<span class="hljs-attr">name</span>: <span class="hljs-string">'La Croix (Orange)'</span>};
  <span class="hljs-keyword">const</span> drink = jest.fn(<span class="hljs-function"><span class="hljs-params">beverage</span> =&gt;</span> beverage.name);

  drink(beverage1);
  drink(beverage2);

  expect(drink).toHaveNthReturnedWith(<span class="hljs-number">1</span>, <span class="hljs-string">'La Croix (Lemon)'</span>);
  expect(drink).toHaveNthReturnedWith(<span class="hljs-number">2</span>, <span class="hljs-string">'La Croix (Orange)'</span>);
});
</code></pre>
<p>Note: the nth argument must be positive integer starting from 1.</p>
<h3><a class="anchor" aria-hidden="true" id="tohavelengthnumber"></a><a href="#tohavelengthnumber" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveLength(number)</code></h3>
<p>Utilizaţi <code>.toHaveLength</code> pentru a verifica dacă un obiect are o proprietate de <code>.length</code> şi are o anumită valoare numerică.</p>
<p>Acest lucru este util mai ales pentru a verifica dimensiunea listelor sau a șirurilor de caractere.</p>
<pre><code class="hljs css language-js">expect([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">'abc'</span>).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">''</span>).not.toHaveLength(<span class="hljs-number">5</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavepropertykeypath-value"></a><a href="#tohavepropertykeypath-value" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveProperty(keyPath, value?)</code></h3>
<p>Utilizaţi <code>.toHaveProperty</code> pentru a verifica dacă există o anumită proprietate la referinţa <code>keyPath</code> pentru un obiect. For checking deeply nested properties in an object you may use <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors">dot notation</a> or an array containing the keyPath for deep references.</p>
<p>You can provide an optional <code>value</code> argument to compare the received property value (recursively for all properties of object instances, also known as deep equality, like the <code>toEqual</code> matcher).</p>
<p>Exemplul următor conţine un obiect <code>houseForSale</code> cu proprietăţi imbricate. We are using <code>toHaveProperty</code> to check for the existence and values of various properties in the object.</p>
<pre><code class="hljs css language-js"><span class="hljs-comment">// Object containing house features to be tested</span>
<span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
    <span class="hljs-string">'nice.oven'</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-string">'ceiling.height'</span>: <span class="hljs-number">2</span>,
};

test(<span class="hljs-string">'this house has my desired features'</span>, () =&gt; {
  <span class="hljs-comment">// Example Referencing</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bath'</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bedrooms'</span>, <span class="hljs-number">4</span>);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'pool'</span>);

  <span class="hljs-comment">// Deep referencing using dot notation</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.area'</span>, <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.amenities'</span>, [
    <span class="hljs-string">'oven'</span>,
    <span class="hljs-string">'stove'</span>,
    <span class="hljs-string">'washer'</span>,
  ]);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'kitchen.open'</span>);

  <span class="hljs-comment">// Deep referencing using an array containing the keyPath</span>
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'area'</span>], <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(
    [<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'amenities'</span>],
    [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
  );
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'amenities'</span>, <span class="hljs-number">0</span>], <span class="hljs-string">'oven'</span>);
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'nice.oven'</span>]);
  expect(houseForSale).not.toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'open'</span>]);

  <span class="hljs-comment">// Referencing keys with dot in the key itself</span>
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'ceiling.height'</span>], <span class="hljs-string">'tall'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobeclosetonumber-numdigits"></a><a href="#tobeclosetonumber-numdigits" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeCloseTo(number, numDigits?)</code></h3>
<p>Use <code>toBeCloseTo</code> to compare floating point numbers for approximate equality.</p>
<p>The optional <code>numDigits</code> argument limits the number of digits to check <strong>after</strong> the decimal point. For the default value <code>2</code>, the test criterion is <code>Math.abs(expected - received) &lt; 0.005</code> (that is, <code>10 ** -2 / 2</code>).</p>
<p>Intuitive equality comparisons often fail, because arithmetic on decimal (base 10) values often have rounding errors in limited precision binary (base 2) representation. For example, this test fails:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'adding works sanely with decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBe(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// Fails!</span>
});
</code></pre>
<p>It fails because in JavaScript, <code>0.2 + 0.1</code> is actually <code>0.30000000000000004</code>.</p>
<p>For example, this test passes with a precision of 5 digits:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'adding works sanely with decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBeCloseTo(<span class="hljs-number">0.3</span>, <span class="hljs-number">5</span>);
});
</code></pre>
<p>Because floating point errors are the problem that <code>toBeCloseTo</code> solves, it does not support big integer values.</p>
<h3><a class="anchor" aria-hidden="true" id="tobedefined"></a><a href="#tobedefined" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeDefined()</code></h3>
<p>Utilizaţi <code>.toBeDefined</code> pentru a verifica dacă o variabilă nu este nedefinită. For example, if you want to check that a function <code>fetchNewFlavorIdea()</code> returns <em>something</em>, you can write:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'there is a new flavor idea'</span>, () =&gt; {
  expect(fetchNewFlavorIdea()).toBeDefined();
});
</code></pre>
<p>Ați putea scrie și <code>expect(fetchNewFlavorIdea()).not.toBe(undefined)</code>, dar este de preferat să evitați referința la <code>undefined</code> în mod direct în codul vostru.</p>
<h3><a class="anchor" aria-hidden="true" id="tobefalsy"></a><a href="#tobefalsy" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeFalsy()</code></h3>
<p>Use <code>.toBeFalsy</code> when you don't care what a value is and you want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:</p>
<pre><code class="hljs css language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (!getErrors()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>Nu ar trebui sa ne pese ce anume returnează <code>getErrors</code>, specific - ar putea returna <code>false</code>, <code>null</code>, sau <code>0</code>, codul funcționând identic. Așadar, dacă doriţi să testaţi ca nu există erori după ce ați băut niște La Croix, ați putea scrie:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drinking La Croix does not lead to errors'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(getErrors()).toBeFalsy();
});
</code></pre>
<p>In JavaScript, there are six falsy values: <code>false</code>, <code>0</code>, <code>''</code>, <code>null</code>, <code>undefined</code>, and <code>NaN</code>. Everything else is truthy.</p>
<h3><a class="anchor" aria-hidden="true" id="tobegreaterthannumber--bigint"></a><a href="#tobegreaterthannumber--bigint" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeGreaterThan(number | bigint)</code></h3>
<p>Use <code>toBeGreaterThan</code> to compare <code>received &gt; expected</code> for number or big integer values. For example, test that <code>ouncesPerCan()</code> returns a value of more than 10 ounces:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'ounces per can is more than 10'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThan(<span class="hljs-number">10</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobegreaterthanorequalnumber--bigint"></a><a href="#tobegreaterthanorequalnumber--bigint" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeGreaterThanOrEqual(number | bigint)</code></h3>
<p>Use <code>toBeGreaterThanOrEqual</code> to compare <code>received &gt;= expected</code> for number or big integer values. For example, test that <code>ouncesPerCan()</code> returns a value of at least 12 ounces:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'ounces per can is at least 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobelessthannumber--bigint"></a><a href="#tobelessthannumber--bigint" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeLessThan(number | bigint)</code></h3>
<p>Use <code>toBeLessThan</code> to compare <code>received &lt; expected</code> for number or big integer values. For example, test that <code>ouncesPerCan()</code> returns a value of less than 20 ounces:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'ounces per can is less than 20'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThan(<span class="hljs-number">20</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobelessthanorequalnumber--bigint"></a><a href="#tobelessthanorequalnumber--bigint" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeLessThanOrEqual(number | bigint)</code></h3>
<p>Use <code>toBeLessThanOrEqual</code> to compare <code>received &lt;= expected</code> for number or big integer values. For example, test that <code>ouncesPerCan()</code> returns a value of at most 12 ounces:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'ounces per can is at most 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobeinstanceofclass"></a><a href="#tobeinstanceofclass" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeInstanceOf(Class)</code></h3>
<p>Use <code>.toBeInstanceOf(Class)</code> to check that an object is an instance of a class. This matcher uses <code>instanceof</code> underneath.</p>
<pre><code class="hljs css language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{}

expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(A);
expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}).toBeInstanceOf(<span class="hljs-built_in">Function</span>);
expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(<span class="hljs-built_in">Function</span>); <span class="hljs-comment">// throws</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobenull"></a><a href="#tobenull" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeNull()</code></h3>
<p><code>.toBeNull()</code> is the same as <code>.toBe(null)</code> but the error messages are a bit nicer. So use <code>.toBeNull()</code> when you want to check that something is null.</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bloop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

test(<span class="hljs-string">'bloop returns null'</span>, () =&gt; {
  expect(bloop()).toBeNull();
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobetruthy"></a><a href="#tobetruthy" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeTruthy()</code></h3>
<p>Use <code>.toBeTruthy</code> when you don't care what a value is and you want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:</p>
<pre><code class="hljs css language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (thirstInfo()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>Nu ar trebui sa ne pese ce anume returnează <code>thirstInfo</code>, specific - ar putea returna fie <code>true</code> fie un obiect complex, codul funcționând identic. So if you want to test that <code>thirstInfo</code> will be truthy after drinking some La Croix, you could write:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drinking La Croix leads to having thirst info'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(thirstInfo()).toBeTruthy();
});
</code></pre>
<p>In JavaScript, there are six falsy values: <code>false</code>, <code>0</code>, <code>''</code>, <code>null</code>, <code>undefined</code>, and <code>NaN</code>. Everything else is truthy.</p>
<h3><a class="anchor" aria-hidden="true" id="tobeundefined"></a><a href="#tobeundefined" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeUndefined()</code></h3>
<p>Utilizaţi <code>.toBeUndefined</code> pentru a verifica dacă o variabilă este nedefinită. De exemplu, dacă doriţi să verificaţi dacă o funcţie <code>bestDrinkForFlavor(flavor)</code> returnează <code>undefined</code> pentru aroma <code>'octopus'</code>:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'the best drink for octopus flavor is undefined'</span>, () =&gt; {
  expect(bestDrinkForFlavor(<span class="hljs-string">'octopus'</span>)).toBeUndefined();
});
</code></pre>
<p>Ați putea scrie și <code>expect(bestDrinkForFlavor()).toBe(undefined)</code>, dar este de preferat să evitați referința la <code>undefined</code> în mod direct în codul vostru.</p>
<h3><a class="anchor" aria-hidden="true" id="tobenan"></a><a href="#tobenan" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeNaN()</code></h3>
<p>Use <code>.toBeNaN</code> when checking a value is <code>NaN</code>.</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'passes when value is NaN'</span>, () =&gt; {
  expect(<span class="hljs-literal">NaN</span>).toBeNaN();
  expect(<span class="hljs-number">1</span>).not.toBeNaN();
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tocontainitem"></a><a href="#tocontainitem" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toContain(item)</code></h3>
<p>Utilizaţi <code>.toContain</code> atunci când doriţi să verificați dacă un element se află într-o listă. Pentru testarea elementele din matrice, foloseste <code>===</code>, o verificare de strictă egalitate. <code>.toContain</code> poate de asemenea verifica dacă un string este un subșir al unui alt şir.</p>
<p>De exemplu, dacă <code>getAllFlavors()</code> returnează o listă de arome şi doriţi să vă asiguraţi că <code>lime</code> se află în ea, se poate scrie:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'the flavor list contains lime'</span>, () =&gt; {
  expect(getAllFlavors()).toContain(<span class="hljs-string">'lime'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tocontainequalitem"></a><a href="#tocontainequalitem" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toContainEqual(item)</code></h3>
<p>Utilizaţi <code>.toContainEqual</code> atunci când doriţi pentru să verificați dacă un element cu o anumită structură şi valori este conţinut într-o listă. Pentru testarea elementele din listă, acest validator verifică recursiv egalitatea tuturor proprietăților, în loc să verifice referința obiectului.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious and not sour'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> myBeverage = {<span class="hljs-attr">delicious</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">sour</span>: <span class="hljs-literal">false</span>};
    expect(myBeverages()).toContainEqual(myBeverage);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="toequalvalue"></a><a href="#toequalvalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toEqual(value)</code></h3>
<p>Use <code>.toEqual</code> to compare recursively all properties of object instances (also known as &quot;deep&quot; equality). It calls <code>Object.is</code> to compare primitive values, which is even better for testing than <code>===</code> strict equality operator.</p>
<p>For example, <code>.toEqual</code> and <code>.toBe</code> behave differently in this test suite, so all the tests pass:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> can1 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};
<span class="hljs-keyword">const</span> can2 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the La Croix cans on my desk'</span>, () =&gt; {
  test(<span class="hljs-string">'have all the same properties'</span>, () =&gt; {
    expect(can1).toEqual(can2);
  });
  test(<span class="hljs-string">'are not the exact same can'</span>, () =&gt; {
    expect(can1).not.toBe(can2);
  });
});
</code></pre>
<blockquote>
<p>Notă: <code>.toEqual</code> nu va efectua o verificare de <em>egalitate profundă</em> pentru două obiecte Error. Numai proprietatea <code>message</code> al obiectului Error este luată în considerare pentru verificare. Este recomandat să utilizaţi <code>.toThrow</code> pentru testarea erorilor.</p>
</blockquote>
<p>If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the <code>expect</code> function. For example, use <code>equals</code> method of <code>Buffer</code> class to assert whether or not buffers contain the same content:</p>
<ul>
<li>rewrite <code>expect(received).toEqual(expected)</code> as <code>expect(received.equals(expected)).toBe(true)</code></li>
<li>rewrite <code>expect(received).not.toEqual(expected)</code> as <code>expect(received.equals(expected)).toBe(false)</code></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="tomatchregexporstring"></a><a href="#tomatchregexporstring" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatch(regexpOrString)</code></h3>
<p>Utilizaţi <code>.toMatch</code> pentru a verifica dacă un şir de caractere validează o expresie regulată.</p>
<p>De exemplu, s-ar putea să nu ştiţi exact ce returnează <code>essayOnTheBestFlavor()</code>, dar știți că este un şir foarte lung şi că ar trebui să conțină un subșir <code>grapefruit</code>. Puteți testa acest lucru în felul următor:</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'an essay on the best flavor'</span>, () =&gt; {
  test(<span class="hljs-string">'mentions grapefruit'</span>, () =&gt; {
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-regexp">/grapefruit/</span>);
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'grapefruit'</span>));
  });
});
</code></pre>
<p>Acest validator acceptă, de asemenea, un şir de caractere, pe care va încerca să-l găsească:</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'grapefruits are healthy'</span>, () =&gt; {
  test(<span class="hljs-string">'grapefruits are a fruit'</span>, () =&gt; {
    expect(<span class="hljs-string">'grapefruits'</span>).toMatch(<span class="hljs-string">'fruit'</span>);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tomatchobjectobject"></a><a href="#tomatchobjectobject" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchObject(object)</code></h3>
<p>Utilizaţi <code>.toMatchObject</code> pentru a verifica dacă un obiect JavaScript conține un subset de proprietăți ale altui obiect. Validează un obiecte care conţin proprietăți care <strong>nu</strong> fac parte din obiectul aşteptat.</p>
<p>Se poate pasa, de asemenea, o listă de obiecte, iar în cazul acesta metoda va returna adevărat numai în cazul în care fiecare obiect din lista primită se potrivește (în sensul <code>toMatchObject</code> descris mai sus) cu obiectul corespunzător din lista aşteptată. Acest lucru este util dacă doriţi să verificaţi că două liste se potrivesc in raport cu numărul lor de elemente, spre deosebire de <code>arrayContaining</code>, care permite elemente suplimentare în lista primită.</p>
<p>Aveţi posibilitatea să validați proprietăţi cu valori sau cu alți validatori.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};
<span class="hljs-keyword">const</span> desiredHouse = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">wallColor</span>: expect.stringMatching(<span class="hljs-regexp">/white|yellow/</span>),
  },
};

test(<span class="hljs-string">'the house has my desired features'</span>, () =&gt; {
  expect(houseForSale).toMatchObject(desiredHouse);
});
</code></pre>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'toMatchObject applied to arrays'</span>, () =&gt; {
  test(<span class="hljs-string">'the number of elements must match exactly'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]).toMatchObject([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]);
  });

  test(<span class="hljs-string">'.toMatchObject is called for each elements, so extra object properties are okay'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">extra</span>: <span class="hljs-string">'quux'</span>}]).toMatchObject([
      {<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>},
      {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>},
    ]);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tomatchsnapshotpropertymatchers-hint"></a><a href="#tomatchsnapshotpropertymatchers-hint" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchSnapshot(propertyMatchers?, hint?)</code></h3>
<p>This ensures that a value matches the most recent snapshot. Check out <a href="/docs/ro/26.5/snapshot-testing">the Snapshot Testing guide</a> for more information.</p>
<p>You can provide an optional <code>propertyMatchers</code> object argument, which has asymmetric matchers as values of a subset of expected properties, <strong>if</strong> the received value will be an <strong>object</strong> instance. It is like <code>toMatchObject</code> with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties.</p>
<p>You can provide an optional <code>hint</code> string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate <strong>multiple</strong> snapshots in a <strong>single</strong> <code>it</code> or <code>test</code> block. Jest sorts snapshots by name in the corresponding <code>.snap</code> file.</p>
<h3><a class="anchor" aria-hidden="true" id="tomatchinlinesnapshotpropertymatchers-inlinesnapshot"></a><a href="#tomatchinlinesnapshotpropertymatchers-inlinesnapshot" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)</code></h3>
<p>Ensures that a value matches the most recent snapshot.</p>
<p>You can provide an optional <code>propertyMatchers</code> object argument, which has asymmetric matchers as values of a subset of expected properties, <strong>if</strong> the received value will be an <strong>object</strong> instance. It is like <code>toMatchObject</code> with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties.</p>
<p>Jest adds the <code>inlineSnapshot</code> string argument to the matcher in the test file (instead of an external <code>.snap</code> file) the first time that the test runs.</p>
<p>Check out the section on <a href="/docs/ro/26.5/snapshot-testing#inline-snapshots">Inline Snapshots</a> for more info.</p>
<h3><a class="anchor" aria-hidden="true" id="tostrictequalvalue"></a><a href="#tostrictequalvalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toStrictEqual(value)</code></h3>
<p>Use <code>.toStrictEqual</code> to test that objects have the same types as well as structure.</p>
<p>Differences from <code>.toEqual</code>:</p>
<ul>
<li>Keys with <code>undefined</code> properties are checked. e.g. <code>{a: undefined, b: 2}</code> does not match <code>{b: 2}</code> when using <code>.toStrictEqual</code>.</li>
<li>Array sparseness is checked. e.g. <code>[, 1]</code> does not match <code>[undefined, 1]</code> when using <code>.toStrictEqual</code>.</li>
<li>Object types are checked to be equal. e.g. A class instance with fields <code>a</code> and <code>b</code> will not equal a literal object with fields <code>a</code> and <code>b</code>.</li>
</ul>
<pre><code class="hljs css language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaCroix</span> </span>{
  <span class="hljs-keyword">constructor</span>(flavor) {
    <span class="hljs-keyword">this</span>.flavor = flavor;
  }
}

describe(<span class="hljs-string">'the La Croix cans on my desk'</span>, () =&gt; {
  test(<span class="hljs-string">'are not semantically the same'</span>, () =&gt; {
    expect(<span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'lemon'</span>)).toEqual({<span class="hljs-attr">flavor</span>: <span class="hljs-string">'lemon'</span>});
    expect(<span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'lemon'</span>)).not.toStrictEqual({<span class="hljs-attr">flavor</span>: <span class="hljs-string">'lemon'</span>});
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tothrowerror"></a><a href="#tothrowerror" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrow(error?)</code></h3>
<p>Also under the alias: <code>.toThrowError(error?)</code></p>
<p>Utilizaţi <code>.toThrow</code> pentru a testa dacă o funcţie aruncă o excepție atunci când este apelată. De exemplu, dacă vrem să testăm că <code>drinkFlavor('octopus')</code> aruncă o excepție, vom scrie:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }).toThrow();
});
</code></pre>
<blockquote>
<p>Notă: Trebuie să îmbrăcați codul într-o funcţie, altfel eroarea nu va fi prinsă şi aserțiunea va eşua.</p>
</blockquote>
<p>You can provide an optional argument to test that a specific error is thrown:</p>
<ul>
<li>regular expression: error message <strong>matches</strong> the pattern</li>
<li>string: error message <strong>includes</strong> the substring</li>
<li>error object: error message is <strong>equal to</strong> the message property of the object</li>
<li>error class: error object is <strong>instance of</strong> class</li>
</ul>
<p>De exemplu, să presupunem că <code>drinkFlavor</code> este implementată în felul următor:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Do some other stuff</span>
}
</code></pre>
<p>Am putea testa în mai multe moduri că această eroare este aruncată:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  <span class="hljs-comment">// Test that the error message says "yuck" somewhere: these are equivalent</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-regexp">/yuck/</span>);
  expect(drinkOctopus).toThrowError(<span class="hljs-string">'yuck'</span>);

  <span class="hljs-comment">// Test the exact error message</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-regexp">/^yuck, octopus flavor$/</span>);
  expect(drinkOctopus).toThrowError(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'yuck, octopus flavor'</span>));

  <span class="hljs-comment">// Test that we get a DisgustingFlavorError</span>
  expect(drinkOctopus).toThrowError(DisgustingFlavorError);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tothrowerrormatchingsnapshothint"></a><a href="#tothrowerrormatchingsnapshothint" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrowErrorMatchingSnapshot(hint?)</code></h3>
<p>Utilizaţi <code>.toThrowErrorMatchingSnapshot</code> pentru a testa dacă o funcţie aruncă o eroare în timpul comparării cu cea mai recentă imagine, atunci când este apelată.</p>
<p>You can provide an optional <code>hint</code> string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate <strong>multiple</strong> snapshots in a <strong>single</strong> <code>it</code> or <code>test</code> block. Jest sorts snapshots by name in the corresponding <code>.snap</code> file.</p>
<p>De exemplu, să presupunem că aveţi o funcţie <code>drinkFlavor</code> care aruncă o excepție ori de câte ori aroma este <code>'octopus'</code>, şi este implementată în felul următor:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Do some other stuff</span>
}
</code></pre>
<p>Testul pentru această funcţie va arăta astfel:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  expect(drinkOctopus).toThrowErrorMatchingSnapshot();
});
</code></pre>
<p>Care va genera următoarea imagine:</p>
<pre><code class="hljs css language-js">exports[<span class="hljs-string">`drinking flavors throws on octopus 1`</span>] = <span class="hljs-string">`"yuck, octopus flavor"`</span>;
</code></pre>
<p>Vedeți <a href="https://jestjs.io/blog/2016/07/27/jest-14.html"> Testarea de imagine a arborilor React</a> pentru mai multe informaţii.</p>
<h3><a class="anchor" aria-hidden="true" id="tothrowerrormatchinginlinesnapshotinlinesnapshot"></a><a href="#tothrowerrormatchinginlinesnapshotinlinesnapshot" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrowErrorMatchingInlineSnapshot(inlineSnapshot)</code></h3>
<p>Use <code>.toThrowErrorMatchingInlineSnapshot</code> to test that a function throws an error matching the most recent snapshot when it is called.</p>
<p>Jest adds the <code>inlineSnapshot</code> string argument to the matcher in the test file (instead of an external <code>.snap</code> file) the first time that the test runs.</p>
<p>Check out the section on <a href="/docs/ro/26.5/snapshot-testing#inline-snapshots">Inline Snapshots</a> for more info.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ro/26.5/api"><span class="arrow-prev">← </span><span>Globals</span></a><a class="docs-next button" href="/docs/ro/26.5/mock-function-api"><span>Mock Functions</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#metode">Metode</a></li><li><a href="#referințe">Referințe</a><ul class="toc-headings"><li><a href="#expectvalue"><code>expect(value)</code></a></li><li><a href="#expectextendmatchers"><code>expect.extend(matchers)</code></a></li><li><a href="#expectanything"><code>expect.anything()</code></a></li><li><a href="#expectanyconstructor"><code>expect.any(constructor)</code></a></li><li><a href="#expectarraycontainingarray"><code>expect.arrayContaining(array)</code></a></li><li><a href="#expectassertionsnumber"><code>expect.assertions(number)</code></a></li><li><a href="#expecthasassertions"><code>expect.hasAssertions()</code></a></li><li><a href="#expectnotarraycontainingarray"><code>expect.not.arrayContaining(array)</code></a></li><li><a href="#expectnotobjectcontainingobject"><code>expect.not.objectContaining(object)</code></a></li><li><a href="#expectnotstringcontainingstring"><code>expect.not.stringContaining(string)</code></a></li><li><a href="#expectnotstringmatchingstring--regexp"><code>expect.not.stringMatching(string | regexp)</code></a></li><li><a href="#expectobjectcontainingobject"><code>expect.objectContaining(object)</code></a></li><li><a href="#expectstringcontainingstring"><code>expect.stringContaining(string)</code></a></li><li><a href="#expectstringmatchingstring--regexp"><code>expect.stringMatching(string | regexp)</code></a></li><li><a href="#expectaddsnapshotserializerserializer"><code>expect.addSnapshotSerializer(serializer)</code></a></li><li><a href="#not"><code>.not</code></a></li><li><a href="#resolves"><code>.resolves</code></a></li><li><a href="#rejects"><code>.rejects</code></a></li><li><a href="#tobevalue"><code>.toBe(value)</code></a></li><li><a href="#tohavebeencalled"><code>.toHaveBeenCalled()</code></a></li><li><a href="#tohavebeencalledtimesnumber"><code>.toHaveBeenCalledTimes(number)</code></a></li><li><a href="#tohavebeencalledwitharg1-arg2-"><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code></a></li><li><a href="#tohavebeenlastcalledwitharg1-arg2-"><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code></a></li><li><a href="#tohavebeennthcalledwithnthcall-arg1-arg2-"><code>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)</code></a></li><li><a href="#tohavereturned"><code>.toHaveReturned()</code></a></li><li><a href="#tohavereturnedtimesnumber"><code>.toHaveReturnedTimes(number)</code></a></li><li><a href="#tohavereturnedwithvalue"><code>.toHaveReturnedWith(value)</code></a></li><li><a href="#tohavelastreturnedwithvalue"><code>.toHaveLastReturnedWith(value)</code></a></li><li><a href="#tohaventhreturnedwithnthcall-value"><code>.toHaveNthReturnedWith(nthCall, value)</code></a></li><li><a href="#tohavelengthnumber"><code>.toHaveLength(number)</code></a></li><li><a href="#tohavepropertykeypath-value"><code>.toHaveProperty(keyPath, value?)</code></a></li><li><a href="#tobeclosetonumber-numdigits"><code>.toBeCloseTo(number, numDigits?)</code></a></li><li><a href="#tobedefined"><code>.toBeDefined()</code></a></li><li><a href="#tobefalsy"><code>.toBeFalsy()</code></a></li><li><a href="#tobegreaterthannumber--bigint"><code>.toBeGreaterThan(number | bigint)</code></a></li><li><a href="#tobegreaterthanorequalnumber--bigint"><code>.toBeGreaterThanOrEqual(number | bigint)</code></a></li><li><a href="#tobelessthannumber--bigint"><code>.toBeLessThan(number | bigint)</code></a></li><li><a href="#tobelessthanorequalnumber--bigint"><code>.toBeLessThanOrEqual(number | bigint)</code></a></li><li><a href="#tobeinstanceofclass"><code>.toBeInstanceOf(Class)</code></a></li><li><a href="#tobenull"><code>.toBeNull()</code></a></li><li><a href="#tobetruthy"><code>.toBeTruthy()</code></a></li><li><a href="#tobeundefined"><code>.toBeUndefined()</code></a></li><li><a href="#tobenan"><code>.toBeNaN()</code></a></li><li><a href="#tocontainitem"><code>.toContain(item)</code></a></li><li><a href="#tocontainequalitem"><code>.toContainEqual(item)</code></a></li><li><a href="#toequalvalue"><code>.toEqual(value)</code></a></li><li><a href="#tomatchregexporstring"><code>.toMatch(regexpOrString)</code></a></li><li><a href="#tomatchobjectobject"><code>.toMatchObject(object)</code></a></li><li><a href="#tomatchsnapshotpropertymatchers-hint"><code>.toMatchSnapshot(propertyMatchers?, hint?)</code></a></li><li><a href="#tomatchinlinesnapshotpropertymatchers-inlinesnapshot"><code>.toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)</code></a></li><li><a href="#tostrictequalvalue"><code>.toStrictEqual(value)</code></a></li><li><a href="#tothrowerror"><code>.toThrow(error?)</code></a></li><li><a href="#tothrowerrormatchingsnapshothint"><code>.toThrowErrorMatchingSnapshot(hint?)</code></a></li><li><a href="#tothrowerrormatchinginlinesnapshotinlinesnapshot"><code>.toThrowErrorMatchingInlineSnapshot(inlineSnapshot)</code></a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/ro/getting-started.html">Getting Started</a><a href="/docs/ro/snapshot-testing.html">Guides</a><a href="/docs/ro/api.html">API Reference</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://www.reactiflux.com/">Reactiflux</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star facebook/jest on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2020 Facebook Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:ro","version:26.5"]}
              });
            </script></body></html>