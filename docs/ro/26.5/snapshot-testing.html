<!DOCTYPE html><html lang="ro"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Snapshot Testing · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Testarea de imagine este un instrument foarte util, ori de câte ori doriţi să vă asiguraţi că interfaţa nu se schimbă în mod neaşteptat."/><meta name="docsearch:version" content="26.5"/><meta name="docsearch:language" content="ro"/><meta property="og:title" content="Snapshot Testing · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jestjs.io/"/><meta property="og:description" content="Testarea de imagine este un instrument foarte util, ori de câte ori doriţi să vă asiguraţi că interfaţa nu se schimbă în mod neaşteptat."/><meta property="og:image" content="https://jestjs.io/img/opengraph.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://jestjs.io/img/jest.png"/><link rel="shortcut icon" href="/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://jestjs.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://jestjs.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ro"><img class="logo" src="/img/jest.svg" alt="Jest"/><h2 class="headerTitleWithLogo">Jest</h2></a><a href="/ro/versions"><h3>26.5</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ro/26.5/getting-started" target="_self">Documentație</a></li><li class="siteNavGroupActive"><a href="/docs/ro/26.5/api" target="_self">API</a></li><li class=""><a href="/ro/help" target="_self">Ajutor</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Română</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/26.5/snapshot-testing">English</a></li><li><a href="/docs/ja/26.5/snapshot-testing">日本語</a></li><li><a href="/docs/es-ES/26.5/snapshot-testing">Español</a></li><li><a href="/docs/pt-BR/26.5/snapshot-testing">Português (Brasil)</a></li><li><a href="/docs/ru/26.5/snapshot-testing">Русский</a></li><li><a href="/docs/uk/26.5/snapshot-testing">Українська</a></li><li><a href="/docs/zh-Hans/26.5/snapshot-testing">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Guides</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/getting-started">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/using-matchers">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/asynchronous">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/setup-teardown">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/mock-functions">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/jest-platform">Jest Platform</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/jest-community">Jest Community</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/more-resources">More Resources</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Guides</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ro/26.5/snapshot-testing">Snapshot Testing</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/tutorial-async">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/timer-mocks">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/manual-mocks">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/es6-class-mocks">ES6 Class Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/bypassing-module-mocks">Bypassing module mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/ecmascript-modules">ECMAScript Modules</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/webpack">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/puppeteer">Using with puppeteer</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/mongodb">Using with MongoDB</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/dynamodb">Using with DynamoDB</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/tutorial-jquery">DOM Manipulation</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/watch-plugins">Watch Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/migration-guide">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/architecture">Architecture</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Framework Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/tutorial-react">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/tutorial-react-native">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/testing-frameworks">Testing Web Frameworks</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API Reference</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/api">Globals</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/expect">Expect</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/mock-function-api">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/jest-object">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/configuration">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/cli">Jest CLI Options</a></li><li class="navListItem"><a class="navItem" href="/docs/ro/26.5/environment-variables">Environment Variables</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/jest/edit/master/docs/SnapshotTesting.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Snapshot Testing</h1></header><article><div><span><p>Testarea de imagine este un instrument foarte util, ori de câte ori doriţi să vă asiguraţi că interfaţa nu se schimbă în mod neaşteptat.</p>
<p>A typical snapshot test case renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.</p>
<h2><a class="anchor" aria-hidden="true" id="testarea-de-imagine-cu-jest"></a><a href="#testarea-de-imagine-cu-jest" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Testarea de Imagine cu Jest</h2>
<p>O abordare similară se poate lua atunci când vine vorba de testarea componentelor React. În loc de randarea interfeței grafică, care ar necesita construirea întregii aplicații, puteţi utiliza un test de randare pentru a genera rapid o valoare serializabilă pentru arborele React. Consider this <a href="https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/link.react.test.js">example test</a> for a <a href="https://github.com/facebook/jest/blob/master/examples/snapshot/Link.react.js">Link component</a>:</p>
<pre><code class="hljs css language-tsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> renderer <span class="hljs-keyword">from</span> <span class="hljs-string">'react-test-renderer'</span>;
<span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">'../Link.react'</span>;

it(<span class="hljs-string">'renders correctly'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  const tree = renderer
    .create(&lt;Link page=<span class="hljs-string">"http://www.facebook.com"</span>&gt;Facebook&lt;/Link&gt;)
    .toJSON();
  expect(tree).toMatchSnapshot();
});
</code></pre>
<p>Prima dată când acest test se execută, Jest creează un <a href="https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/__snapshots__/link.react.test.js.snap">fişier imagine</a> care arată astfel:</p>
<pre><code class="hljs css language-javascript">exports[<span class="hljs-string">`renders correctly 1`</span>] = <span class="hljs-string">`
&lt;a
  className="normal"
  href="http://www.facebook.com"
  onMouseEnter={[Function]}
  onMouseLeave={[Function]}
&gt;
  Facebook
&lt;/a&gt;
`</span>;
</code></pre>
<p>Imaginea ar trebui să fie adăugată alături de modificările de cod, şi revizuite ca parte a procesului de code review. Jest utilizează <a href="https://github.com/facebook/jest/tree/master/packages/pretty-format">pretty-format</a> pentru face imaginile ușor de înţeles omului în timpul procesului de code review. On subsequent test runs, Jest will compare the rendered output with the previous snapshot. În cazul în care acestea se potrivesc, testul va trece. If they don't match, either the test runner found a bug in your code (in the <code>&lt;Link&gt;</code> component in this case) that should be fixed, or the implementation has changed and the snapshot needs to be updated.</p>
<blockquote>
<p>Note: The snapshot is directly scoped to the data you render – in our example the <code>&lt;Link /&gt;</code> component with <code>page</code> prop passed to it. This implies that even if any other file has missing props (Say, <code>App.js</code>) in the <code>&lt;Link /&gt;</code> component, it will still pass the test as the test doesn't know the usage of <code>&lt;Link /&gt;</code> component and it's scoped only to the <code>Link.react.js</code>. Also, Rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.</p>
</blockquote>
<p>Mai multe informaţii despre cum testarea de imagine funcţionează şi de ce am construit-o pot fi găsite pe <a href="https://jestjs.io/blog/2016/07/27/jest-14.html">blog</a>. Va recomandam să citiți <a href="http://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/">acest articol de blog</a> pentru a înțelege mai bine când ar trebui să utilizaţi testarea de imagine. De asemenea, recomandăm vizionarea acestui <a href="https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074">video egghead</a> despre testarea de imagine cu Jest.</p>
<h3><a class="anchor" aria-hidden="true" id="actualizarea-imaginilor"></a><a href="#actualizarea-imaginilor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Actualizarea imaginilor</h3>
<p>Este evident atunci când un test eșuează după ce s-a introdus un bug. Când se întâmplă, rezolvați problema și asigurați-vă că testele trec din nou. Acum, să vorbim însă despre cazul în care un test eșuează din cauza unei schimbări intenţionate în implementare.</p>
<p>O astfel de situaţie poate apărea în cazul în care schimbăm în mod intenţionat adresa componentei Link din exemplul nostru.</p>
<pre><code class="hljs css language-tsx">// Updated test case with a Link to a different address
it('renders correctly', () =&gt; {
  const tree = renderer
    .create(<span class="hljs-name">&lt;Link</span> page=<span class="hljs-string">"http://www.instagram.com"</span>&gt;Instagram&lt;/Link&gt;)
    .toJSON()<span class="hljs-comment">;</span>
  expect(<span class="hljs-name">tree</span>).toMatchSnapshot()<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p>În acest caz, Jest va afișa următoarele:</p>
<p><img src="/img/content/failedSnapshotTest.png" alt=""></p>
<p>Din moment ce am actualizat componenta noastre pentru a indica spre o altă adresă, este firesc să aşteptăm modificări în imaginea acestei componente. Test nostru de imagine eșuează deoarece imagine actualizată pentru componenta noastră nu mai corespunde cu imaginea de referință.</p>
<p>To resolve this, we will need to update our snapshot artifacts. You can run Jest with a flag that will tell it to re-generate snapshots:</p>
<pre><code class="hljs css language-bash">jest --updateSnapshot
</code></pre>
<p>Acceptați modificările executând comanda de mai sus. Puteţi utiliza, de asemenea, echivalentul <code>-u</code> pentru a regenera imaginile, dacă preferaţi. Aceasta va regenera imaginile de referință pentru toate testele de imagine. Daca am avea si alte teste de imagine eșuate din cauza unor bug-uri neintenţionate, va fi nevoie să rezolvăm bug-urile înainte de a regenera imaginile pentru a evita stocarea imaginilor cu comportament eronat.</p>
<p>Dacă doriţi să limitați testele pentru care se vor regenera imaginile, puteţi specifica o opțiune suplimentară <code>--testNamePattern</code> pentru a re-înregistra imaginile doar pentru acele teste care se potrivesc cu modelul specificat.</p>
<p>Puteţi încerca această funcţionalitate prin clonarea <a href="https://github.com/facebook/jest/tree/master/examples/snapshot">exemplului de imagine</a>, modificarea componentei <code>Link</code>, şi rularea Jest.</p>
<h3><a class="anchor" aria-hidden="true" id="interactive-snapshot-mode"></a><a href="#interactive-snapshot-mode" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interactive Snapshot Mode</h3>
<p>Failed snapshots can also be updated interactively in watch mode:</p>
<p><img src="/img/content/interactiveSnapshot.png" alt=""></p>
<p>Once you enter Interactive Snapshot Mode, Jest will step you through the failed snapshots one test at a time and give you the opportunity to review the failed output.</p>
<p>From here you can choose to update that snapshot or skip to the next:</p>
<p><img src="/img/content/interactiveSnapshotUpdate.gif" alt=""></p>
<p>Once you're finished, Jest will give you a summary before returning back to watch mode:</p>
<p><img src="/img/content/interactiveSnapshotDone.png" alt=""></p>
<h3><a class="anchor" aria-hidden="true" id="inline-snapshots"></a><a href="#inline-snapshots" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Inline Snapshots</h3>
<p>Inline snapshots behave identically to external snapshots (<code>.snap</code> files), except the snapshot values are written automatically back into the source code. This means you can get the benefits of automatically generated snapshots without having to switch to an external file to make sure the correct value was written.</p>
<blockquote>
<p>Inline snapshots are powered by <a href="https://prettier.io">Prettier</a>. To use inline snapshots you must have <code>prettier</code> installed in your project. Your Prettier configuration will be respected when writing to test files.</p>
<p>If you have <code>prettier</code> installed in a location where Jest can't find it, you can tell Jest how to find it using the <a href="/docs/ro/26.5/configuration#prettierpath-string"><code>&quot;prettierPath&quot;</code></a> configuration property.</p>
</blockquote>
<p><strong>Exemplu:</strong></p>
<p>First, you write a test, calling <code>.toMatchInlineSnapshot()</code> with no arguments:</p>
<pre><code class="hljs css language-tsx">it('renders correctly', () =&gt; {
  const tree = renderer
    .create(<span class="hljs-name">&lt;Link</span> page=<span class="hljs-string">"https://prettier.io"</span>&gt;Prettier&lt;/Link&gt;)
    .toJSON()<span class="hljs-comment">;</span>
  expect(<span class="hljs-name">tree</span>).toMatchInlineSnapshot()<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p>The next time you run Jest, <code>tree</code> will be evaluated, and a snapshot will be written as an argument to <code>toMatchInlineSnapshot</code>:</p>
<pre><code class="hljs css language-tsx">it('renders correctly', () =&gt; {
  const tree = renderer
    .create(<span class="hljs-name">&lt;Link</span> page=<span class="hljs-string">"https://prettier.io"</span>&gt;Prettier&lt;/Link&gt;)
    .toJSON()<span class="hljs-comment">;</span>
  expect(<span class="hljs-name">tree</span>).toMatchInlineSnapshot(`
&lt;a
  className=<span class="hljs-string">"normal"</span>
  href=<span class="hljs-string">"https://prettier.io"</span>
  onMouseEnter={[Function]}
  onMouseLeave={[Function]}
&gt;
  Prettier
&lt;/a&gt;
`)<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p>That's all there is to it! You can even update the snapshots with <code>--updateSnapshot</code> or using the <code>u</code> key in <code>--watch</code> mode.</p>
<h3><a class="anchor" aria-hidden="true" id="property-matchers"></a><a href="#property-matchers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Property Matchers</h3>
<p>Often there are fields in the object you want to snapshot which are generated (like IDs and Dates). If you try to snapshot these objects, they will force the snapshot to fail on every run:</p>
<pre><code class="hljs css language-javascript">it(<span class="hljs-string">'will fail every time'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> user = {
    <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">20</span>),
    <span class="hljs-attr">name</span>: <span class="hljs-string">'LeBron James'</span>,
  };

  expect(user).toMatchSnapshot();
});

<span class="hljs-comment">// Snapshot</span>
exports[<span class="hljs-string">`will fail every time 1`</span>] = <span class="hljs-string">`
Object {
  "createdAt": 2018-05-19T23:36:09.816Z,
  "id": 3,
  "name": "LeBron James",
}
`</span>;
</code></pre>
<p>For these cases, Jest allows providing an asymmetric matcher for any property. These matchers are checked before the snapshot is written or tested, and then saved to the snapshot file instead of the received value:</p>
<pre><code class="hljs css language-javascript">it(<span class="hljs-string">'will check the matchers and pass'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> user = {
    <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">20</span>),
    <span class="hljs-attr">name</span>: <span class="hljs-string">'LeBron James'</span>,
  };

  expect(user).toMatchSnapshot({
    <span class="hljs-attr">createdAt</span>: expect.any(<span class="hljs-built_in">Date</span>),
    <span class="hljs-attr">id</span>: expect.any(<span class="hljs-built_in">Number</span>),
  });
});

<span class="hljs-comment">// Snapshot</span>
exports[<span class="hljs-string">`will check the matchers and pass 1`</span>] = <span class="hljs-string">`
Object {
  "createdAt": Any&lt;Date&gt;,
  "id": Any&lt;Number&gt;,
  "name": "LeBron James",
}
`</span>;
</code></pre>
<p>Any given value that is not a matcher will be checked exactly and saved to the snapshot:</p>
<pre><code class="hljs css language-javascript">it(<span class="hljs-string">'will check the values and pass'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> user = {
    <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Bond... James Bond'</span>,
  };

  expect(user).toMatchSnapshot({
    <span class="hljs-attr">createdAt</span>: expect.any(<span class="hljs-built_in">Date</span>),
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Bond... James Bond'</span>,
  });
});

<span class="hljs-comment">// Snapshot</span>
exports[<span class="hljs-string">`will check the values and pass 1`</span>] = <span class="hljs-string">`
Object {
  "createdAt": Any&lt;Date&gt;,
  "name": 'Bond... James Bond',
}
`</span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="best-practices"></a><a href="#best-practices" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Best Practices</h2>
<p>Snapshots are a fantastic tool for identifying unexpected interface changes within your application – whether that interface is an API response, UI, logs, or error messages. As with any testing strategy, there are some best-practices you should be aware of, and guidelines you should follow, in order to use them effectively.</p>
<h3><a class="anchor" aria-hidden="true" id="1-treat-snapshots-as-code"></a><a href="#1-treat-snapshots-as-code" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. Treat snapshots as code</h3>
<p>Commit snapshots and review them as part of your regular code review process. This means treating snapshots as you would any other type of test or code in your project.</p>
<p>Ensure that your snapshots are readable by keeping them focused, short, and by using tools that enforce these stylistic conventions.</p>
<p>As mentioned previously, Jest uses <a href="https://yarnpkg.com/en/package/pretty-format"><code>pretty-format</code></a> to make snapshots human-readable, but you may find it useful to introduce additional tools, like <a href="https://yarnpkg.com/en/package/eslint-plugin-jest"><code>eslint-plugin-jest</code></a> with its <a href="https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md"><code>no-large-snapshots</code></a> option, or <a href="https://yarnpkg.com/en/package/snapshot-diff"><code>snapshot-diff</code></a> with its component snapshot comparison feature, to promote committing short, focused assertions.</p>
<p>The goal is to make it easy to review snapshots in pull requests, and fight against the habit of regenerating snapshots when test suites fail instead of examining the root causes of their failure.</p>
<h3><a class="anchor" aria-hidden="true" id="2-tests-should-be-deterministic"></a><a href="#2-tests-should-be-deterministic" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. Tests should be deterministic</h3>
<p>Testele voastre trebuie să fie deterministe. Running the same tests multiple times on a component that has not changed should produce the same results every time. Sunteți responsabili să vă asigurați ca imaginile generate nu includ cod specific unor platforme sau alte informatii non-deterministice.</p>
<p>De exemplu, dacă aveţi o componentă <a href="https://github.com/facebook/jest/blob/master/examples/snapshot/Clock.react.js">Clock</a> care utilizează <code>Date.now()</code>, imaginea generată pentru această componentă va fi diferită de fiecare dată când este rulat testul. În acest caz putem <a href="/docs/ro/26.5/mock-functions">dubla metoda Date.now()</a> pentru a returna o valoare consecventă de fiecare dată când se execută testul:</p>
<pre><code class="hljs css language-js"><span class="hljs-built_in">Date</span>.now = jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">1482363367071</span>);
</code></pre>
<p>Acum, de fiecare dată când se execută testul, <code>Date.now()</code> va returna <code>1482363367071</code> în mod constant. Acest lucru va conduce la aceaşi imagine generată pentru această componentă indiferent când s-ar executa testul.</p>
<h3><a class="anchor" aria-hidden="true" id="3-use-descriptive-snapshot-names"></a><a href="#3-use-descriptive-snapshot-names" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. Use descriptive snapshot names</h3>
<p>Always strive to use descriptive test and/or snapshot names for snapshots. The best names describe the expected snapshot content. This makes it easier for reviewers to verify the snapshots during review, and for anyone to know whether or not an outdated snapshot is the correct behavior before updating.</p>
<p>For example, compare:</p>
<pre><code class="hljs css language-js">exports[<span class="hljs-string">`&lt;UserName /&gt; should handle some test case`</span>] = <span class="hljs-string">`null`</span>;

exports[<span class="hljs-string">`&lt;UserName /&gt; should handle some other test case`</span>] = <span class="hljs-string">`
&lt;div&gt;
  Alan Turing
&lt;/div&gt;
`</span>;
</code></pre>
<p>To:</p>
<pre><code class="hljs css language-js">exports[<span class="hljs-string">`&lt;UserName /&gt; should render null`</span>] = <span class="hljs-string">`null`</span>;

exports[<span class="hljs-string">`&lt;UserName /&gt; should render Alan Turing`</span>] = <span class="hljs-string">`
&lt;div&gt;
  Alan Turing
&lt;/div&gt;
`</span>;
</code></pre>
<p>Since the later describes exactly what's expected in the output, it's more clear to see when it's wrong:</p>
<pre><code class="hljs css language-js">exports[<span class="hljs-string">`&lt;UserName /&gt; should render null`</span>] = <span class="hljs-string">`
&lt;div&gt;
  Alan Turing
&lt;/div&gt;
`</span>;

exports[<span class="hljs-string">`&lt;UserName /&gt; should render Alan Turing`</span>] = <span class="hljs-string">`null`</span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="întrebări-frecvente"></a><a href="#întrebări-frecvente" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Întrebări frecvente</h2>
<h3><a class="anchor" aria-hidden="true" id="are-snapshots-written-automatically-on-continuous-integration-ci-systems"></a><a href="#are-snapshots-written-automatically-on-continuous-integration-ci-systems" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Are snapshots written automatically on Continuous Integration (CI) systems?</h3>
<p>No, as of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing <code>--updateSnapshot</code>. Este de aşteptat ca toate imaginile fac parte din codul care se execută pe CI şi deoarece noi imagini ar trece automat testele, ele nu ar trebui să treacă testele rulate pe un sistem de CI. Este recomandat să se commit-uie întotdeauna toate imaginile pentru a fi menţinute în sistemul de versionare.</p>
<h3><a class="anchor" aria-hidden="true" id="ar-trebui-commit-uite-imaginile-serializate"></a><a href="#ar-trebui-commit-uite-imaginile-serializate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ar trebui commit-uite imaginile serializate?</h3>
<p>Da, toate fişierele de imagine ar trebui să fie commit-uite alături de module pe care le acoperă şi testele lor. They should be considered part of a test, similar to the value of any other assertion in Jest. De fapt, imaginile reprezintă starea modulelor sursă la un anumit moment. În acest fel, atunci când modulele sursă sunt modificate, Jest poate spune ce anume s-a schimbat de la versiunea anterioară. Acesta poate oferi și context suplimentar în timpul code review-ului în care recenzenţii pot studia mai bine modificările.</p>
<h3><a class="anchor" aria-hidden="true" id="testarea-de-imagine-funcționeaza-numai-cu-componente-react"></a><a href="#testarea-de-imagine-funcționeaza-numai-cu-componente-react" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Testarea de imagine funcționeaza numai cu componente React?</h3>
<p><a href="/docs/ro/26.5/tutorial-react">React</a> and <a href="/docs/ro/26.5/tutorial-react-native">React Native</a> components are a good use case for snapshot testing. Cu toate acestea, imaginile pot captura orice valoare serializabilă şi ar trebui utilizate oricând doriți să testați dacă rezultatul este corect. Proiectul Jest conţine multe exemple de testare Jest, rezultatul librăriei de aserțiuni Jest, precum şi loguri din diferite părţi ale codului Jest. Vedeți un exemplu de <a href="https://github.com/facebook/jest/blob/master/e2e/__tests__/console.test.ts">testarea de imagine a consolei</a> în proiectul Jest.</p>
<h3><a class="anchor" aria-hidden="true" id="care-este-diferenţa-între-testarea-de-imagine-şi-testarea-vizuală-de-regresii"></a><a href="#care-este-diferenţa-între-testarea-de-imagine-şi-testarea-vizuală-de-regresii" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Care este diferenţa între testarea de imagine şi testarea vizuală de regresii?</h3>
<p>Testarea de imagine şi testarea vizuală de regresii sunt două moduri distincte de testare a interfețelor UI, şi ele servesc scopuri diferite. Instrumentele de testare vizuală fac capturi de ecran ale paginilor web şi compară imaginile rezultate pixel cu pixel. With Snapshot testing values are serialized, stored within text files, and compared using a diff algorithm. There are different trade-offs to consider and we listed the reasons why snapshot testing was built in the <a href="https://jestjs.io/blog/2016/07/27/jest-14.html#why-snapshot-testing">Jest blog</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="does-snapshot-testing-replace-unit-testing"></a><a href="#does-snapshot-testing-replace-unit-testing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Does snapshot testing replace unit testing?</h3>
<p>Testarea de imagine este doar una dintre cele peste 20 asserțiuni, care sunt livrate cu Jest. The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. În unele scenarii, testarea de imagine ar putea elimina nevoia de teste unitare pentru un anumit set de functionalitati (ex. componente React), însă ele pot funcționa la fel de bine împreună.</p>
<h3><a class="anchor" aria-hidden="true" id="care-este-performanţa-testelor-de-imagine-în-ceea-ce-priveşte-viteza-şi-dimensiunea-fişierelor-generate"></a><a href="#care-este-performanţa-testelor-de-imagine-în-ceea-ce-priveşte-viteza-şi-dimensiunea-fişierelor-generate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Care este performanţa testelor de imagine în ceea ce priveşte viteza şi dimensiunea fişierelor generate?</h3>
<p>Jest a fost rescris având performanţa în prim plan, şi testarea de imagine nu face nicio excepţie. Deoarece imaginile sunt stocate în fişiere text, modul acesta de testare este rapid şi de încredere. Jest generează câte un fişier pentru fiecare fişier de test, care invocă metoda <code>toMatchSnapshot</code>. The size of the snapshots is pretty small: For reference, the size of all snapshot files in the Jest codebase itself is less than 300 KB.</p>
<h3><a class="anchor" aria-hidden="true" id="cum-rezolv-conflictele-în-cadrul-fişierelor-de-imagine"></a><a href="#cum-rezolv-conflictele-în-cadrul-fişierelor-de-imagine" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cum rezolv conflictele în cadrul fişierelor de imagine?</h3>
<p>Fişierele imagine trebuie să reprezinte întotdeauna starea actuală a modulelor pe care le acoperă. Therefore, if you are merging two branches and encounter a conflict in the snapshot files, you can either resolve the conflict manually or update the snapshot file by running Jest and inspecting the result.</p>
<h3><a class="anchor" aria-hidden="true" id="este-posibil-să-se-aplice-principiile-de-test-driven-development-în-testarea-de-imagine"></a><a href="#este-posibil-să-se-aplice-principiile-de-test-driven-development-în-testarea-de-imagine" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Este posibil să se aplice principiile de test-driven development în testarea de imagine?</h3>
<p>Deşi este posibil să se scrie manual fişierele de imagine, de obicei nu este o metodă abordabilă. Snapshots help to figure out whether the output of the modules covered by tests is changed, rather than giving guidance to design the code in the first place.</p>
<h3><a class="anchor" aria-hidden="true" id="does-code-coverage-work-with-snapshot-testing"></a><a href="#does-code-coverage-work-with-snapshot-testing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Does code coverage work with snapshot testing?</h3>
<p>Yes, as well as with any other test.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ro/26.5/more-resources"><span class="arrow-prev">← </span><span>More Resources</span></a><a class="docs-next button" href="/docs/ro/26.5/tutorial-async"><span>An Async Example</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#testarea-de-imagine-cu-jest">Testarea de Imagine cu Jest</a><ul class="toc-headings"><li><a href="#actualizarea-imaginilor">Actualizarea imaginilor</a></li><li><a href="#interactive-snapshot-mode">Interactive Snapshot Mode</a></li><li><a href="#inline-snapshots">Inline Snapshots</a></li><li><a href="#property-matchers">Property Matchers</a></li></ul></li><li><a href="#best-practices">Best Practices</a><ul class="toc-headings"><li><a href="#1-treat-snapshots-as-code">1. Treat snapshots as code</a></li><li><a href="#2-tests-should-be-deterministic">2. Tests should be deterministic</a></li><li><a href="#3-use-descriptive-snapshot-names">3. Use descriptive snapshot names</a></li></ul></li><li><a href="#întrebări-frecvente">Întrebări frecvente</a><ul class="toc-headings"><li><a href="#are-snapshots-written-automatically-on-continuous-integration-ci-systems">Are snapshots written automatically on Continuous Integration (CI) systems?</a></li><li><a href="#ar-trebui-commit-uite-imaginile-serializate">Ar trebui commit-uite imaginile serializate?</a></li><li><a href="#testarea-de-imagine-funcționeaza-numai-cu-componente-react">Testarea de imagine funcționeaza numai cu componente React?</a></li><li><a href="#care-este-diferenţa-între-testarea-de-imagine-şi-testarea-vizuală-de-regresii">Care este diferenţa între testarea de imagine şi testarea vizuală de regresii?</a></li><li><a href="#does-snapshot-testing-replace-unit-testing">Does snapshot testing replace unit testing?</a></li><li><a href="#care-este-performanţa-testelor-de-imagine-în-ceea-ce-priveşte-viteza-şi-dimensiunea-fişierelor-generate">Care este performanţa testelor de imagine în ceea ce priveşte viteza şi dimensiunea fişierelor generate?</a></li><li><a href="#cum-rezolv-conflictele-în-cadrul-fişierelor-de-imagine">Cum rezolv conflictele în cadrul fişierelor de imagine?</a></li><li><a href="#este-posibil-să-se-aplice-principiile-de-test-driven-development-în-testarea-de-imagine">Este posibil să se aplice principiile de test-driven development în testarea de imagine?</a></li><li><a href="#does-code-coverage-work-with-snapshot-testing">Does code coverage work with snapshot testing?</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/ro/getting-started.html">Getting Started</a><a href="/docs/ro/snapshot-testing.html">Guides</a><a href="/docs/ro/api.html">API Reference</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discord.gg/j6FKKQQrW9">Reactiflux</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star facebook/jest on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2021 Facebook Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:ro","version:26.5"]}
              });
            </script></body></html>