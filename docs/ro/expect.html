<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Expect · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Expect · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="Atunci când scrieți teste, adesea trebuie să verificaţi dacă valorile îndeplinesc anumite condiţii. `expect` vă oferă acces la numeroși &quot;validatori&quot;, care vă permit să validați diferite lucruri."/><meta property="og:image" content="/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="/jest/css/main.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/ro/getting-started.html" target="_self">Documentație</a></li><li><a href="/jest/docs/ro/api.html" target="_self">API</a></li><li><a href="/jest/ro/help.html" target="_self">Ajutor</a></li><li><a href="/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Română</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/es-ES">Español</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/api.html">Globals</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/ro/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/cli.html">Jest CLI Options</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ro/snapshot-testing.html">Testarea de imagine</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ro/troubleshooting.html">Troubleshooting</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Expect</h1></header><article><div><span><p>Atunci când scrieți teste, adesea trebuie să verificaţi dacă valorile îndeplinesc anumite condiţii. <code>expect</code> vă oferă acces la numeroși &quot;validatori&quot;, care vă permit să validați diferite lucruri.</p>
<h2><a class="anchor" name="metode"></a>Metode <a class="hash-link" href="#metode">#</a></h2>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" name="referin-e"></a>Referințe <a class="hash-link" href="#referin-e">#</a></h2>
<h3><a class="anchor" name="expectvalue"></a><code>expect(value)</code> <a class="hash-link" href="#expectvalue">#</a></h3>
<p>Funcţia <code>expect</code> este folosită de fiecare dată când vrei să testezi o valoare. Foarte rar vei apela <code>expect</code> de una singură. În schimb, vei folosi <code>expect</code> împreună cu funcție de &quot;comparare&quot; pentru a pretinde ceva despre o valoare.</p>
<p>Este mai uşor de înţeles acest lucru printr-un exemplu. Să presupunem că aveţi o metodă <code>bestLaCroixFlavor()</code> care ar trebui să returneze <code>'grapefruit'</code>. Iată cum ai testa acest lucru:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best flavor is grapefruit'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).toBe(<span class="hljs-string">'grapefruit'</span>);
});
</code></pre>
<p>În acest caz, <code>toBe</code> este funcţia comparator. Există o mulţime de astfel de funcţii, documentate mai jos, pentru a vă ajuta să testaţi diferite lucruri.</p>
<p>Argumentul funcției <code>expect</code> trebuie să fie valoarea care produce codul şi orice argument pentru funcția comparator ar trebui să fie valoarea corectă. Dacă le amestecați, testele vor funcţiona în continuare, dar mesajele de eroare pentru testele eșuate vor arăta ciudat.</p>
<h3><a class="anchor" name="expectextendmatchers"></a><code>expect.extend(matchers)</code> <a class="hash-link" href="#expectextendmatchers">#</a></h3>
<p>Utilizaţi <code>expect.extend</code> pentru a adăuga proprii comparatorii. De exemplu, să presupunem că testați o librărie de teoria numerelor şi trebuie să verificați frecvent că numerele sunt divizibile cu alte numere. Ai putea abstractiza această logică într-un comparator <code>toBeDivisibleBy</code>:</p>
<pre><code class="language-js">expect.extend({
  toBeDivisibleBy(received, argument) {
    <span class="hljs-keyword">const</span> pass = (received % argument == <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> not to be divisible by <span class="hljs-subst">${argument}</span>`</span>
        ),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (<span class="hljs-string">`expected <span class="hljs-subst">${received}</span> to be divisible by <span class="hljs-subst">${argument}</span>`</span>),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'even and odd numbers'</span>, () =&gt; {
  expect(<span class="hljs-number">100</span>).toBeDivisibleBy(<span class="hljs-number">2</span>);
  expect(<span class="hljs-number">101</span>).not.toBeDivisibleBy(<span class="hljs-number">2</span>);
});
</code></pre>
<p>Comparatorii ar trebui să returneze un obiect cu două proprietăți. <code>pass</code> indică dacă a fost o potrivire sau nu, şi <code>message</code> oferă o funcţie fără argumente care returnează un mesaj de eroare în caz de eşec. Astfel, atunci când <code>pass</code> este fals, <code>message</code> trebuie să returneze mesajul de eroare pentru atunci când <code>expect(x).yourMatcher()</code> eșuează. Iar când <code>pass</code> este adevărat, <code>message</code> trebuie să returneze mesajul de eroare pentru atunci când <code>expect(x).not.yourMatcher()</code> eșuează.</p>
<p>Aceste funcţii ajutătoare pot fi găsite pe <code>this</code> în interiorul unui comparator personalizat:</p>
<h4><a class="anchor" name="thisisnot"></a><code>this.isNot</code> <a class="hash-link" href="#thisisnot">#</a></h4>
<p>Un boolean care vă spune dacă comparatorul a fost chemat cu modificatorul de negație <code>.not</code> permiţându-vă să inversați afirmaţia.</p>
<h4><a class="anchor" name="thisequalsa-b"></a><code>this.equals(a, b)</code> <a class="hash-link" href="#thisequalsa-b">#</a></h4>
<p>Aceasta este o funcţie de egalitate-în-adâncime, care va returna <code>true</code> dacă două obiecte au aceleaşi valori (recursiv).</p>
<h4><a class="anchor" name="thisutils"></a><code>this.utils</code> <a class="hash-link" href="#thisutils">#</a></h4>
<p>Există o serie de instrumente utile expuse în <code>this.utils</code> în principal constând din exporturile din <a href="https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils"> <code>jest-matcher-utils</code></a>.</p>
<p>Cele mai utile sunt <code>matcherHint</code>, <code>printExpected</code> şi <code>printReceived</code> pentru a formata frumos mesajele de eroare. De exemplu, să aruncăm o privire asupra implementării pentru <code>toBe</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> diff = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-diff'</span>);
expect.extend({
  toBe(received, expected) {
    <span class="hljs-keyword">const</span> pass = received === expected;

    <span class="hljs-keyword">const</span> message = pass
      ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.not.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to not be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>
      : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> diffString = diff(expected, received, {
          <span class="hljs-attr">expand</span>: <span class="hljs-keyword">this</span>.expand,
        });
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span> +
        (diffString ? <span class="hljs-string">`\n\nDifference:\n\n<span class="hljs-subst">${diffString}</span>`</span> : <span class="hljs-string">''</span>);
      };

    <span class="hljs-keyword">return</span> {<span class="hljs-attr">actual</span>: received, message, pass};
  },
});
</code></pre>
<p>Acest lucru va afișa ceva similar:</p>
<pre><code>  expect(received).toBe(expected)

    Expected value to be (using ===):
      &quot;banana&quot;
    Received:
      &quot;apple&quot;
</code></pre>
<p>Atunci când o aserţiune eșuează, mesajul de eroare ar trebui să dea detalii suficiente pentru utilizator, astfel încât ei poată rezolva problema rapid. Ar trebui să construiți mesaje de eroare precise pentru a vă asigura că utilizatorii de aserțiunilor voastre au o experienţă bună.</p>
<h3><a class="anchor" name="expectanything"></a><code>expect.anything()</code> <a class="hash-link" href="#expectanything">#</a></h3>
<p><code>expect.anything()</code> validează orice, mai putin <code>null</code> sau <code>undefined</code>. Îl puteţi folosi în interiorul lui <code>toEqual</code> sau <code>toBeCalledWith</code> în locul unei valori concrete. De exemplu, dacă doriţi să verificaţi că o dublură a fost apelată cu un argument non-null:</p>
<pre><code class="language-js">test(<span class="hljs-string">'map calls its argument with a non-null argument'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  [<span class="hljs-number">1</span>].map(mock);
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h3><a class="anchor" name="expectanyconstructor"></a><code>expect.any(constructor)</code> <a class="hash-link" href="#expectanyconstructor">#</a></h3>
<p><code>expect.any(constructor)</code> validează orice obiect creat cu constructorul dat. Îl puteţi folosi în interiorul lui <code>toEqual</code> sau <code>toBeCalledWith</code> în locul unei valori concrete. De exemplu, dacă doriţi să verificaţi că o dublură a fost apelată cu un număr:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randocall</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> fn(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>));
}

test(<span class="hljs-string">'randocall calls its callback with a number'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(<span class="hljs-built_in">Number</span>));
});
</code></pre>
<h3><a class="anchor" name="expectarraycontainingarray"></a><code>expect.arrayContaining(array)</code> <a class="hash-link" href="#expectarraycontainingarray">#</a></h3>
<p><code>expect.arrayContaining(array)</code> validează o listă care conţine toate elementele din lista pasată. Adică, lista presupusă este un <strong>subset</strong> al listei primite. Prin urmare, validează o listă care conţine elemente care <strong>nu</strong> fac parte din lista aşteptată.</p>
<p>Îl puteţi folosi în locul unei valori concrete:</p>
<ul>
<li>în <code>toEqual</code> sau <code>toBeCalledWith</code></li>
<li>pentru a valida o proprietate în <code>objectContaining</code> sau <code>toMatchObject</code></li>
</ul>
<pre><code class="language-js">describe(<span class="hljs-string">'arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'Beware of a misunderstanding! A sequence of dice rolls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  it(<span class="hljs-string">'matches even with an unexpected number 7'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match without an expected number 2'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" name="expectassertionsnumber"></a><code>expect.assertions(number)</code> <a class="hash-link" href="#expectassertionsnumber">#</a></h3>
<p><code>expect.assertions(number)</code> verifică dacă un anumit număr de aserțiuni au fost apelate în timpul unui test. Acest lucru este adesea util când testăm cod asincron, pentru a ne asigura că aserțiunile dintr-un callback chiar sunt apelate.</p>
<p>De exemplu, să presupunem că avem o funcţie <code>doAsync</code> care primeşte două callback-uri <code>callback1</code> şi <code>callback2</code>, care vor fi apelate asincron într-o ordine necunoscută. Putem testa acest lucru în felul următor:</p>
<pre><code class="language-js">test(<span class="hljs-string">'doAsync calls both callbacks'</span>, () =&gt; {
  expect.assertions(<span class="hljs-number">2</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p>Apelul <code>expect.assertions(2)</code> asigură că ambele callback-uri au fost apelate.</p>
<h3><a class="anchor" name="expecthasassertions"></a><code>expect.hasAssertions()</code> <a class="hash-link" href="#expecthasassertions">#</a></h3>
<p><code>expect.hasAssertions()</code> verifică dacă cel puțin o aserțiune a fost apelată în timpul unui test. Acest lucru este adesea util când testăm cod asincron, pentru a ne asigura că aserțiunile dintr-un callback chiar sunt apelate.</p>
<p>De exemplu, să spunem că avem câteva funcţii care se ocupă toate de stare. <code>prepareState</code> apelează un callback cu un obiect de stare, <code>validateState</code> ruleaza pe acel obiect de stare şi <code>waitOnState</code> returnează o promisiune care aşteaptă până când toate callback-urile <code>prepareState</code> se termină. Putem testa acest lucru în felul următor:</p>
<pre><code class="language-js">test(<span class="hljs-string">'prepareState prepares a valid state'</span>, () =&gt; {
  expect.hasAssertions();
  prepareState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    expect(validateState(state)).toBeTruthy();
  });
  <span class="hljs-keyword">return</span> waitOnState();
});
</code></pre>
<p>Apelul <code>expect.hasAssertions()</code> ne asigură că <code>prepareState</code> este apelat.</p>
<h3><a class="anchor" name="expectobjectcontainingobject"></a><code>expect.objectContaining(object)</code> <a class="hash-link" href="#expectobjectcontainingobject">#</a></h3>
<p><code>expect.objectContaining(object)</code> validează orice obiect primit care conține în mod recursiv proprietăţile aşteptate. Adică, obiectul asteptat este un <strong>subset</strong> al obiectului primit. Prin urmare, validează un obiect primit care conţine proprietăți care <strong>nu</strong> fac parte din obiectul aşteptat.</p>
<p>În loc de valori literale în obiectul aşteptat, puteţi utiliza validatori, <code>expect.anything()</code>, şi aşa mai departe.</p>
<p>De exemplu, să presupunem că ne aşteptăm ca o funcţie <code>onPress</code> să fie apelată cu un obiect de tip <code>Event</code>, şi tot ce avem nevoie să verificăm este că evenimentul are proprietățile <code>event.x</code> și <code>event.y</code>. Putem testa acest lucru în felul următor:</p>
<pre><code class="language-js">test(<span class="hljs-string">'onPress gets called with the right thing'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(expect.objectContaining({
    <span class="hljs-attr">x</span>: expect.any(<span class="hljs-built_in">Number</span>),
    <span class="hljs-attr">y</span>: expect.any(<span class="hljs-built_in">Number</span>),
  }));
});
</code></pre>
<h3><a class="anchor" name="expectstringcontainingstring"></a><code>expect.stringContaining(string)</code> <a class="hash-link" href="#expectstringcontainingstring">#</a></h3>
<h5><a class="anchor" name="disponibil-in-jest-1900"></a>disponibil în Jest <strong>19.0.0+</strong> <a class="hash-link" href="#disponibil-in-jest-1900">#</a></h5>
<p><code>expect.stringContaining(string)</code> validează orice şir de caractere care conţine exact şirul aşteptat.</p>
<h3><a class="anchor" name="expectstringmatchingregexp"></a><code>expect.stringMatching(regexp)</code> <a class="hash-link" href="#expectstringmatchingregexp">#</a></h3>
<p><code>expect.stringMatching(string)</code> validează orice şir de caractere care respectă o anumită expresie regulată.</p>
<p>Îl puteţi folosi în locul unei valori concrete:</p>
<ul>
<li>în <code>toEqual</code> sau <code>toBeCalledWith</code></li>
<li>pentru a valida un element în <code>arrayContaining</code></li>
<li>pentru a valida o proprietate în <code>objectContaining</code> sau <code>toMatchObject</code></li>
</ul>
<p>Acest exemplu arată cum puteţi imbrica mai mulți validatori asimetrici, cu <code>expect.stringMatching</code> în interiorul unui <code>expect.arrayContaining</code>.</p>
<pre><code class="language-js">describe(<span class="hljs-string">'stringMatching in arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [
    expect.stringMatching(<span class="hljs-regexp">/^Alic/</span>),
    expect.stringMatching(<span class="hljs-regexp">/^[BR]ob/</span>),
  ];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alicia'</span>, <span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" name="expectaddsnapshotserializerserializer"></a><code>expect.addSnapshotSerializer(serializer)</code> <a class="hash-link" href="#expectaddsnapshotserializerserializer">#</a></h3>
<p>Puteţi apela <code>expect.addSnapshotSerializer</code> pentru a adăuga un modul care formatează structuri de date specifice aplicaţiei.</p>
<p>Pentru un fişier de individual test, un modul suplimentar precede orice module din configurarea <code>snapshotSerializers</code>, care precedă la rândul lor serializatoarele implicite pentru tipurile JavaScript şi elemente React. Ultimul modul adăugat este primul testat.</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> serializer <span class="hljs-keyword">from</span> <span class="hljs-string">'my-serializer-module'</span>;
expect.addSnapshotSerializer(serializer);

<span class="hljs-comment">// affects expect(value).toMatchSnapshot() assertions in the test file</span>
</code></pre>
<p>Dacă adăugați un serializator în fişiere individuale de test în loc să-l adăugați în configurarea <code>snapshotSerializers</code>:</p>
<ul>
<li>Definiți explicit dependenţa în loc de implicit.</li>
<li>Evitați limitele de configurare care v-ar putea forța să faceți &quot;eject&quot; din <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>.</li>
</ul>
<p>See <a href="/jest/docs/ro/configuration.html#snapshotserializers-array-string">configuring Jest</a> for more information.</p>
<h3><a class="anchor" name="not"></a><code>.not</code> <a class="hash-link" href="#not">#</a></h3>
<p>Dacă știți cum să testați ceva, <code>.not</code> vă permite să testaţi opusul său. De exemplu, acest cod testează că cel mai bun gust La Croix nu este de nucă de cocos:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best flavor is not coconut'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).not.toBe(<span class="hljs-string">'coconut'</span>);
});
</code></pre>
<h3><a class="anchor" name="resolves"></a><code>.resolves</code> <a class="hash-link" href="#resolves">#</a></h3>
<h5><a class="anchor" name="disponibil-in-jest-2000"></a>disponibil în Jest <strong>20.0.0+</strong> <a class="hash-link" href="#disponibil-in-jest-2000">#</a></h5>
<p>Utilizaţi <code>resolves</code> pentru a desface valoarea unei promisiuni împlinite, astfel încât pot fi înlănțuiți alți validatori. În cazul în care promisiunea este respinsă, afirmaţia va eșua.</p>
<p>De exemplu, acest cod testează că promisiunea se rezolvă şi că valoarea rezultată este <code>'lemon'</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'resolves to lemon'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
});
</code></pre>
<p>Alternativ, puteţi utiliza <code>async/await</code> în combinaţie cu <code>.resolves</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'resolves to lemon'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.not.toBe(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" name="rejects"></a><code>.rejects</code> <a class="hash-link" href="#rejects">#</a></h3>
<h5><a class="anchor" name="disponibil-in-jest-2000"></a>disponibil în Jest <strong>20.0.0+</strong> <a class="hash-link" href="#disponibil-in-jest-2000">#</a></h5>
<p>Utilizaţi <code>.rejects</code> pentru a desface valoarea unei promisiuni împlinite, astfel încât pot fi înlănțuiți alți validatori. În cazul în care promisiunea este împlinită, afirmaţia va eșua.</p>
<p>De exemplu, acest cod testează că promisiunea este respinsă cu un motiv:</p>
<pre><code class="language-js">test(<span class="hljs-string">'fetchData() rejects to be error'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'octopus'</span>)).rejects.toBeDefined();
});
</code></pre>
<p>Alternativ, puteţi utiliza <code>async/await</code> în combinaţie cu <code>.rejects</code>. În plus, acest cod testează că rezultatul returnat include 'octopus':</p>
<pre><code class="language-js">test(<span class="hljs-string">'fetchData() rejects to be error'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> drinkOctopus = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  });

  <span class="hljs-keyword">await</span> expect(drinkOctopus).rejects.toMatch(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobevalue"></a><code>.toBe(value)</code> <a class="hash-link" href="#tobevalue">#</a></h3>
<p><code>toBe</code> doar verifică dacă o valoare este ceea ce vă aşteptaţi să fie. Acesta utilizează <code>===</code> pentru verificarea egalității stricte.</p>
<p>De exemplu, acest cod va valida unele proprietăţi ale obiectului <code>can</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> can = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'pamplemousse'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the can'</span>, () =&gt; {
  test(<span class="hljs-string">'has 12 ounces'</span>, () =&gt; {
    expect(can.ounces).toBe(<span class="hljs-number">12</span>);
  });

  test(<span class="hljs-string">'has a sophisticated name'</span>, () =&gt; {
    expect(can.name).toBe(<span class="hljs-string">'pamplemousse'</span>);
  });
});
</code></pre>
<p>Nu utilizaţi <code>toBe</code> cu numere cu virgulă mobilă. De exemplu, din cauza rotunjirilor, în JavaScript <code>0.2 + 0.1</code> nu este strict egal cu <code>0.3</code>. Dacă aveţi numerele cu virgulă mobilă, încercaţi <code>.toBeCloseTo</code> în schimb.</p>
<h3><a class="anchor" name="tohavebeencalled"></a><code>.toHaveBeenCalled()</code> <a class="hash-link" href="#tohavebeencalled">#</a></h3>
<p>Există și cu aliasul: <code>.toBeCalled()</code></p>
<p>Utilizaţi <code>.toHaveBeenCalled</code> pentru a vă asigura că o funcţie mock a fost apelată.</p>
<p>De exemplu, să spunem că avem o funcţie <code>drinkAll(drink, flavor)</code>, care primește o funcţie <code>drink</code> pe care o aplică tuturor băuturilor disponibile. Aţi putea verifica faptul că <code>drink</code> este apelată pentru <code>'lemon'</code>, dar nu pentru <code>'octopus'</code>. Se poate face asta cu următorul test:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'drinkAll'</span>, () =&gt; {
  test(<span class="hljs-string">'drinks something lemon-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'lemon'</span>);
    expect(drink).toHaveBeenCalled();
  });

  test(<span class="hljs-string">'does not drink something octopus-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'octopus'</span>);
    expect(drink).not.toHaveBeenCalled();
  });
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledtimesnumber"></a><code>.toHaveBeenCalledTimes(number)</code> <a class="hash-link" href="#tohavebeencalledtimesnumber">#</a></h3>
<p>Utilizaţi <code>. toHaveBeenCalledTimes</code> pentru a vă asigura că o funcţie mock a fost apelată de un anumit număr de ori.</p>
<p>De exemplu, să presupunem că avem o funcţie <code>drinkEach(drink, Array&lt;flavor&gt;)</code>, care primește o funcţie <code>drink</code> pe care o aplică tuturor băuturilor primite. Aţi putea verifica faptul că funcţia a fost apelată de un număr exact de ori. Se poate face asta cu următorul test:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinkEach drinks each drink'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  drinkEach(drink, [<span class="hljs-string">'lemon'</span>, <span class="hljs-string">'octopus'</span>]);
  expect(drink).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledwitharg1-arg2-"></a><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeencalledwitharg1-arg2-">#</a></h3>
<p>Există și cu aliasul: <code>.toBeCalledWith()</code></p>
<p>Utilizaţi <code>.toHaveBeenCalledWith</code> pentru a vă asigura că o funcţie mock a fost apelată cu niște argumente specifice.</p>
<p>De exemplu, să spunem că puteţi înregistra o băutură cu funcție <code>register</code>, şi <code>applyToAll(f)</code> ar trebui să aplice funcția <code>f</code> tuturor băuturilor înregistrate. Pentru a vă asigura că aceasta funcţionează, ați putea scrie:</p>
<pre><code class="language-js">test(<span class="hljs-string">'registration applies correctly to orange La Croix'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage = <span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'orange'</span>);
  register(beverage);
  <span class="hljs-keyword">const</span> f = jest.fn();
  applyToAll(f);
  expect(f).toHaveBeenCalledWith(beverage);
});
</code></pre>
<h3><a class="anchor" name="tohavebeenlastcalledwitharg1-arg2-"></a><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeenlastcalledwitharg1-arg2-">#</a></h3>
<p>Există și cu aliasul: <code>.lastCalledWith(arg1, arg2, ...)</code></p>
<p>Dacă aveţi o funcţie mock, puteţi utiliza <code>.toHaveBeenLastCalledWith</code> pentru a testa cu ce argumente a fost apelată ultima dată. De exemplu, să presupunem că aveţi o funcţie <code>applyToAllFlavors(f)</code>, care aplică <code>f</code> la o grămadă de arome, şi doriţi să vă asiguraţi că, atunci când o apelați, ultima aromă cu care operează este <code>'mango'</code>. Puteţi scrie:</p>
<pre><code class="language-js">test(<span class="hljs-string">'applying to all flavors does mango last'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  applyToAllFlavors(drink);
  expect(drink).toHaveBeenLastCalledWith(<span class="hljs-string">'mango'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeclosetonumber-numdigits"></a><code>.toBeCloseTo(number, numDigits)</code> <a class="hash-link" href="#tobeclosetonumber-numdigits">#</a></h3>
<p>Folosind egalitatea la numere în virgulă mobilă este o idee rea. Rotunjirea înseamnă că lucrurile intuitive vor eșua. De exemplu, acest test nu trece:</p>
<pre><code class="language-js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBe(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// Fails!</span>
});
</code></pre>
<p>Aceasta nu trece, deoarece în JavaScript, <code>0.2 + 0.1</code> este de fapt <code>0.30000000000000004</code>. Ne pare rău.</p>
<p>În schimb, utilizaţi <code>.toBeCloseTo</code>. Utilizaţi <code>numDigits</code> pentru a controla câte zecimale să fie verificate. De exemplu, dacă doriţi să vă asiguraţi că <code>0.2 + 0.1</code> este egal cu <code>0.3</code> cu o precizie de 5 cifre zecimale, se poate utiliza acest test:</p>
<pre><code class="language-js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBeCloseTo(<span class="hljs-number">0.3</span>, <span class="hljs-number">5</span>);
});
</code></pre>
<p>Valoarea implicită pentru <code>numDigits</code> este 2, care s-a dovedit a fi suficientă în majoritatea cazurilor.</p>
<h3><a class="anchor" name="tobedefined"></a><code>.toBeDefined()</code> <a class="hash-link" href="#tobedefined">#</a></h3>
<p>Utilizaţi <code>.toBeDefined</code> pentru a verifica dacă o variabilă nu este nedefinită. De exemplu, dacă doriţi să verificați că o funcţie <code>fetchNewFlavorIdea()</code> doar returnează <em>ceva</em>, puteţi scrie:</p>
<pre><code class="language-js">test(<span class="hljs-string">'there is a new flavor idea'</span>, () =&gt; {
  expect(fetchNewFlavorIdea()).toBeDefined();
});
</code></pre>
<p>Ați putea scrie și <code>expect(fetchNewFlavorIdea()).not.toBe(undefined)</code>, dar este de preferat să evitați referința la <code>undefined</code> în mod direct în codul vostru.</p>
<h3><a class="anchor" name="tobefalsy"></a><code>.toBeFalsy()</code> <a class="hash-link" href="#tobefalsy">#</a></h3>
<p>Utilizaţi <code>.toBeFalsy</code> atunci când nu vă pasă valoarea exacta, ci vreți doar să vă asigurați că valoarea este falsă într-un context boolean. De exemplu, să presupunem că aveţi următorul cod:</p>
<pre><code class="language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (!getErrors()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>Nu ar trebui sa ne pese ce anume returnează <code>getErrors</code>, specific - ar putea returna <code>false</code>, <code>null</code>, sau ``, codul funcționând identic. Așadar, dacă doriţi să testaţi ca nu există erori după ce ați băut niște La Croix, ați putea scrie:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinking La Croix does not lead to errors'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(getErrors()).toBeFalsy();
});
</code></pre>
<p>În JavaScript, există şase valori false: <code>false</code>, ``, <code>&quot;&quot;</code>, <code>null</code>, <code>undefined</code>, și <code>NaN</code>. Orice altceva este adevărat.</p>
<h3><a class="anchor" name="tobegreaterthannumber"></a><code>.toBeGreaterThan(number)</code> <a class="hash-link" href="#tobegreaterthannumber">#</a></h3>
<p>Pentru comparea numerele în virgula mobilă, puteţi utiliza <code>toBeGreaterThan</code>. De exemplu, dacă doriţi să testaţi că <code>ouncesPerCan()</code> returnează o valoare de mai mult de 10 uncii, vom scrie:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is more than 10'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThan(<span class="hljs-number">10</span>);
});
</code></pre>
<h3><a class="anchor" name="tobegreaterthanorequalnumber"></a><code>.toBeGreaterThanOrEqual(number)</code> <a class="hash-link" href="#tobegreaterthanorequalnumber">#</a></h3>
<p>Pentru comparea numerele în virgula mobilă, puteţi utiliza <code>toBeGreaterThanOrEqual</code>. De exemplu, dacă doriţi să testaţi că <code>ouncesPerCan()</code> returnează o valoare de cel puțin 12 uncii, vom scrie:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is at least 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthannumber"></a><code>.toBeLessThan(number)</code> <a class="hash-link" href="#tobelessthannumber">#</a></h3>
<p>Pentru comparea numerele în virgula mobilă, puteţi utiliza <code>toBeLessThan</code>. De exemplu, dacă doriţi să testaţi că <code>ouncesPerCan()</code> returnează o valoare mai mică decât 20 uncii, vom scrie:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is less than 20'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThan(<span class="hljs-number">20</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthanorequalnumber"></a><code>.toBeLessThanOrEqual(number)</code> <a class="hash-link" href="#tobelessthanorequalnumber">#</a></h3>
<p>Pentru comparea numerele în virgula mobilă, puteţi utiliza <code>toBeLessThanOrEqual</code>. De exemplu, dacă doriţi să testaţi că <code>ouncesPerCan()</code> returnează o valoare de cel mult 12 uncii, vom scrie:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is at most 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeinstanceofclass"></a><code>.toBeInstanceOf(Class)</code> <a class="hash-link" href="#tobeinstanceofclass">#</a></h3>
<p>Utilizaţi <code>.toBeInstanceOf(Class)</code> pentru a verifica dacă un obiect este o instanță a unei clase. Acest validator foloseste <code>instanceof</code> în spate.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{}

expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(A);
expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}).toBeInstanceOf(<span class="hljs-built_in">Function</span>);
expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(<span class="hljs-built_in">Function</span>); <span class="hljs-comment">// throws</span>
</code></pre>
<h3><a class="anchor" name="tobenull"></a><code>.toBeNull()</code> <a class="hash-link" href="#tobenull">#</a></h3>
<p><code>.toBeNull()</code> este la fel ca <code>.toBe(null)</code>, dar mesajele de eroare sunt puțin mai frumoase. Așadar folosiți <code>.toBeNull()</code> atunci când doriţi să verificați dacă ceva este null.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bloop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

test(<span class="hljs-string">'bloop returns null'</span>, () =&gt; {
  expect(bloop()).toBeNull();
});
</code></pre>
<h3><a class="anchor" name="tobetruthy"></a><code>.toBeTruthy()</code> <a class="hash-link" href="#tobetruthy">#</a></h3>
<p>Utilizaţi <code>.toBeTruthy</code> atunci când nu vă pasă valoarea exacta, ci vreți doar să vă asigurați că valoarea este adevărată într-un context boolean. De exemplu, să presupunem că aveţi următorul cod:</p>
<pre><code class="language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (thirstInfo()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>Nu ar trebui sa ne pese ce anume returnează <code>thirstInfo</code>, specific - ar putea returna fie <code>true</code> fie un obiect complex, codul funcționând identic. Așadar dacă vreți doar să testați că <code>thirstInfo</code> va fi adevărat după ce s-a băut niște La Croix, ați putea scrie:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinking La Croix leads to having thirst info'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(thirstInfo()).toBeTruthy();
});
</code></pre>
<p>În JavaScript, există şase valori false: <code>false</code>, ``, <code>&quot;&quot;</code>, <code>null</code>, <code>undefined</code>, și <code>NaN</code>. Orice altceva este adevărat.</p>
<h3><a class="anchor" name="tobeundefined"></a><code>.toBeUndefined()</code> <a class="hash-link" href="#tobeundefined">#</a></h3>
<p>Utilizaţi <code>.toBeUndefined</code> pentru a verifica dacă o variabilă este nedefinită. De exemplu, dacă doriţi să verificaţi dacă o funcţie <code>bestDrinkForFlavor(flavor)</code> returnează <code>undefined</code> pentru aroma <code>'octopus'</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best drink for octopus flavor is undefined'</span>, () =&gt; {
  expect(bestDrinkForFlavor(<span class="hljs-string">'octopus'</span>)).toBeUndefined();
});
</code></pre>
<p>Ați putea scrie și <code>expect(bestDrinkForFlavor()).toBe(undefined)</code>, dar este de preferat să evitați referința la <code>undefined</code> în mod direct în codul vostru.</p>
<h3><a class="anchor" name="tocontainitem"></a><code>.toContain(item)</code> <a class="hash-link" href="#tocontainitem">#</a></h3>
<p>Utilizaţi <code>.toContain</code> atunci când doriţi să verificați dacă un element se află într-o listă. Pentru testarea elementele din matrice, foloseste <code>===</code>, o verificare de strictă egalitate. <code>.toContain</code> poate de asemenea verifica dacă un string este un subșir al unui alt şir.</p>
<p>De exemplu, dacă <code>getAllFlavors()</code> returnează o listă de arome şi doriţi să vă asiguraţi că <code>lime</code> se află în ea, se poate scrie:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the flavor list contains lime'</span>, () =&gt; {
  expect(getAllFlavors()).toContain(<span class="hljs-string">'lime'</span>);
});
</code></pre>
<h3><a class="anchor" name="tocontainequalitem"></a><code>.toContainEqual(item)</code> <a class="hash-link" href="#tocontainequalitem">#</a></h3>
<p>Utilizaţi <code>.toContainEqual</code> atunci când doriţi pentru să verificați dacă un element cu o anumită structură şi valori este conţinut într-o listă. Pentru testarea elementele din listă, acest validator verifică recursiv egalitatea tuturor proprietăților, în loc să verifice referința obiectului.</p>
<pre><code class="language-js">describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious and not sour'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> myBeverage = {<span class="hljs-attr">delicious</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">sour</span>: <span class="hljs-literal">false</span>};
    expect(myBeverages()).toContainEqual(myBeverage);
  });
});
</code></pre>
<h3><a class="anchor" name="toequalvalue"></a><code>.toEqual(value)</code> <a class="hash-link" href="#toequalvalue">#</a></h3>
<p>Utilizaţi <code>.toEqual</code> atunci când doriţi să verificați dacă două obiecte au aceeaşi valoare. Acest validator verifică recursiv egalitatea tuturor proprietăților, în loc să verifice referințele obictelor—acest lucru fiind cunoscut și sub numele de &quot;egalitate profundă&quot;. De exemplu, <code>toEqual</code> şi <code>toBe</code> se comportă diferit în această suită de teste, astfel încât toate testele vor trece:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> can1 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};
<span class="hljs-keyword">const</span> can2 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the La Croix cans on my desk'</span>, () =&gt; {
  test(<span class="hljs-string">'have all the same properties'</span>, () =&gt; {
    expect(can1).toEqual(can2);
  });
  test(<span class="hljs-string">'are not the exact same can'</span>, () =&gt; {
    expect(can1).not.toBe(can2);
  });
});
</code></pre>
<blockquote>
<p>Notă: <code>.toEqual</code> nu va efectua o verificare de <em>egalitate profundă</em> pentru două obiecte Error. Numai proprietatea <code>message</code> al obiectului Error este luată în considerare pentru verificare. Este recomandat să utilizaţi <code>.toThrow</code> pentru testarea erorilor.</p>
</blockquote>
<h3><a class="anchor" name="tohavelengthnumber"></a><code>.toHaveLength(number)</code> <a class="hash-link" href="#tohavelengthnumber">#</a></h3>
<p>Utilizaţi <code>.toHaveLength</code> pentru a verifica dacă un obiect are o proprietate de <code>.length</code> şi are o anumită valoare numerică.</p>
<p>Acest lucru este util mai ales pentru a verifica dimensiunea listelor sau a șirurilor de caractere.</p>
<pre><code class="language-js">expect([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">'abc'</span>).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">''</span>).not.toHaveLength(<span class="hljs-number">5</span>);
</code></pre>
<h3><a class="anchor" name="tomatchregexporstring"></a><code>.toMatch(regexpOrString)</code> <a class="hash-link" href="#tomatchregexporstring">#</a></h3>
<p>Utilizaţi <code>.toMatch</code> pentru a verifica dacă un şir de caractere validează o expresie regulată.</p>
<p>De exemplu, s-ar putea să nu ştiţi exact ce returnează <code>essayOnTheBestFlavor()</code>, dar știți că este un şir foarte lung şi că ar trebui să conțină un subșir <code>grapefruit</code>. Puteți testa acest lucru în felul următor:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'an essay on the best flavor'</span>, () =&gt; {
  test(<span class="hljs-string">'mentions grapefruit'</span>, () =&gt; {
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-regexp">/grapefruit/</span>);
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'grapefruit'</span>));
  });
});
</code></pre>
<p>Acest validator acceptă, de asemenea, un şir de caractere, pe care va încerca să-l găsească:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'grapefruits are healthy'</span>, () =&gt; {
  test(<span class="hljs-string">'grapefruits are a fruit'</span>, () =&gt; {
    expect(<span class="hljs-string">'grapefruits'</span>).toMatch(<span class="hljs-string">'fruit'</span>);
  });
});
</code></pre>
<h3><a class="anchor" name="tomatchobjectobject"></a><code>.toMatchObject(object)</code> <a class="hash-link" href="#tomatchobjectobject">#</a></h3>
<p>Utilizaţi <code>.toMatchObject</code> pentru a verifica dacă un obiect JavaScript conține un subset de proprietăți ale altui obiect. Validează un obiecte care conţin proprietăți care <strong>nu</strong> fac parte din obiectul aşteptat.</p>
<p>Se poate pasa, de asemenea, o listă de obiecte, iar în cazul acesta metoda va returna adevărat numai în cazul în care fiecare obiect din lista primită se potrivește (în sensul <code>toMatchObject</code> descris mai sus) cu obiectul corespunzător din lista aşteptată. Acest lucru este util dacă doriţi să verificaţi că două liste se potrivesc in raport cu numărul lor de elemente, spre deosebire de <code>arrayContaining</code>, care permite elemente suplimentare în lista primită.</p>
<p>Aveţi posibilitatea să validați proprietăţi cu valori sau cu alți validatori.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};
<span class="hljs-keyword">const</span> desiredHouse = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">wallColor</span>: expect.stringMatching(<span class="hljs-regexp">/white|yellow/</span>),
  },
};

test(<span class="hljs-string">'the house has my desired features'</span>, () =&gt; {
  expect(houseForSale).toMatchObject(desiredHouse);
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'toMatchObject applied to arrays arrays'</span>, () =&gt; {
  test(<span class="hljs-string">'the number of elements must match exactly'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });

  <span class="hljs-comment">// .arrayContaining "matches a received array which contains elements that are *not* in the expected array"</span>
  test(<span class="hljs-string">'.toMatchObject does not allow extra elements'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> }
    ]);
  });

  test(<span class="hljs-string">'.toMatchObject is called for each elements, so extra object properties are okay'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">extra</span>: <span class="hljs-string">'quux'</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });
});
</code></pre>
<h3><a class="anchor" name="tohavepropertykeypath-value"></a><code>.toHaveProperty(keyPath, value)</code> <a class="hash-link" href="#tohavepropertykeypath-value">#</a></h3>
<p>Utilizaţi <code>.toHaveProperty</code> pentru a verifica dacă există o anumită proprietate la referinţa <code>keyPath</code> pentru un obiect. Pentru verificarea proprietăţilor imbricate profund într-un obiect, folosiți <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors">notația cu puncte</a> pentru referinţe profunde.</p>
<p>Opţional, puteţi furniza o <code>valoare</code> pentru a verifica dacă este egală cu valoarea prezentă la <code>keyPath</code> din obiectul ţintă. Acest validator foloseste 'egalitate profundă' (ca <code>toEqual()</code>) şi verifică recursiv egalitatea tuturor proprietăților.</p>
<p>Exemplul următor conţine un obiect <code>houseForSale</code> cu proprietăţi imbricate. Folosim <code>toHaveProperty</code> pentru a verifica existenţa şi valorile diferitelor proprietăţi din obiect.</p>
<pre><code class="language-js"><span class="hljs-comment">// Object containing house features to be tested</span>
<span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};

test(<span class="hljs-string">'this house has my desired features'</span>, () =&gt; {
  <span class="hljs-comment">// Simple Referencing</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bath'</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bedrooms'</span>, <span class="hljs-number">4</span>);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'pool'</span>);

  <span class="hljs-comment">// Deep referencing using dot notation</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.area'</span>, <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.amenities'</span>, [
    <span class="hljs-string">'oven'</span>,
    <span class="hljs-string">'stove'</span>,
    <span class="hljs-string">'washer'</span>,
  ]);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'kitchen.open'</span>);
});
</code></pre>
<h3><a class="anchor" name="tomatchsnapshotoptionalstring"></a><code>.toMatchSnapshot(optionalString)</code> <a class="hash-link" href="#tomatchsnapshotoptionalstring">#</a></h3>
<p>This ensures that a value matches the most recent snapshot. Check out <a href="/jest/docs/ro/snapshot-testing.html">the Snapshot Testing guide</a> for more information.</p>
<p>Puteţi specifica și un nume opţional de imagine stocată. În caz contrar, numele este dedus din test.</p>
<p><em>Notă: În timp ce testarea de imagine este utilizată cel mai frecvent cu componente React, orice valoare serializabilă poate fi folosită ca imagine.</em></p>
<h3><a class="anchor" name="tothrowerror"></a><code>.toThrow(error)</code> <a class="hash-link" href="#tothrowerror">#</a></h3>
<p>Există și cu aliasul: <code>.toThrowError(error)</code></p>
<p>Utilizaţi <code>.toThrow</code> pentru a testa dacă o funcţie aruncă o excepție atunci când este apelată. De exemplu, dacă vrem să testăm că <code>drinkFlavor('octopus')</code> aruncă o excepție, vom scrie:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }).toThrow();
});
</code></pre>
<p>Dacă doriţi să testaţi că este aruncată o eroare specifică, puteți pasa un argument la <code>toThrow</code>. Argumentul poate fi un șir de caractere pentru mesajul de eroare, o clasă de eroare, sau o expresie regulată care ar trebui să se valideze mesajul de eroare. De exemplu, să presupunem că <code>drinkFlavor</code> este implementată în felul următor:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Do some other stuff</span>
}
</code></pre>
<p>Am putea testa în mai multe moduri că această eroare este aruncată:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  <span class="hljs-comment">// Test the exact error message</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-string">'yuck, octopus flavor'</span>);

  <span class="hljs-comment">// Test that the error message says "yuck" somewhere</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-regexp">/yuck/</span>);

  <span class="hljs-comment">// Test that we get a DisgustingFlavorError</span>
  expect(drinkOctopus).toThrowError(DisgustingFlavorError);
});
</code></pre>
<blockquote>
<p>Notă: Trebuie să îmbrăcați codul într-o funcţie, altfel eroarea nu va fi prinsă şi aserțiunea va eşua.</p>
</blockquote>
<h3><a class="anchor" name="tothrowerrormatchingsnapshot"></a><code>.toThrowErrorMatchingSnapshot()</code> <a class="hash-link" href="#tothrowerrormatchingsnapshot">#</a></h3>
<p>Utilizaţi <code>.toThrowErrorMatchingSnapshot</code> pentru a testa dacă o funcţie aruncă o eroare în timpul comparării cu cea mai recentă imagine, atunci când este apelată. De exemplu, să presupunem că aveţi o funcţie <code>drinkFlavor</code> care aruncă o excepție ori de câte ori aroma este <code>'octopus'</code>, şi este implementată în felul următor:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// Do some other stuff</span>
}
</code></pre>
<p>Testul pentru această funcţie va arăta astfel:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  expect(drinkOctopus).toThrowErrorMatchingSnapshot();
});
</code></pre>
<p>Care va genera următoarea imagine:</p>
<pre><code>exports[`drinking flavors throws on octopus 1`] = `&quot;yuck, octopus flavor&quot;`;
</code></pre>
<p>Vedeți <a href="http://facebook.github.io/jest/blog/2016/07/27/jest-14.html"> Testarea de imagine a arborilor React</a> pentru mai multe informaţii.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="api.html">← Globals</a><a class="docs-next button" href="mock-function-api.html">Mock Functions →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/ro/getting-started.html">Getting Started</a><a href="/jest/docs/ro/snapshot-testing.html">Guides</a><a href="/jest/docs/ro/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/ro/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-count-api="/repos/facebook/jest#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>