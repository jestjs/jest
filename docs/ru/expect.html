<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Expect · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Expect · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="Когда вы пишете тесты, вам, как правило, необходимо проверять, что значения соответствуют определенным условиям. `expect` предоставляет вам доступ к ряду «проверок» (matchers), которые позволяют сопоставить результаты с ожиданиями."/><meta property="og:image" content="/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="/jest/css/main.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/ru/getting-started.html" target="_self">Документация</a></li><li><a href="/jest/docs/ru/api.html" target="_self">API</a></li><li><a href="/jest/ru/help.html" target="_self">Справка</a></li><li><a href="/jest/blog" target="_self">Блог</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Русский</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/es-ES">Español</a></li><li><a href="/jest/pt-BR">Português (Brasil)</a></li><li><a href="/jest/ro">Română</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ru/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ru/api.html">Globals</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/ru/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/mock-function-api.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/cli.html">Jest CLI Options</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ru/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/ru/snapshot-testing.html">Тестирование при помощи снимков</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/ru/troubleshooting.html">Troubleshooting</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Expect</h1></header><article><div><span><p>Когда вы пишете тесты, вам, как правило, необходимо проверять, что значения соответствуют определенным условиям. <code>expect</code> предоставляет вам доступ к ряду «проверок» (matchers), которые позволяют сопоставить результаты с ожиданиями.</p>
<h2><a class="anchor" name=""></a>Методы <a class="hash-link" href="#">#</a></h2>
<p>&lt;autogenerated_table_of_contents&gt;</p>
<hr>
<h2><a class="anchor" name=""></a>Справка <a class="hash-link" href="#">#</a></h2>
<h3><a class="anchor" name="expectvalue"></a><code>expect(value)</code> <a class="hash-link" href="#expectvalue">#</a></h3>
<p>Функция <code>expect</code> используется каждый раз, когда вы хотите проверить значение. Однако, вам редко придется вызывать <code>expect</code> саму по себе. Вместо этого вы будете использовать <code>expect</code> вместе с функцией-проверкой для утверждения чего-либо о значении.</p>
<p>Это легче понять на примере. Скажем, у вас есть метод <code>bestLaCroixFlavor()</code>, который должен возвращать строку <code>«грейпфрут»</code>. Вот как можно это протестировать:</p>
<pre><code class="language-js">test(<span class="hljs-string">'лучший вкус это грейпфрут'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).toBe(<span class="hljs-string">'грейпфрут'</span>);
});
</code></pre>
<p>В данном случае для проверки значения используется функция <code>toBe</code>. Существует множество подобных функций, которые помогут вам тестировать различные вещи. Их список приведён ниже.</p>
<p>Аргументом для функции <code>expect</code> должно быть значение, которое возвращает ваш код, а в функцию проверки необходимо передавать ожидаемое верное значение. Если их перепутать местами, то тесты будут продолжать работать, а вот сообщения об ошибках в тестах будут выглядеть странно.</p>
<h3><a class="anchor" name="expectextendmatchers"></a><code>expect.extend(matchers)</code> <a class="hash-link" href="#expectextendmatchers">#</a></h3>
<p><code>expect.extend</code> используется для добавления новых проверок в Jest. Предположим, что вы тестируете библиотеку для работы с числами и вам довольно часто необходимо проверять, что числа делятся на другие числа без остатка. Тогда вы могли бы написать функцию <code>toBeDivisibleBy</code>, которая проверяет это:</p>
<pre><code class="language-js">expect.extend({
  toBeDivisibleBy(received, argument) {
    <span class="hljs-keyword">const</span> pass = (received % argument == <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
          <span class="hljs-string">`ожидалось что <span class="hljs-subst">${received}</span> не делится на <span class="hljs-subst">${argument}</span>`</span>
        ),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (<span class="hljs-string">`ожидалось что <span class="hljs-subst">${received}</span> делится на <span class="hljs-subst">${argument}</span>`</span>),
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});
</code></pre>
<p>Функции-проверки должны возвращать объект с двумя ключами. Ключ <code>pass</code> указывает было ли совпадение успешным или нет, а <code>message</code> представляет собой функцию без аргументов, которая возвращает сообщение об ошибке в случае проваленого теста. То есть, если <code>pass</code> имеет значение false, функция <code>message</code> должна возвращать сообщение об ошибке в случае если <code>expect(x).yourMatcher()</code> не выполняется. Когда же <code>pass</code> имеет значение true, функция <code>message</code> должна возвращать сообщение об ошибке в случае, если не выполняется <code>expect(x).not.yourMatcher()</code>.</p>
<p>По ссылке <code>this</code> внутри пользовательской проверки можно получить доступ к следующим вспомогательным методам:</p>
<h4><a class="anchor" name="thisisnot"></a><code>this.isNot</code> <a class="hash-link" href="#thisisnot">#</a></h4>
<p>Значение типа boolean, сигнализирующее о том, что функция была вызвана с модификатором отрицания <code>.not</code>, позволяющим инвертировать утверждение.</p>
<h4><a class="anchor" name="thisequalsa-b"></a><code>this.equals(a, b)</code> <a class="hash-link" href="#thisequalsa-b">#</a></h4>
<p>Функция для проверки двух объектов на равенство (в т. ч. вложенных свойств). Возвращает значение типа <code>boolean</code>.</p>
<h4><a class="anchor" name="thisutils"></a><code>this.utils</code> <a class="hash-link" href="#thisutils">#</a></h4>
<p>Существует целый ряд полезных инструментов доступных через <code>this.utils</code> и в основном состоящий из функций экспортируемых из <a href="https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils"><code>jest-matcher-utils</code></a>.</p>
<p>Наиболее полезными из них являются <code>matcherHint</code>, <code>printExpected</code> и <code>printReceived</code> для форматирования сообщений об ошибках. Например, взгляните как это реализовано для функции <code>toBe</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> diff = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-diff'</span>);
expect.extend({
  toBe(received, expected) {
    <span class="hljs-keyword">const</span> pass = received === expected;

    <span class="hljs-keyword">const</span> message = pass
      ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.not.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to not be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>
      : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> diffString = diff(expected, received, {
          <span class="hljs-attr">expand</span>: <span class="hljs-keyword">this</span>.expand,
        });
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.toBe'</span>) + <span class="hljs-string">'\n\n'</span> +
        <span class="hljs-string">`Expected value to be (using ===):\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
        <span class="hljs-string">`Received:\n`</span> +
        <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span> +
        (diffString ? <span class="hljs-string">`\n\nDifference:\n\n<span class="hljs-subst">${diffString}</span>`</span> : <span class="hljs-string">''</span>);
      };

    <span class="hljs-keyword">return</span> {<span class="hljs-attr">actual</span>: received, message, pass};
  },
});
</code></pre>
<p>Отобразится что-то вроде этого:</p>
<pre><code>  expect(received).toBe(expected)

    Expected value to be (using ===):
      &quot;banana&quot;
    Received:
      &quot;apple&quot;
</code></pre>
<p>Когда утверждение становится ложным, сообщение об ошибке должно дать пользователю как можно больше информации, необходимой, чтобы быстро решить проблему. Поэтому, разрабатывая новые проверки, вам необходимо реализовывать в них точные и ясные сообщения об ошибках.</p>
<h3><a class="anchor" name="expectanything"></a><code>expect.anything()</code> <a class="hash-link" href="#expectanything">#</a></h3>
<p><code>expect.anything()</code> совпадает с любыми значениями, кроме <code>null</code> или <code>undefined</code>. Её можно использовать внутри <code>toEqual</code> или <code>toBeCalledWith</code> вместо литералов. Например, если вы хотите проверить, что функция-заглушка была вызвана с аргументом, не равным null:</p>
<pre><code class="language-js">test(<span class="hljs-string">'map calls its argument with a non-null argument'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  [<span class="hljs-number">1</span>].map(mock);
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h3><a class="anchor" name="expectanyconstructor"></a><code>expect.any(constructor)</code> <a class="hash-link" href="#expectanyconstructor">#</a></h3>
<p><code>expect.any(constructor)</code> проверяет, что значение было создано с помощью данного конструктора. Её можно использовать внутри <code>toEqual</code> или <code>toBeCalledWith</code> вместо литералов. Например, если вы хотите проверить, что функция-заглушка была вызвана с аргументом типа число:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randocall</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> fn(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>));
}

test(<span class="hljs-string">'randocall calls its callback with a number'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(<span class="hljs-built_in">Number</span>));
});
</code></pre>
<h3><a class="anchor" name="expectarraycontainingarray"></a><code>expect.arrayContaining(array)</code> <a class="hash-link" href="#expectarraycontainingarray">#</a></h3>
<p><code>expect.arrayContaining(array)</code> проверяет, что данный массив содержит все элементы тестового. Иными словами, что тестовый массив является <strong>подмножеством</strong> данного. Отсюда в том числе следует, что этот массив может содержать элементы, которых <strong>нет</strong> в тестовом.</p>
<p>Можно использовать данный метод вместо литерала:</p>
<ul>
<li>в функциях <code>toEqual</code> или <code>toBeCalledWith</code></li>
<li>для проверки свойств объектов в <code>objectContaining</code> или <code>toMatchObject</code></li>
</ul>
<pre><code class="language-js">describe(<span class="hljs-string">'arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'Beware of a misunderstanding! A sequence of dice rolls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  it(<span class="hljs-string">'matches even with an unexpected number 7'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match without an expected number 2'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>])
      .not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" name="expectassertionsnumber"></a><code>expect.assertions(number)</code> <a class="hash-link" href="#expectassertionsnumber">#</a></h3>
<p><code>expect.assertions(number)</code> проверяет, что во время выполнения теста было вызвано определённое число проверок. Это обычно полезно для тестирования асинхронного кода, чтобы удостовериться, что проверки действительно были вызваны в функциях обратного вызова.</p>
<p>Скажем, у нас есть функция <code>doAsync</code>, которая получает на вход две функции обратного вызова <code>callback1</code> и <code>callback2</code>. Обе этих функции будут вызваны асинхронно в неизвестном заранее порядке. Это можно протестировать так:</p>
<pre><code class="language-js">test(<span class="hljs-string">'doAsync calls both callbacks'</span>, () =&gt; {
  expect.assertions(<span class="hljs-number">2</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p>Код <code>expect.assertions(2)</code> проверяет, что обе функции были вызваны.</p>
<h3><a class="anchor" name="expecthasassertions"></a><code>expect.hasAssertions()</code> <a class="hash-link" href="#expecthasassertions">#</a></h3>
<p><code>expect.hasAssertions()</code> проверяет, что во время выполнения теста была вызвана хотя бы одна проверка. Это обычно полезно для тестирования асинхронного кода, чтобы удостовериться, что проверки действительно были вызваны в функциях обратного вызова.</p>
<p>Предположим, что у нас есть несколько функций, которые работают с неким состоянием. <code>prepareState</code> запускает функцию обратного вызова с объектом состояния, <code>validateState</code> выполняет над этим объектом некую операцию, а <code>waitOnState</code> возвращает Promise, который ожидает, пока все фунцкии обратного вызова внутри <code>prepareState</code> не будут выполнены. Это можно протестировать так:</p>
<pre><code class="language-js">test(<span class="hljs-string">'prepareState prepares a valid state'</span>, () =&gt; {
  expect.hasAssertions();
  prepareState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    expect(validateState(state)).toBeTruthy();
  });
  <span class="hljs-keyword">return</span> waitOnState();
});
</code></pre>
<p>Код <code>expect.hasAssertions()</code> проверяет, что функция обратного вызова в <code>prepareState</code> была вызвана.</p>
<h3><a class="anchor" name="expectobjectcontainingobject"></a><code>expect.objectContaining(object)</code> <a class="hash-link" href="#expectobjectcontainingobject">#</a></h3>
<p><code>expect.objectContaining(object)</code> проверяет (рекурсивно), что данный объект имеет те или иные свойства. Иными словами, что тестовый объект является <strong>подмножеством</strong> данного. Отсюда в том числе следует, что этот объект может содержать свойста, которых <strong>нет</strong> в тестовом.</p>
<p>Instead of literal property values in the expected object, you can use matchers, <code>expect.anything()</code>, and so on.</p>
<p>Предположим, мы ожидаем, что функция <code>onPress</code> будет вызвана с объектом <code>Event</code> и всё, что мы хотим проверить — это то, что этот объект имеет свойства <code>event.x</code> и <code>event.y</code>. Это можно сделать так:</p>
<pre><code class="language-js">test(<span class="hljs-string">'onPress gets called with the right thing'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> _onPress = jest.fn();
  simulatePresses(_onPress);
  expect(_onPress).toBeCalledWith(expect.objectContaining({
    <span class="hljs-attr">x</span>: expect.any(<span class="hljs-built_in">Number</span>),
    <span class="hljs-attr">y</span>: expect.any(<span class="hljs-built_in">Number</span>),
  }));
});
</code></pre>
<h3><a class="anchor" name="expectstringcontainingstring"></a><code>expect.stringContaining(string)</code> <a class="hash-link" href="#expectstringcontainingstring">#</a></h3>
<h5><a class="anchor" name="jest-1900"></a>доступно в версиях Jest <strong>19.0.0+</strong> <a class="hash-link" href="#jest-1900">#</a></h5>
<p><code>expect.stringContaining(string)</code> проверяет, что данная строка содержит в себе тестовую.</p>
<h3><a class="anchor" name="expectstringmatchingregexp"></a><code>expect.stringMatching(regexp)</code> <a class="hash-link" href="#expectstringmatchingregexp">#</a></h3>
<p><code>expect.stringMatching(regexp)</code> проверяет, что данная строка соответствует регулярному выражению.</p>
<p>Можно использовать данный метод вместо литерала:</p>
<ul>
<li>в функциях <code>toEqual</code> или <code>toBeCalledWith</code></li>
<li>для проверки элемента в <code>arrayContaining</code></li>
<li>для проверки свойств объектов в <code>objectContaining</code> или <code>toMatchObject</code></li>
</ul>
<p>Следующий пример также демонстрирует, что вы можете вложить друг в друга несколько асимметричных проверок. В данном случае <code>expect.stringMatching</code> находится внутри <code>expect.arrayContaining</code>.</p>
<pre><code class="language-js">describe(<span class="hljs-string">'stringMatching in arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [
    expect.stringMatching(<span class="hljs-regexp">/^Alic/</span>),
    expect.stringMatching(<span class="hljs-regexp">/^[BR]ob/</span>),
  ];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alicia'</span>, <span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>])
      .not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" name="expectaddsnapshotserializerserializer"></a><code>expect.addSnapshotSerializer(serializer)</code> <a class="hash-link" href="#expectaddsnapshotserializerserializer">#</a></h3>
<p>Вы можете использовать <code>expect.addSnapshotSerializer</code> для добавления модуля, который поддерживает форматирование структур данных, специфичных для вашего приложения.</p>
<p>Для каждого файла, содержащего тесты, добавленный таким образом модуль будет предшествовать всем модулям, объявленным в параметре конфигурации <code>snapshotSerializers</code>. Те, в свою очередь, предшествуют сериализаторам снимков для встроенных типов JavaScript и элементов React, включённым в Jest по-умолчанию. Последний добавленный модуль будет протестирован первым.</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> serializer <span class="hljs-keyword">from</span> <span class="hljs-string">'my-serializer-module'</span>;
expect.addSnapshotSerializer(serializer);

<span class="hljs-comment">// влияет на поведение проверки expect(value).toMatchSnapshot() в файле с тестами</span>
</code></pre>
<p>Если вы добавляете сериализатор снимков в файл с тестами вместо того, чтобы объявить его в параметре конфигурации <code>snapshotSerializers</code>, то:</p>
<ul>
<li>Вы делаете зависимость явной.</li>
<li>Вы избегаете ограничений конфигурации, которые могут помешать вам использовать <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>.</li>
</ul>
<p>See <a href="/jest/docs/ru/configuration.html#snapshotserializers-array-string">configuring Jest</a> for more information.</p>
<h3><a class="anchor" name="not"></a><code>.not</code> <a class="hash-link" href="#not">#</a></h3>
<p>Если вы знаете как можно проверить некое утверждение, то <code>.not</code> позволяет вам проверить обратное ему утверждение. Например, следующий код проверяет, что лучший вкус газировки La Croix не является кокосовым:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best flavor is not coconut'</span>, () =&gt; {
  expect(bestLaCroixFlavor()).not.toBe(<span class="hljs-string">'coconut'</span>);
});
</code></pre>
<h3><a class="anchor" name="resolves"></a><code>.resolves</code> <a class="hash-link" href="#resolves">#</a></h3>
<h5><a class="anchor" name="jest-2000"></a>доступно в версиях Jest <strong>20.0.0+</strong> <a class="hash-link" href="#jest-2000">#</a></h5>
<p>Используйте <code>resolves</code> для возврата значения из объекта типа Promise. К возвращённому таким образом значению можно применять другие функции-проверки. Данный метод работает только с объектами Promise в состоянии «выполнено». Если объект Promise находится в состоянии «отклонено», то проверка не выполняется.</p>
<p>Например, следующий код проверяет, что Promise выполняется и результатом будет <code>'lemon'</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'resolves to lemon'</span>, () =&gt; {
  <span class="hljs-comment">// не забудьте добавить оператор return</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
});
</code></pre>
<p>Кроме того, вы можете использовать <code>async/await</code> в комбинации с <code>.resolves</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'resolves to lemon'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.toBe(<span class="hljs-string">'lemon'</span>);
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'lemon'</span>)).resolves.not.toBe(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" name="rejects"></a><code>.rejects</code> <a class="hash-link" href="#rejects">#</a></h3>
<h5><a class="anchor" name="jest-2000"></a>доступно в версиях Jest <strong>20.0.0+</strong> <a class="hash-link" href="#jest-2000">#</a></h5>
<p>Используйте <code>.rejects</code> для возврата значения из объекта типа Promise. К возвращённому таким образом значению можно применять другие функции-проверки. Данный метод работает только с объектами Promise в состоянии «отклонено». Если объект Promise находится в состоянии «выполнено», то проверка не выполняется.</p>
<p>For example, this code tests that the promise rejects with reason <code>'octopus'</code>:</p>
<pre><code class="language-js">test(<span class="hljs-string">'rejects to octopus'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'octopus'</span>)).rejects.toBe(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<p>Alternatively, you can use <code>async/await</code> in combination with <code>.rejects</code>.</p>
<pre><code class="language-js">test(<span class="hljs-string">'rejects to octopus'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'octopus'</span>)).rejects.toBe(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobevalue"></a><code>.toBe(value)</code> <a class="hash-link" href="#tobevalue">#</a></h3>
<p><code>toBe</code> просто проверяет, что значение соответствует ожидаемому. Эта функция использует строгую проверку на равенство <code>===</code>.</p>
<p>For example, this code will validate some properties of the <code>can</code> object:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> can = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'pamplemousse'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the can'</span>, () =&gt; {
  test(<span class="hljs-string">'has 12 ounces'</span>, () =&gt; {
    expect(can.ounces).toBe(<span class="hljs-number">12</span>);
  });

  test(<span class="hljs-string">'has a sophisticated name'</span>, () =&gt; {
    expect(can.name).toBe(<span class="hljs-string">'pamplemousse'</span>);
  });
});
</code></pre>
<p>Не следует использовать <code>toBe</code> для чисел с плавающей точкой. В JavaScript <code>0.2 + 0.1</code> не будет равно <code>0.3</code> из-за особенностей округления. Используйте <code>.toBeCloseTo</code> если вам необходимо сравнивать числа с плавающей точкой.</p>
<h3><a class="anchor" name="tohavebeencalled"></a><code>.toHaveBeenCalled()</code> <a class="hash-link" href="#tohavebeencalled">#</a></h3>
<p>Другое имя функции: <code>.toBeCalled()</code></p>
<p>Используйте <code>.toHaveBeenCalled</code>, чтобы убедиться, что функция-заглушка была вызвана.</p>
<p>Предположим, что у вас есть функция <code>drinkAll(drink, flavor)</code>, которая принимает в качестве параметра функцию <code>drink</code> и вызывает её для всех напитков в вашей системе. Вам может потребоваться протестировать, что <code>drink</code> была вызвана для напитка <code>'lemon'</code>, но никак не для напитка <code>'octopus'</code>. Было бы весьма странным иметь напиток со вкусом осьминога, не правда ли? Это можно сделать при помощи следующего теста:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'drinkAll'</span>, () =&gt; {
  test(<span class="hljs-string">'drinks something lemon-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'lemon'</span>);
    expect(drink).toHaveBeenCalled();
  });

  test(<span class="hljs-string">'does not drink something octopus-flavored'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'octopus'</span>);
    expect(drink).not.toHaveBeenCalled();
  });
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledtimesnumber"></a><code>.toHaveBeenCalledTimes(number)</code> <a class="hash-link" href="#tohavebeencalledtimesnumber">#</a></h3>
<p>Используйте <code>.toHaveBeenCalledTimes</code>, чтобы убедиться, что функция-заглушка была вызвана строго определённое число раз.</p>
<p>Например, у вас может быть функция <code>drinkEach(drink, Array&lt;flavor&gt;)</code>, которая принимает в качестве параметра функцию <code>drink</code> и вызывает её для каждого элемента массива напитков. Тогда вам может потребоваться проверить, что функция drink была вызвана определённое число раз. Это можно сделать при помощи следующего теста:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinkEach drinks each drink'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  drinkEach(drink, [<span class="hljs-string">'lemon'</span>, <span class="hljs-string">'octopus'</span>]);
  expect(drink).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" name="tohavebeencalledwitharg1-arg2-"></a><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeencalledwitharg1-arg2-">#</a></h3>
<p>Also under the alias: <code>.toBeCalledWith()</code></p>
<p>Используйте <code>.toHaveBeenCalledWith</code>, чтобы убедиться, что функция-заглушка была вызвана с определённым набором аргументов.</p>
<p>Предположим, что у вас есть функция <code>register</code>, которая добавляет напиток в систему, а также функция <code>applyToAll(f)</code>, должна применить функцию <code>f</code> ко всем напиткам. Чтобы убедиться, что это работает, вы могли бы написать:</p>
<pre><code class="language-js">test(<span class="hljs-string">'registration applies correctly to orange La Croix'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage = <span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'orange'</span>);
  register(beverage);
  <span class="hljs-keyword">const</span> f = jest.fn();
  applyToAll(f);
  expect(f).toHaveBeenCalledWith(beverage);
});
</code></pre>
<h3><a class="anchor" name="tohavebeenlastcalledwitharg1-arg2-"></a><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code> <a class="hash-link" href="#tohavebeenlastcalledwitharg1-arg2-">#</a></h3>
<p>Другое имя функции: <code>.lastCalledWith(arg1, arg2, ...)</code></p>
<p>Используйте <code>.toHaveBeenLastCalledWith</code>, чтобы убедиться, что в последний раз функция-заглушка была вызвана с определённым набором аргументов. Например, ваша функция <code>applyToAllFlavors(f)</code> вызывает функцию <code>drink</code> для набора напитков. Вы хотите убедиться, что последним был вызван напиток <code>'mango'</code>. Вы можете написать:</p>
<pre><code class="language-js">test(<span class="hljs-string">'applying to all flavors does mango last'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  applyToAllFlavors(drink);
  expect(drink).toHaveBeenLastCalledWith(<span class="hljs-string">'mango'</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeclosetonumber-numdigits"></a><code>.toBeCloseTo(number, numDigits)</code> <a class="hash-link" href="#tobeclosetonumber-numdigits">#</a></h3>
<p>Использовать оператор равенства для сравнения чисел с плавающей точкой — это плохая идея. Когда работает округление, перестают работать очевидные вещи. Нпример, этот тест не будет пройден:</p>
<pre><code class="language-js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBe(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// Неверно!</span>
});
</code></pre>
<p>А неверно это потому, что в JavaScript <code>0.2 + 0.1</code> равно <code>0.30000000000000004</code>. Уж извините.</p>
<p>Вместо этого используйте <code>.toBeCloseTo</code>. Параметр <code>numDigits</code> определяет сколько разрядов после запятой необходимо учитывать. Например, если вам нужно убедиться, что <code>0.2 + 0.1</code> равно <code>0.3</code> с точностью до пяти знаков после запятой, можно написать следующее:</p>
<pre><code class="language-js">test(<span class="hljs-string">'adding works sanely with simple decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBeCloseTo(<span class="hljs-number">0.3</span>, <span class="hljs-number">5</span>);
});
</code></pre>
<p>По-умолчанию <code>numDigits</code> равен 2, что в большинстве случаев достаточно.</p>
<h3><a class="anchor" name="tobedefined"></a><code>.toBeDefined()</code> <a class="hash-link" href="#tobedefined">#</a></h3>
<p>Используйте <code>.toBeDefined</code> для проверки того, что переменная определена. Например, если вы просто хотите проверить, что функция <code>fetchNewFlavorIdea()</code> возвращает <em>что-то</em>, вы можете написать:</p>
<pre><code class="language-js">test(<span class="hljs-string">'there is a new flavor idea'</span>, () =&gt; {
  expect(fetchNewFlavorIdea()).toBeDefined();
});
</code></pre>
<p>Конечно, можно было бы написать <code>expect(fetchNewFlavorIdea()).not.toBe(undefined)</code>, но лучше избегать использования <code>undefined</code> непосредственно в вашем коде.</p>
<h3><a class="anchor" name="tobefalsy"></a><code>.toBeFalsy()</code> <a class="hash-link" href="#tobefalsy">#</a></h3>
<p>Используйте <code>.toBeFalsy</code> когда вам всего лишь необходимо проверить, что значение эквивалентно ложному. Предположим, что у вас есть следующий код:</p>
<pre><code class="language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (!getErrors()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>Вам не так уж важно что возвращает <code>getErrors</code>. Она может вернуть <code>false</code>, <code>null</code> или ``, однако ваш код будет корректно работать. И если вы хотите протестировать, что после употребления газировки La Croix не произошло никаких ошибок, то можно написать:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinking La Croix does not lead to errors'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(getErrors()).toBeFalsy();
});
</code></pre>
<p>В JavaScript существует всего шесть значений, эквивалетных ложному: <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code> и <code>NaN</code>. Всё остальное эквивалентно истине.</p>
<h3><a class="anchor" name="tobegreaterthannumber"></a><code>.toBeGreaterThan(number)</code> <a class="hash-link" href="#tobegreaterthannumber">#</a></h3>
<p>Для сравнения чисел с плавающей точкой можно использовать <code>toBeGreaterThan</code>. Например, если вы хотите проверить, что <code>ouncesPerCan()</code> возвращает значение, которое больше чем 10 унций, пишите:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is more than 10'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThan(<span class="hljs-number">10</span>);
});
</code></pre>
<h3><a class="anchor" name="tobegreaterthanorequalnumber"></a><code>.toBeGreaterThanOrEqual(number)</code> <a class="hash-link" href="#tobegreaterthanorequalnumber">#</a></h3>
<p>Для сравнения чисел с плавающей точкой можно использовать <code>toBeGreaterThanOrEqual</code>. Например, если вы хотите проверить, что <code>ouncesPerCan()</code> возвращает значение, которое не меньше чем 12 унций, пишите:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is at least 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthannumber"></a><code>.toBeLessThan(number)</code> <a class="hash-link" href="#tobelessthannumber">#</a></h3>
<p>Для сравнения чисел с плавающей точкой можно использовать <code>toBeLessThan</code>. Например, если вы хотите проверить, что <code>ouncesPerCan()</code> возвращает значение, которое меньше чем 20 унций, пишите:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is less than 20'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThan(<span class="hljs-number">20</span>);
});
</code></pre>
<h3><a class="anchor" name="tobelessthanorequalnumber"></a><code>.toBeLessThanOrEqual(number)</code> <a class="hash-link" href="#tobelessthanorequalnumber">#</a></h3>
<p>Для сравнения чисел с плавающей точкой можно использовать <code>toBeLessThanOrEqual</code>. Например, если вы хотите проверить, что <code>ouncesPerCan()</code> возвращает значение, которое не больше чем 12 унций, пишите:</p>
<pre><code class="language-js">test(<span class="hljs-string">'ounces per can is at most 12'</span>, () =&gt; {
  expect(ouncesPerCan()).toBeLessThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" name="tobeinstanceofclass"></a><code>.toBeInstanceOf(Class)</code> <a class="hash-link" href="#tobeinstanceofclass">#</a></h3>
<p>Используйте <code>.toBeInstanceOf(Class)</code>, чтобы проверить, что данный объект является экземпляром того или иного класса. Эта функция использует оператор <code>instanceof</code>.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{}

expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(A);
expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}).toBeInstanceOf(<span class="hljs-built_in">Function</span>);
expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(<span class="hljs-built_in">Function</span>); <span class="hljs-comment">// throws</span>
</code></pre>
<h3><a class="anchor" name="tobenull"></a><code>.toBeNull()</code> <a class="hash-link" href="#tobenull">#</a></h3>
<p><code>.toBeNull()</code> ведёт себя точно так же, как <code>.toBe(null)</code>, просто её сообщения об ошибках выглядят получше. Так что, если вам нужно проверить, что что-то является null, то используйте <code>.toBeNull()</code>.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bloop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

test(<span class="hljs-string">'bloop returns null'</span>, () =&gt; {
  expect(bloop()).toBeNull();
});
</code></pre>
<h3><a class="anchor" name="tobetruthy"></a><code>.toBeTruthy()</code> <a class="hash-link" href="#tobetruthy">#</a></h3>
<p>Используйте <code>.toBeTruthy</code> когда вам всего лишь необходимо проверить, что значение эквивалентно истинному. Предположим, что у вас есть следующий код:</p>
<pre><code class="language-js">drinkSomeLaCroix();
<span class="hljs-keyword">if</span> (thirstInfo()) {
  drinkMoreLaCroix();
}
</code></pre>
<p>Вам не так уж важно, что возвращает <code>thirstInfo</code>. Она может вернуть <code>true</code> или целый объект, однако ваш код будет корректно работать. Так что если вы просто хотите проверить, что <code>thirstInfo</code> вернёт значение эквивалетное истинному после употребления газировки La Croix, можно написать:</p>
<pre><code class="language-js">test(<span class="hljs-string">'drinking La Croix leads to having thirst info'</span>, () =&gt; {
  drinkSomeLaCroix();
  expect(thirstInfo()).toBeTruthy();
});
</code></pre>
<p>В JavaScript существует всего шесть значений, эквивалетных ложному: <code>false</code>, ``, <code>''</code>, <code>null</code>, <code>undefined</code> и <code>NaN</code>. Всё остальное эквивалентно истине.</p>
<h3><a class="anchor" name="tobeundefined"></a><code>.toBeUndefined()</code> <a class="hash-link" href="#tobeundefined">#</a></h3>
<p>Используйте <code>.toBeUndefined</code>, чтобы проверить, что переменная не определена. Например, вы хотите проверить, что функция <code>bestDrinkForFlavor(flavor)</code> возвращает <code>undefined</code> для вкуса <code>'octopus'</code>. Просто потому, что напитков со вкусом осьминога не существует:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the best drink for octopus flavor is undefined'</span>, () =&gt; {
  expect(bestDrinkForFlavor(<span class="hljs-string">'octopus'</span>)).toBeUndefined();
});
</code></pre>
<p>Конечно, можно было бы написать <code>expect(bestDrinkForFlavor('octopus')).toBe(undefined)</code>, но лучше избегать использования <code>undefined</code> непосредственно в вашем коде.</p>
<h3><a class="anchor" name="tocontainitem"></a><code>.toContain(item)</code> <a class="hash-link" href="#tocontainitem">#</a></h3>
<p>Use <code>.toContain</code> when you want to check that an item is in an array. For testing the items in the array, this uses <code>===</code>, a strict equality check. <code>.toContain</code> can also check whether a string is a substring of another string.</p>
<p>For example, if <code>getAllFlavors()</code> returns an array of flavors and you want to be sure that <code>lime</code> is in there, you can write:</p>
<pre><code class="language-js">test(<span class="hljs-string">'the flavor list contains lime'</span>, () =&gt; {
  expect(getAllFlavors()).toContain(<span class="hljs-string">'lime'</span>);
});
</code></pre>
<h3><a class="anchor" name="tocontainequalitem"></a><code>.toContainEqual(item)</code> <a class="hash-link" href="#tocontainequalitem">#</a></h3>
<p>Use <code>.toContainEqual</code> when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity.</p>
<pre><code class="language-js">describe(<span class="hljs-string">'my beverage'</span>, () =&gt; {
  test(<span class="hljs-string">'is delicious and not sour'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> myBeverage = {<span class="hljs-attr">delicious</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">sour</span>: <span class="hljs-literal">false</span>};
    expect(myBeverages()).toContainEqual(myBeverage);
  });
});
</code></pre>
<h3><a class="anchor" name="toequalvalue"></a><code>.toEqual(value)</code> <a class="hash-link" href="#toequalvalue">#</a></h3>
<p>Используйте <code>.toEqual</code>, когда вы хотите проверить, что два объекта имеют одинаковое значение. Вместо проверки объектов на идентичность, эта функция рекурсивно сравнивает все поля в объектах. Эта процедура ещё называется «проверка на глубокое равенство». Например <code>toEqual</code> и <code>toBe</code> ведут себя по-разному в этом наборе, и, таким образом, все тесты успешно выполняются:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> can1 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};
<span class="hljs-keyword">const</span> can2 = {
  <span class="hljs-attr">flavor</span>: <span class="hljs-string">'grapefruit'</span>,
  <span class="hljs-attr">ounces</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'the La Croix cans on my desk'</span>, () =&gt; {
  test(<span class="hljs-string">'have all the same properties'</span>, () =&gt; {
    expect(can1).toEqual(can2);
  });
  test(<span class="hljs-string">'are not the exact same can'</span>, () =&gt; {
    expect(can1).not.toBe(can2);
  });
});
</code></pre>
<blockquote>
<p>Примечание: <code>.toEqual</code> не сможет выполнить проверку на <em>глубокое равенство</em> для объектов типа Error. В этих объектах проверяется на равенство только свойство <code>message</code>. Поэтому для тестирования исключений рекомендуется использовать функцию <code>.toThrow</code>.</p>
</blockquote>
<h3><a class="anchor" name="tohavelengthnumber"></a><code>.toHaveLength(number)</code> <a class="hash-link" href="#tohavelengthnumber">#</a></h3>
<p>Используйте <code>.toHaveLength</code> для проверки того, что объект имеет свойство <code>.length</code>, и оно имеет определённое значение.</p>
<p>Это особенно полезно для проверки размера массивов или строк.</p>
<pre><code class="language-js">expect([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">'abc'</span>).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">''</span>).not.toHaveLength(<span class="hljs-number">5</span>);
</code></pre>
<h3><a class="anchor" name="tomatchregexporstring"></a><code>.toMatch(regexpOrString)</code> <a class="hash-link" href="#tomatchregexporstring">#</a></h3>
<p>Используйте <code>.toMatch</code>, чтобы проверить, что строка соответствует регулярному выражению.</p>
<p>Например, вы можете не знать точное возвращаемое значение функции <code>essayOnTheBestFlavor()</code>, однако вы уверены, что это — очень длинная строка в которой содержится слово <code>grapefruit</code>. Это можно протестировать так:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'an essay on the best flavor'</span>, () =&gt; {
  test(<span class="hljs-string">'mentions grapefruit'</span>, () =&gt; {
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-regexp">/grapefruit/</span>);
    expect(essayOnTheBestFlavor()).toMatch(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'grapefruit'</span>));
  });
});
</code></pre>
<p>Кроме того, эта функция может принимать и строку, которую попытается найти в исходной:</p>
<pre><code class="language-js">describe(<span class="hljs-string">'grapefruits are healthy'</span>, () =&gt; {
  test(<span class="hljs-string">'grapefruits are a fruit'</span>, () =&gt; {
    expect(<span class="hljs-string">'grapefruits'</span>).toMatch(<span class="hljs-string">'fruit'</span>);
  });
});
</code></pre>
<h3><a class="anchor" name="tomatchobjectobject"></a><code>.toMatchObject(object)</code> <a class="hash-link" href="#tomatchobjectobject">#</a></h3>
<p>Используйте <code>.toMatchObject</code> для проверки того, что некий объект содержит подмножество свойств текущего объекта. It will match received objects with properties that are <strong>not</strong> in the expected object.</p>
<p>You can also pass an array of objects, in which case the method will return true only if each object in the received array matches (in the <code>toMatchObject</code> sense described above) the corresponding object in the expected array. This is useful if you want to check that two arrays match in their number of elements, as opposed to <code>arrayContaining</code>, which allows for extra elements in the received array.</p>
<p>You can match properties against values or against matchers.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};
<span class="hljs-keyword">const</span> desiredHouse = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">wallColor</span>: expect.stringMatching(<span class="hljs-regexp">/white|yellow/</span>),
  },
};

test(<span class="hljs-string">'the house has my desired features'</span>, () =&gt; {
  expect(houseForSale).toMatchObject(desiredHouse);
});
</code></pre>
<pre><code class="language-js">describe(<span class="hljs-string">'toMatchObject applied to arrays arrays'</span>, () =&gt; {
  test(<span class="hljs-string">'the number of elements must match exactly'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });

  <span class="hljs-comment">// .arrayContaining "matches a received array which contains elements that are *not* in the expected array"</span>
  test(<span class="hljs-string">'.toMatchObject does not allow extra elements'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> }
    ]);
  });

  test(<span class="hljs-string">'.toMatchObject is called for each elements, so extra object properties are okay'</span>, () =&gt; {
    expect([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">extra</span>: <span class="hljs-string">'quux'</span> }
    ]).toMatchObject([
      { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> },
      { <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span> }
    ]);
  });
});
</code></pre>
<h3><a class="anchor" name="tohavepropertykeypath-value"></a><code>.toHaveProperty(keyPath, value)</code> <a class="hash-link" href="#tohavepropertykeypath-value">#</a></h3>
<p>Используйте <code>.toHaveProperty</code> для проверки того, что в данном объекте есть свойство <code>keyPath</code>. Для проверки глубоко вложенных свойств используйте <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Property_accessors">точечную нотацию</a>.</p>
<p>Кроме того, можно указать параметр <code>value</code> для проверки того, что значение свойства <code>keyPath</code> в объекте соответствует заданному. Эта функция использует «глубокое равенство» (как и <code>toEqual()</code>) и проверяет равенство полей рекурсивно.</p>
<p>В следующем примере содержится объект <code>houseForSale</code> с вложенными свойствами. Мы используем <code>toHaveProperty</code> для проверки существования и значений некоторых свойств в объекте.</p>
<pre><code class="language-js"><span class="hljs-comment">// Object containing house features to be tested</span>
<span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
  },
};

test(<span class="hljs-string">'this house has my desired features'</span>, () =&gt; {
  <span class="hljs-comment">// Simple Referencing</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bath'</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bedrooms'</span>, <span class="hljs-number">4</span>);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'pool'</span>);

  <span class="hljs-comment">// Deep referencing using dot notation</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.area'</span>, <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.amenities'</span>, [
    <span class="hljs-string">'oven'</span>,
    <span class="hljs-string">'stove'</span>,
    <span class="hljs-string">'washer'</span>,
  ]);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'kitchen.open'</span>);
});
</code></pre>
<h3><a class="anchor" name="tomatchsnapshotoptionalstring"></a><code>.toMatchSnapshot(optionalString)</code> <a class="hash-link" href="#tomatchsnapshotoptionalstring">#</a></h3>
<p>This ensures that a value matches the most recent snapshot. Check out <a href="/jest/docs/ru/snapshot-testing.html">the Snapshot Testing guide</a> for more information.</p>
<p>В функцию можно передать имя снимка. В противном случае имя определяется из теста.</p>
<p><em>Примечание: тестирование при помощи снимков, как правило, применяется к компонентам React. Тем не менее, любое сериализуемое значение может быть использовано в качестве снимка.</em></p>
<h3><a class="anchor" name="tothrowerror"></a><code>.toThrow(error)</code> <a class="hash-link" href="#tothrowerror">#</a></h3>
<p>Другое имя функции: <code>.toThrowError()</code></p>
<p>Используйте <code>.toThrow</code> для проверки, что функция бросает исключение при вызове. Например, если бы мы хотели проверить, что функция <code>drinkFlavor('octopus')</code> кидает исключение, потому что газировка со вкусом осьминога слишком отвратительна для питья, мы могли бы написать:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }).toThrow();
});
</code></pre>
<p>Если вы хотите проверить, что было выброшено то или иное исключение, то можно передать аргумент в <code>toThrow</code>. Этим аргументом может быть строка с сообщением об ошибке, класс исключения или регулярное выражение. Пусть в <code>drinkFlavor</code> написано следующее:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// что угодно</span>
}
</code></pre>
<p>Мы можем проверить это исключение несколькими способами:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  <span class="hljs-comment">// проверяем сообщение об ошибке на полное соответствие</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-string">'yuck, octopus flavor'</span>);

  <span class="hljs-comment">// проверяем, что сообщение об ошибке содержит слово "yuck"</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-regexp">/yuck/</span>);

  <span class="hljs-comment">// проверяем, что ошибка является DisgustingFlavorError</span>
  expect(drinkOctopus).toThrowError(DisgustingFlavorError);
});
</code></pre>
<blockquote>
<p>Note: You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail.</p>
</blockquote>
<h3><a class="anchor" name="tothrowerrormatchingsnapshot"></a><code>.toThrowErrorMatchingSnapshot()</code> <a class="hash-link" href="#tothrowerrormatchingsnapshot">#</a></h3>
<p>Use <code>.toThrowErrorMatchingSnapshot</code> to test that a function throws an error matching the most recent snapshot when it is called. Например, у вас есть функция <code>drinkFlavor</code>, которая генерирует исключение всякий раз, когда ей передают параметр <code>'octopus'</code>:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkFlavor</span>(<span class="hljs-params">flavor</span>) </span>{
  <span class="hljs-keyword">if</span> (flavor == <span class="hljs-string">'octopus'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisgustingFlavorError(<span class="hljs-string">'yuck, octopus flavor'</span>);
  }
  <span class="hljs-comment">// что угодно</span>
}
</code></pre>
<p>Тест для этой функции будет выглядеть следующим образом:</p>
<pre><code class="language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  expect(drinkOctopus).toThrowErrorMatchingSnapshot();
});
</code></pre>
<p>Этот тест создаст следующий снимок:</p>
<pre><code>exports[`drinking flavors throws on octopus 1`] = `&quot;yuck, octopus flavor&quot;`;
</code></pre>
<p>Дополнительную информацию по тестированию при помощи снимков можно найти на странице <a href="http://facebook.github.io/jest/blog/2016/07/27/jest-14.html">React Tree Snapshot Testing</a>.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="api.html">← Globals</a><a class="docs-next button" href="mock-function-api.html">Mock Functions →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/ru/getting-started.html">Getting Started</a><a href="/jest/docs/ru/snapshot-testing.html">Guides</a><a href="/jest/docs/ru/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/ru/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-count-api="/repos/facebook/jest#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>