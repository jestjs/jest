<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>The Jest Object · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="The Jest Object · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://facebook.github.io/jest/index.html"/><meta property="og:description" content="O objeto `jest` é automaticamente inserido no escopo de cada arquivo de teste. Os métodos no objeto `jest` ajudam a criar simulações (mock, em inglês) e deixam você controlar o comportamento geral de Jest."/><meta property="og:image" content="/jest/img/opengraph.png"/><link rel="shortcut icon" href="/jest/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="/jest/css/main.css"/><link rel="alternate" type="application/atom+xml" href="https://facebook.github.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://facebook.github.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jest/"><img class="logo" src="/jest/img/jest.svg"/><h2 class="headerTitle">Jest</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/jest/docs/pt-BR/getting-started.html" target="_self">Documentação</a></li><li><a href="/jest/docs/pt-BR/api.html" target="_self">API</a></li><li><a href="/jest/pt-BR/help.html" target="_self">Ajuda</a></li><li><a href="/jest/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/jest/img/language.svg"/>Português (Brasil)</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/jest/en">English</a></li><li><a href="/jest/ja">日本語</a></li><li><a href="/jest/es-ES">Español</a></li><li><a href="/jest/ro">Română</a></li><li><a href="/jest/ru">Русский</a></li><li><a href="/jest/uk">Українська</a></li><li><a href="/jest/zh-Hans">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/getting-started.html">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/using-matchers.html">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/asynchronous.html">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/setup-teardown.html">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/mock-functions.html">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/more-resources.html">More Resources</a></li></ul></div><div class="navGroup navGroupActive"><h3>API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/api.html">Globals</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/expect.html">Expect</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/mock-function-api.html">Mock Functions</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/jest/docs/pt-BR/jest-object.html">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/configuration.html">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/cli.html">Jest CLI Options</a></li></ul></div><div class="navGroup navGroupActive"><h3>Framework Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/tutorial-react.html">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/tutorial-react-native.html">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/testing-frameworks.html">Testing Web Frameworks</a></li></ul></div><div class="navGroup navGroupActive"><h3>Guides</h3><ul><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/snapshot-testing.html">Teste de Snapshot</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/tutorial-async.html">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/timer-mocks.html">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/manual-mocks.html">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/webpack.html">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/migration-guide.html">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/jest/docs/pt-BR/troubleshooting.html">Troubleshooting</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>The Jest Object</h1></header><article><div><span><p>O objeto <code>jest</code> é automaticamente inserido no escopo de cada arquivo de teste. Os métodos no objeto <code>jest</code> ajudam a criar simulações (mock, em inglês) e deixam você controlar o comportamento geral de Jest.</p>
<h2><a class="anchor" name="metodos"></a>Métodos <a class="hash-link" href="#metodos">#</a></h2>
<ul>
<li><a href="#jestclearalltimers"><code>jest.clearAllTimers()</code></a></li>
<li><a href="#jestdisableautomock"><code>jest.disableAutomock()</code></a></li>
<li><a href="#jestenableautomock"><code>jest.enableAutomock()</code></a></li>
<li><a href="#jestfnimplementation"><code>jest.fn(implementation)</code></a></li>
<li><a href="#jestismockfunctionfn"><code>jest.isMockFunction(fn)</code></a></li>
<li><a href="#jestgenmockfrommodulemodulename"><code>jest.genMockFromModule(moduleName)</code></a></li>
<li><a href="#jestmockmodulename-factory-options"><code>jest.mock(moduleName, factory, options)</code></a></li>
<li><a href="#jestunmockmodulename"><code>jest.unmock(moduleName)</code></a></li>
<li><a href="#jestdomockmodulename-factory-options"><code>jest.doMock(moduleName, factory, options)</code></a></li>
<li><a href="#jestdontmockmodulename"><code>jest.dontMock(moduleName)</code></a></li>
<li><a href="#jestclearallmocks"><code>jest.clearAllMocks()</code></a></li>
<li><a href="#jestresetallmocks"><code>jest.resetAllMocks()</code></a></li>
<li><a href="#jestrestoreallmocks"><code>jest.restoreAllMocks()</code></a></li>
<li><a href="#jestresetmodules"><code>jest.resetModules()</code></a></li>
<li><a href="#jestrunallticks"><code>jest.runAllTicks()</code></a></li>
<li><a href="#jestrunalltimers"><code>jest.runAllTimers()</code></a></li>
<li><a href="#jestadvancetimersbytimemstorun"><code>jest.advanceTimersByTime(msToRun)</code></a></li>
<li><a href="#jestrunonlypendingtimers"><code>jest.runOnlyPendingTimers()</code></a></li>
<li><a href="#jestsetmockmodulename-moduleexports"><code>jest.setMock(moduleName, moduleExports)</code></a></li>
<li><a href="#jestsettimeouttimeout"><code>jest.setTimeout(timeout)</code></a></li>
<li><a href="#jestusefaketimers"><code>jest.useFakeTimers()</code></a></li>
<li><a href="#jestuserealtimers"><code>jest.useRealTimers()</code></a></li>
<li><a href="#jestspyonobject-methodname"><code>jest.spyOn(object, methodName)</code></a></li>
</ul>
<hr>
<h2><a class="anchor" name="referencia"></a>Referência <a class="hash-link" href="#referencia">#</a></h2>
<h3><a class="anchor" name="jestclearalltimers"></a><code>jest.clearAllTimers()</code> <a class="hash-link" href="#jestclearalltimers">#</a></h3>
<p>Remove quaisquer temporizadores pendentes do sistema de temporizador.</p>
<p>Isto significa que se quaisquer temporizadores foram programados (mas ainda não foram executados), eles serão apagados e nunca terão a oportunidade de executar no futuro.</p>
<h3><a class="anchor" name="jestdisableautomock"></a><code>jest.disableAutomock()</code> <a class="hash-link" href="#jestdisableautomock">#</a></h3>
<p>Desabilita simulações automáticas no carregador de módulo.</p>
<p>Depois que esse método é chamado, todos os <code>require()</code> irão retornar as versões reais de cada módulo (em vez de uma versão simulada, ou mocked).</p>
<p>Isto é geralmente útil quando você tiver um cenário onde o número de dependências que se quer simular (mock, em inglês) é muito menor do que o número de dependências que você não quer. Por exemplo, se você estiver escrevendo um teste para um módulo que utiliza um grande número de dependências que podem razoavelmente ser classificadas como &quot;detalhes de implementação&quot; do módulo, então você provavelmente não quer simular elas.</p>
<p>Exemplos de dependências que podem ser considerados &quot;detalhes de implementação&quot; são coisas que variam de built-ins de linguagem (por exemplo, métodos Array.prototype) para métodos de utilitário altamente comuns (por exemplo, underscore/lo-dash, utilidades de array, etc) e bibliotecas inteiras como React.js.</p>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<p><em>Nota: Este método anteriormente foi chamado <code>autoMockOff</code>. Ao usar <code>babel-jest</code>, chamadas para <code>disableAutomock</code> serão automaticamente içadas (hoisted, em inglês) até o topo do bloco de código. Use <code>autoMockOff</code> se você quiser evitar explicitamente esse comportamento.</em></p>
<h3><a class="anchor" name="jestenableautomock"></a><code>jest.enableAutomock()</code> <a class="hash-link" href="#jestenableautomock">#</a></h3>
<p>Habilita simulações automáticas no carregador de módulo.</p>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<p><em>Nota: Este método anteriormente foi chamado <code>autoMockOn</code>. Ao usar <code>babel-jest</code>, chamadas para <code>enableAutomock</code> serão automaticamente içadas (hoisted, em inglês) até o topo do bloco de código. Use <code>autoMockOn</code> se você quiser evitar explicitamente esse comportamento.</em></p>
<h3><a class="anchor" name="jestfnimplementation"></a><code>jest.fn(implementation)</code> <a class="hash-link" href="#jestfnimplementation">#</a></h3>
<p>Returns a new, unused <a href="MockFunctionAPI.html">mock function</a>. Optionally takes a mock implementation.</p>
<pre><code class="language-js">  <span class="hljs-keyword">const</span> mockFn = jest.fn();
  mockFn();
  expect(mockFn).toHaveBeenCalled();

  <span class="hljs-comment">// With a mock implementation:</span>
  <span class="hljs-keyword">const</span> returnsTrue = jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-literal">true</span>);
  <span class="hljs-built_in">console</span>.log(returnsTrue()); <span class="hljs-comment">// true;</span>
</code></pre>
<h3><a class="anchor" name="jestismockfunctionfn"></a><code>jest.isMockFunction(fn)</code> <a class="hash-link" href="#jestismockfunctionfn">#</a></h3>
<p>Determina se a função dada é uma função simulada.</p>
<h3><a class="anchor" name="jestgenmockfrommodulemodulename"></a><code>jest.genMockFromModule(moduleName)</code> <a class="hash-link" href="#jestgenmockfrommodulemodulename">#</a></h3>
<p>Dado o nome de um módulo, use o sistema automático de simulação para gerar uma versão simulada do módulo para você.</p>
<p>This is useful when you want to create a <a href="/jest/docs/pt-BR/manual-mocks.html">manual mock</a> that extends the automatic mock's behavior.</p>
<h3><a class="anchor" name="jestmockmodulename-factory-options"></a><code>jest.mock(moduleName, factory, options)</code> <a class="hash-link" href="#jestmockmodulename-factory-options">#</a></h3>
<p>Simula um módulo com uma versão auto simulada quando ele está sendo &quot;required&quot;. <code>factory</code> e <code>options</code> são opcionais. Por exemplo:</p>
<pre><code class="language-js"><span class="hljs-comment">// banana.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">'banana'</span>;

<span class="hljs-comment">// __tests__/test.js</span>
jest.mock(<span class="hljs-string">'../banana'</span>);

<span class="hljs-keyword">const</span> banana = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../banana'</span>); <span class="hljs-comment">// banana will be explicitly mocked.</span>

banana(); <span class="hljs-comment">// will return 'undefined' because the function is auto-mocked.</span>
</code></pre>
<p>O segundo argumento pode ser usado para especificar um módulo factory explícito que está sendo executado em vez de usar o recurso de automocking do Jest:</p>
<pre><code class="language-js">jest.mock(<span class="hljs-string">'../moduleName'</span>, () =&gt; {
  <span class="hljs-keyword">return</span> jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">42</span>);
});

<span class="hljs-keyword">const</span> moduleName = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../moduleName'</span>); <span class="hljs-comment">// This runs the function specified as second argument to `jest.mock`.</span>
moduleName(); <span class="hljs-comment">// Will return '42';</span>
</code></pre>
<p>O terceiro argumento pode ser usado para criar simulações virtuais – simulações de módulos que não existem em qualquer lugar no sistema:</p>
<pre><code class="language-js">jest.mock(<span class="hljs-string">'../moduleName'</span>, () =&gt; {
  <span class="hljs-comment">/*
   * Implementação personalizada de um módulo que não existe em JS,
   * como um módulo gerado ou um módulo nativo do react-native.
   */</span>
}, {<span class="hljs-attr">virtual</span>: <span class="hljs-literal">true</span>});
</code></pre>
<p><em>Aviso: Importar um módulo em um arquivo de instalação (conforme especificado pelo <code>setupTestFrameworkScriptFile</code>) impedirá a simulação para o módulo em questão, bem como todos os módulos que ele importa.</em></p>
<p>Módulos que são simulados (mocked, em inglês) com <code>jest.mock</code> são simulados apenas para o arquivo que chama <code>jest.mock</code>. Outro arquivo que importa o módulo receberá a implementação original, mesmo se executado após o arquivo de teste que simula o módulo.</p>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<h3><a class="anchor" name="jestunmockmodulename"></a><code>jest.unmock(moduleName)</code> <a class="hash-link" href="#jestunmockmodulename">#</a></h3>
<p>Indica que o sistema de módulo nunca deve retornar uma versão simulada (mocked, em inglês) do módulo especificado no <code>require()</code> (por exemplo, que ele sempre deve retornar o módulo real).</p>
<p>O uso mais comum dessa API é para especificar ao módulo que um determinado teste pretende testar (e, portanto, não quer ser automaticamente simulado).</p>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<h3><a class="anchor" name="jestdomockmodulename-factory-options"></a><code>jest.doMock(moduleName, factory, options)</code> <a class="hash-link" href="#jestdomockmodulename-factory-options">#</a></h3>
<p>Ao usar <code>babel-jest</code>, chamadas para <code>mock</code> serão automaticamente içadas (hoisted, em inglês) até o topo do bloco de código. Use este método se você deseja evitar explicitamente esse comportamento.</p>
<p>Um exemplo de quando isso é útil é quando você quer simular (mock, em inglês) de outra maneira um módulo dentro do mesmo arquivo:</p>
<pre><code class="language-js">beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  jest.resetModules();
});

test(<span class="hljs-string">'moduleName 1'</span>, () =&gt; {
  jest.doMock(<span class="hljs-string">'../moduleName'</span>, () =&gt; {
    <span class="hljs-keyword">return</span> jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">1</span>);
  });
  <span class="hljs-keyword">const</span> moduleName = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../moduleName'</span>);
  expect(moduleName()).toEqual(<span class="hljs-number">1</span>);
});

test(<span class="hljs-string">'moduleName 2'</span>, () =&gt; {
  jest.doMock(<span class="hljs-string">'../moduleName'</span>, () =&gt; {
    <span class="hljs-keyword">return</span> jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">2</span>);
  });
  <span class="hljs-keyword">const</span> moduleName = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../moduleName'</span>);
  expect(moduleName()).toEqual(<span class="hljs-number">2</span>);
});
</code></pre>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<h3><a class="anchor" name="jestdontmockmodulename"></a><code>jest.dontMock(moduleName)</code> <a class="hash-link" href="#jestdontmockmodulename">#</a></h3>
<p>Ao usar <code>babel-jest</code>, chamadas para <code>unmock</code> serão automaticamente içadas (hoisted, em inglês) até o topo do bloco de código. Use este método se você deseja evitar explicitamente esse comportamento.</p>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<h3><a class="anchor" name="jestclearallmocks"></a><code>jest.clearAllMocks()</code> <a class="hash-link" href="#jestclearallmocks">#</a></h3>
<p>Limpa as propriedades <code>mock.calls</code> e <code>mock.instances</code> de todas as simulações. Equivalente a chamar <code>.mockClear()</code> em cada função de simulação.</p>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<h3><a class="anchor" name="jestresetallmocks"></a><code>jest.resetAllMocks()</code> <a class="hash-link" href="#jestresetallmocks">#</a></h3>
<p>Redefine o estado de todas as simulações. Equivalente a chamar <code>.mockReset()</code> em cada função simulada.</p>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<h3><a class="anchor" name="jestrestoreallmocks"></a><code>jest.restoreAllMocks()</code> <a class="hash-link" href="#jestrestoreallmocks">#</a></h3>
<h5><a class="anchor" name="available-in-jest-2110"></a>available in Jest <strong>21.1.0+</strong> <a class="hash-link" href="#available-in-jest-2110">#</a></h5>
<p>Restaura todas as simulações (mocks, em inglês) para seu valor original. Equivalente a chamar <code>.mockRestore</code> em cada função simulada. Cuidado que <code>jest.restoreAllMocks()</code> só funciona quando a simulação foi criada com <code>jest.spyOn</code>; outras simulações vão exigir você restaurá-las manualmente.</p>
<h3><a class="anchor" name="jestresetmodules"></a><code>jest.resetModules()</code> <a class="hash-link" href="#jestresetmodules">#</a></h3>
<p>Redefine o registro do módulo - o cache de todos os módulos necessários. Isso é útil para isolar módulos onde o estado local pode entrar em conflito entre os testes.</p>
<p>Exemplo:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> sum1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../sum'</span>);
jest.resetModules();
<span class="hljs-keyword">const</span> sum2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../sum'</span>);
sum1 === sum2;
<span class="hljs-comment">// &gt; false (Both sum modules are separate "instances" of the sum module.)</span>
</code></pre>
<p>Exemplo em um teste:</p>
<pre><code class="language-js">beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  jest.resetModules();
});

test(<span class="hljs-string">'works'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../sum'</span>);
});

test(<span class="hljs-string">'works too'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> sum = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../sum'</span>);
  <span class="hljs-comment">// sum is a different copy of the sum module from the previous test.</span>
});
</code></pre>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<h3><a class="anchor" name="jestrunallticks"></a><code>jest.runAllTicks()</code> <a class="hash-link" href="#jestrunallticks">#</a></h3>
<p>Esgota a pilha de <strong>micro</strong>-task (geralmente usando um interface node via <code>process.nextTick</code>).</p>
<p>Quando esta API for chamada, todas micro-tasks pendentes que foram empilhadas via <code>process.nextTick</code> serão executadas. Adicionalmente, caso estas micro-tasks agendem novas micro-tasks, essas por sua vez serão esgotadas até que não haja mais micro-tasks na fila.</p>
<h3><a class="anchor" name="jestrunalltimers"></a><code>jest.runAllTimers()</code> <a class="hash-link" href="#jestrunalltimers">#</a></h3>
<p>Esgota a fila de <strong>macro</strong>-task (ou seja, todas as tarefas enfileiradas por <code>setTimeout()</code>, <code>setInterval()</code> e <code>setImmediate()</code>).</p>
<p>Quando esta API é chamada, todas as &quot;macro-tasks&quot; pendentes que foram enfileiradas via <code>setTimeout()</code> ou <code>setInterval()</code> serão executadas. Adicionalmente, caso estas macro-tasks agendem novas macro-tasks, essas por sua vez serão esgotadas até que não haja mais macro-tasks na fila.</p>
<p>Isso muitas vezes é útil para executar de modo síncrono setTimeouts durante um teste para verificar sincronicamente algum comportamento que só aconteceria após as &quot;callbacks&quot; <code>setTimeout()</code> ou <code>setInterval()</code> executarem. See the <a href="/jest/docs/pt-BR/timer-mocks.html">Timer mocks</a> doc for more information.</p>
<h3><a class="anchor" name="jestrunallimmediates"></a><code>jest.runAllImmediates()</code> <a class="hash-link" href="#jestrunallimmediates">#</a></h3>
<p>Esgota todas as tarefas enfileiradas por <code>setImmediate()</code>.</p>
<h3><a class="anchor" name="jestadvancetimersbytimemstorun"></a><code>jest.advanceTimersByTime(msToRun)</code> <a class="hash-link" href="#jestadvancetimersbytimemstorun">#</a></h3>
<h5><a class="anchor" name="renamed-in-jest-2130"></a>renamed in Jest <strong>21.3.0+</strong> <a class="hash-link" href="#renamed-in-jest-2130">#</a></h5>
<p>Also under the alias: <code>.runTimersToTime()</code></p>
<p>Executa somente a fila de tarefas macro (ou seja, todas as tarefas enfileiradas por <code>setTimeout()</code> ou <code>setInterval()</code> e <code>setImmediate()</code>).</p>
<p>When this API is called, all timers are advanced by <code>msToRun</code> milliseconds. All pending &quot;macro-tasks&quot; that have been queued via <code>setTimeout()</code> or <code>setInterval()</code>, and would be executed within this timeframe will be executed. Adicionalmente, caso estas macro-tarefas agendem novas macro-tarefas que seriam executadas dentro do mesmo prazo, aquelas serão executadas até que não haja mais nenhuma macro-tarefa restante na fila que deve ser executada dentro de <code>msToRun</code> milissegundos.</p>
<h3><a class="anchor" name="jestrunonlypendingtimers"></a><code>jest.runOnlyPendingTimers()</code> <a class="hash-link" href="#jestrunonlypendingtimers">#</a></h3>
<p>Executa somente as macro-tasks que estão atualmente pendentes (ou seja, apenas as tarefas que foram enfileiradas por <code>setTimeout()</code> ou <code>setInterval()</code> até este ponto). Se qualquer uma das macro-tasks atualmente pendentes agendar novas macro-tasks, essas novas tarefas não serão executadas por essa chamada.</p>
<p>Isso é útil para cenários como aquele onde o módulo sendo testado agendará um <code>setTimeout()</code> cuja &quot;callback&quot; agenda outro <code>setTimeout()</code> recursivamente (ou seja, o agendamento nunca para). Nesses cenários, é útil ser capaz de executar para a frente no tempo, um passo de cada vez.</p>
<h3><a class="anchor" name="jestsetmockmodulename-moduleexports"></a><code>jest.setMock(moduleName, moduleExports)</code> <a class="hash-link" href="#jestsetmockmodulename-moduleexports">#</a></h3>
<p>Explicitamente fornece o objeto simulado (mock, em inglês) que o sistema de módulo deve retornar para o módulo especificado.</p>
<p>Às vezes, há ocasiões em que a simulação automaticamente gerada, que o sistema de módulo normalmente lhe providencia, não é adequada o suficiente para suas necessidades de testes. Normally under those circumstances you should write a <a href="/jest/docs/pt-BR/manual-mocks.html">manual mock</a> that is more adequate for the module in question. No entanto, em ocasiões extremamente raras, até mesmo um simulação manual não é apropriada para seus propósitos e você precisa construir a simulação você mesmo dentro de seu teste.</p>
<p>Nessas situações raras, você pode usar essa API para preencher manualmente o slot do registro &quot;mock-module&quot; no sistema do módulo.</p>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<p><em>Nota: recomenda-se usar ao invés <a href="#jestmockmodulename-factory-options"> <code>jest.mock()</code></a>. O segundo argumento da API <code>jest.mock</code> é uma fábrica de módulo, em vez do esperado objeto do módulo exportado.</em></p>
<h3><a class="anchor" name="jestsettimeouttimeout"></a><code>jest.setTimeout(timeout)</code> <a class="hash-link" href="#jestsettimeouttimeout">#</a></h3>
<p>Define o tempo limite de execução padrão para testes antes/depois de ganchos em milissegundos.</p>
<p><em>Nota: O tempo limite de execução padrão é 5 segundos caso este método não seja chamado.</em></p>
<p>Exemplo:</p>
<pre><code class="language-js">jest.setTimeout(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 1 segundo</span>
</code></pre>
<h3><a class="anchor" name="jestusefaketimers"></a><code>jest.useFakeTimers()</code> <a class="hash-link" href="#jestusefaketimers">#</a></h3>
<p>Instrui Jest para usar versões falsas das funções de temporizador padrão (<code>setTimeout</code>, <code>setInterval</code>, <code>clearTimeout</code>, <code>clearInterval</code>, <code>nextTick</code>, <code>setImmediate</code> e <code>clearImmediate</code>).</p>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<h3><a class="anchor" name="jestuserealtimers"></a><code>jest.useRealTimers()</code> <a class="hash-link" href="#jestuserealtimers">#</a></h3>
<p>Instrui Jest para usar as versões reais das funções de temporizador padrão.</p>
<p>Retorna o objeto <code>jest</code> para encadeamento.</p>
<h3><a class="anchor" name="jestspyonobject-methodname"></a><code>jest.spyOn(object, methodName)</code> <a class="hash-link" href="#jestspyonobject-methodname">#</a></h3>
<h5><a class="anchor" name="disponivel-no-jest-1900"></a>disponível no Jest <strong>19.0.0+</strong> <a class="hash-link" href="#disponivel-no-jest-1900">#</a></h5>
<p>Cria uma função de simulação (mock, em inglês) semelhante ao <code>jest.fn</code> mas também rastreia chamadas para <code>object[methodName]</code>. Retorna uma função de simulação Jest.</p>
<p><em>Nota: Por padrão, <code>jest.spyOn</code> também chama o método <strong>spied</strong>. Este é um comportamento diferente da maioria das outras bibliotecas de teste. Se você deseja substituir a função original, você pode usar <code>jest.spyOn(object, methodName).mockImplementation(() =&gt; customImplementation)</code> ou <code>object[methodName] = jest.fn(() =&gt; customImplementation);</code></em></p>
<p>Exemplo:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> video = {
  play() {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  },
};

<span class="hljs-built_in">module</span>.exports = video;
</code></pre>
<p>Exemplo do teste:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> video = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./video'</span>);

test(<span class="hljs-string">'plays video'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> spy = jest.spyOn(video, <span class="hljs-string">'play'</span>);
  <span class="hljs-keyword">const</span> isPlaying = video.play();

  expect(spy).toHaveBeenCalled();
  expect(isPlaying).toBe(<span class="hljs-literal">true</span>);

  spy.mockReset();
  spy.mockRestore();
});
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="mock-function-api.html">← Mock Functions</a><a class="docs-next button" href="configuration.html">Configuring Jest →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/jest/" class="nav-home"><img src="/jest/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/jest/docs/pt-BR/getting-started.html">Getting Started</a><a href="/jest/docs/pt-BR/snapshot-testing.html">Guides</a><a href="/jest/docs/pt-BR/api.html">API Reference</a></div><div><h5>Community</h5><a href="/jest/pt-BR/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://discordapp.com/channels/102860784329052160/103622435865104384">Jest Chat</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/jest/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-count-api="/repos/facebook/jest#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/jest/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2017 Facebook Inc.</section></footer></div><script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><script>
              var search = docsearch({
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react'
              });
            </script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>